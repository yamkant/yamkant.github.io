---
layout: archive
title:  "[DB] [Real MySQL 8.0] 내용 정리 "
date:   2023-05-14 22:05:07 +0900
categories: [DB]
---

CH 4.1.4 플러그인 스토리지 엔진 모델
- MySQL의 독특한 구조 중 대표적인 것이 플러그인 모델입니다.
- MySQL에서 쿼리가 실행되는 과정 대부분은 MySQL엔진에서 처리되고, 마지막 ‘데이터 읽기/쓰기’ 자업만 스토리지 엔진에 의해 처리됩니다.
(데이터 읽기/쓰기 작업은 대부분 1건의 레코드 단위로 처리)
- MySQL 엔진은 스토리지 엔진을 조정하기 위해 핸들러를 사용합니다. 따라서 `Handler_`로 시작되는 상태변수가 많습니다.
- `GROUP BY`와 `ORDER BY` 등의 복잡한 처리는 MySQL 엔진의 처리 영역인 ‘쿼리 실행기’에서 처리됩니다.
- 앞으로의 여정에서는, 하나의 쿼리 작업에서 나뉘어 지는 여러 하위 작업들이 MySQL 엔진 영역에서 처리되는지, 스토리지 엔진 영역에서 처리되는지 구분하게 될 것입니다.
- mysqld에서 지원되는 스토리지 엔진을 확인하는 명령어
`mysql> SHOW ENGINS;`
- 인증 및 전문 검색용 파서와 같은 플러그인을 확인하는 명령어
`mysql> SHOW PLUGINS;`

CH 4.1.5 컴포넌트
- MySQL 8.0부터는 기존의 플러그인 아키텍처를 **대체하기 위해** 컴포넌트 아키텍처가 지원됩니다. 
- 기존 플러그인의 단점
	- MySQL 서버와만 통신 가능하며, 플러그인끼리 통신 불가
	- MYSQL 서버의 변수나 함수를 직접 호출 -> 캡슐화 안 됨
	- 상호 의존관계를 설정할 수 없어 초기화 어려움

CH 4.1.6 쿼리 실행 구조
- 쿼리파서 -> 전처리기 -> 옵티마이저 -> 실행엔진 -> 핸들러 -> 복제 -> 쿼리 캐시(deprecated) -> 스레드 풀
- 쿼리파서: 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만듭니다. (기본 문법 오류 탐지)
- 전처리기: 쿼리 문장의 구조적 문제점을 확인합니다. 테이블 이름, 컬럼 이름, 내장함수 및 객체 존재 여부, 접근 권한을 확인합니다.
- 옵티마이저: DBMS의 두뇌에 해당하는 부분으로, 쿼리를 최적화합니다.
- 실행엔진: 핸들러에게 실행 계획 요청 하고, 요청에 대한 응답을 다른 핸들러에게 전달하는 역할을 수행합니다.
- 핸들러(스토리지 엔진): 실행 엔진의 요청에 따라 데이터를 디스크로 저장하거나 읽어옵니다. 따라서 스토리지 엔진을 의미합니다.
- 복제: Replication 기능을 답당합니다.
- 스레드풀
	- 내부적으로 사용자 요청을 처리하는 스레드 개수를 줄여서, 제한된 개수의 스레드 처리에만 집중하도록 하여 서버의 자원 소모를 줄이는 것이 목적입니다.
	- 일반적으로 CPU코어의 개수와 맞추는 것이  CPU 프로세서 친화도를 높이는 데 좋습니다.
	- `thread_pool_stall_limit`: 주기적으로 그룹의 상태를 체크하여 정해진 시간 내(ms 단위)에 작업을 끝내지 못하는 경우, 새로운 스레드에 추가합니다.
	-  `thread_pool_max_threads`: 해당 개수보다 스레드가 많아질 수 없도록 제한합니다.
	- 트랜잭션 내에 속한 SQL을 빨리 처리하면, 해당 트랜잭션이 가지고 있던 잠금이 빨리 해제되고,잠금 경합을 낮춰 전체적인 쿼리 성능이 향상됩니다.


### 4.2 InnoDB 스토리지 엔진 아키텍처
CH 4.2.1 프라이머리 키에 의한 클러스터링
- 모든 테이블은 기본적으로 PK를 기준으로 클러스터링되어 저장됩니다.
- 모든 세컨더리 인덱스는 레코드의 주소 대신 PK의 값을 논리적인 주소로 사용합니다.

CH 4.2.2 외래 키 지원
- InnoDB 스토리지 엔진 레벨에서 지원하는 기능으로, MyISAM이나 MEMORY 테이블에서는 사용할 수 없습니다.
- 부모 테이블과 자식 테이블 모두 해당 컬럼에 인덱스 생성이 필요하며, 변경 시 두 테이블에 데이터가 있는지 확인하는 작업이 필요합니다.
- 따라서, 여러 테이블에 전파되는 잠금으로 인해 데드락이 발생하는 경우가 많습니다.
- 시스템 변수  `foreign_key_checks`를 OFF로 설정하면 외래 키 관계에 대한 확인 작업을 일시적으로 멈출 수 있습니다.

CH 4.2.3 MVCC(Multi Version Concurrency Control)
- 잠금을 사용하지 않는 일관된 읽기를 제공합니다.
- MySQL의 격리 수준(solation level)은 `READ_COMMITTED`
- `UPDATE` 문장이 실행되면 커밋 실행 여부와 관계없이 InnoDB의 버퍼 풀은 새로운 값으로 업데이트 됩니다.
- InnoDB 버퍼 풀의 변경 내용은 InnoDB 스토리지 엔진의 백그라운드 스레드에 의해서 기록되므로, 버퍼 풀의 변경 내용이 디스크의 데이터 파일에 기록됐는지 여부는 시점에 따라 다를 수 있습니다. 
(InnoDB는 ACID를 보장하기 때문에 일반적으로 버퍼 풀과 데이터 파일은 동일한 상태로 가정해도 됩니다.)
- MVCC: Undo log 혹은 버퍼풀, 데이터 파일 두 버전으로 부터 필요에 따른 데이터를 불러오는 구조를 의미합니다. 
	- 격리 수준이 `READ_UNCOMMITTED`인 경우, 커밋 여부와 상관없이 변경된 상태의 데이터를 반환합니다.(버퍼 풀과 데이터 파일로부터 값 조회)
	- `READ_COMMITTED` 이상의 격리 수준에서는 아직 커밋이 되지 않았기 때문에, Undo log에서 값을 가져옵니다.

CH 4.2.4 잠금 없는 일관된 읽기(Non-Locking Consistent Read)
- InnoDB 스토리지 엔진은 MVCC를 이용해 잠금을 걸지 않고 읽기 작업을 수행합니다. 
- SERIALIZABLE 외의 격리 수준에서는 순수한 읽기 작업을 사용할 때 다른 트랜잭션의 변경 작업과 관계없이 항상 잠금을 대기하지 않고 바로 실행됩니다.
- 사용자가 UPDATE 후에 커밋하지 않더라도, 다른 사용자의 SELECT 요청을 방해하지 않는 것을 ‘잠금 없는 일관된 읽기’라고 말하며, 언두 로그에서 값을 읽습니다.
-  일관된 읽기를 위해 언두 로그를 계속 유지하려기 보다는 속도 문제가 발생할 수 있으므로, 트랜잭션이 시작됐다면 가능한 빨리 롤백이나 커밋을하여 완료해야합니다.

CH 4.2.5 자동 데드락 감지
- InnoDB 엔진은 교착 상태에 빠지지 않았는지 확인하기 위해 잠금 대기 목록을 그래프(Wait-for List) 형태로 관리합니다.
- 데드락 감지 스레드는 주기적으로 이 리스트를 검사하여 교착상태에 있는 트랜잭션을 강제 종료합니다.(언두 로그 레코드를 적게 가진 트랜잭션이 우선순위가 높음)
- 시스템 변수 `innodb_table_locks` 를 활성화하면, InnoDB 엔진 내부 레코드를 잠금할 뿐 아니라 테이블 잠그까지 감지합니다.
- 동시에 처리할 스레드가 매우 많은 경우, CPU 자원의 소모로 인해 데드락 감지 스레드가 느려지게 될 수 있습니다. 
	- `innodb_deadlock_detect`: 더 이상 데드락 감지 스레드가 동작하지 않습니다. 
	- `innodb_lock_wait_timeout`: 데드락 상태일 때, 해당 변수에 정해둔 시간이 지나면 자동으로 요청이 실패하고 에러 메시지를 반환합니다.
