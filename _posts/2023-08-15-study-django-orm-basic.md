---
layout: archive
title:  "[Study] Django - ORM Basic"
date:   2023-08-12 00:05:07 +0900
categories: 
    - Django Study
---

## ORM이란 무엇인가?

- 객체지향 프로그래밍은 클래스를 사용하지만, 관계형 데이터베이스는 테이블을 사용하기 때문에, 객체 모델과 관계형 모델 간에 불일치가 발생합니다.
- ORM은 SQL문을 자동으로 생성하여 이러한 불일치를 해결할 수 있습니다.

## ORM의 장단점

### 장점

- 완벽한 객체지향적인 코드
    - SQL문이 아닌 클래스의 메서드를 통한 데이터베이스 조작이 가능하기 때문에, 개발자가 객체 모델만을 이용해서 프로그래밍을하는데 집중할 수 있습니다.
    - SQL문을 사용하며 함께 필요한 선언문, 할당, 종료와 같은 부수적인 코드가 사라지거나 줄어들게 됩니다.
- 재사용, 유지보수, 리팩토링이 용이합니다.
- DBMS에 대한 종속성이 줄어듭니다.
    - 객체 간의 관계를 바탕으로 SQL문을 자동으로 생성하며, 객체의 자료형 타입까지 사용할 수 있습니다.
    - 따라서, RDBMS의 데이터 구조와 객체지향 모델 사이의 간격을 좁힐 수 있습니다.

### 단점

- 프로젝트의 복잡성이 커질수록 난이도도 올라가고, 잘못 구현되는 경우 속도 저하가 발생합니다. 일관성을 무너뜨리게 될 수도 있습니다.
- 잘못된 사용으루 N+1 문제와 같은 비효율적인 동작을 야기할 수 있습니다.
- 대형 SQL문은 속도를 위해 별도의 튜닝이 필요하므로, 결국 SQL문법을 사용해야할 때가 생깁니다.
- 쿼리문이 복잡한 경우, SQL문 사용이 직관적이고 효율적일 수 있습니다.

### ORM을 적절하게 사용하는 방법

**타겟 DB를 이해하기**

- SQL 및 DB의 locking 모델을 무시하면 안됩니다.
- ORM 적용 환경에서 발생하는 많은 부류의 문제들은 DB와 SQL의 문제를 간과함에서 발생합니다.

**필요한 경우 SQL을 사용하기**

- Hibernate, TopLink와 같은 ORM들은 SQL 쿼리 작성 기능을 제공하지만, 경우에 따라 SQL문을 직접 작성해야합니다.

**O-R 매핑 제품을 선택하기 전에 충분히 검토하기**

- 모든 ORM 제품이 동일한 수준의 기능을 제공하지 않기 때문에, 요구 사항을 반영하는 환경을 구축하고 제품들을 비교, 테스트 해야합니다.
- 엔터프라이즈 개발 과정의 다른 요소들과 마찬가지로, 프로젝트 라이프사이클 초기 단계에서 성능과 관련된 리스크를 최소화하는 것이 중요합니다.
- 매핑 기능에 과도한 오버헤드가 수반되지 않는지 분석해야 합니다.

**ORM이 적절히 사용될 수 있는 상황을 이해하기**

- ORM은 엔티티를 개별적으로 업데이트하고 간헐적으로 셋 기반 작업을 수행하는 OLTP 애플리케이션이 적합합니다.

**ORM이 적합하지 않은 경우**

- 많은 수의 레코드에 대해 잦은 빈도로 bulk 업데이트를 수행하는 애플리케이션(OLAP 애플리케이션)
- 데이터 마이닝을 위해 사용되는 애플리케이션에서는 이미 데이터를 본래의 엔티티 상태로 사용하기 어렵습니다.
- 데이터의 인출 및 업데이트를 위해 핸드코딩으로 작성된 SQL 및 저장 프로시저를 이용하는 DB 환경
- 순수 SQL 기반 접근 방법을 적용하는 것이 적절한 애플리케이션
    - 비즈니스 로직의 대부분이 DB에 이미 구현되어 있거나, 데이터베이스 무결성 제약(integrity constraint)이 적용된 경우 등입니다.
    - 이러한 애플리케이션에서는 오브젝트 또는 ORM의 활용 여지가 적으며, 데이터베이스 테이블을 도메인 오브젝트로 모델링 함으로써 기대할 수 있는 효과가 거의 없습니다.

## Django ORM의 특징

### QuerySet

- Django ORM을 통해 생성된 자료형으로, 데이터베이스의 테이블로부터 가져온 객체의 목록입니다.

### Lazy Loading

- 필요한 시점에만 SQL을 호출하는 Lazy한 특성이 있습니다.
- `users=User.objects.all()` 문법을 사용하더라도, 이 때 DB를 호출하는 것이 아닌, `user=users[0]`, `list(users)`와 같이 실제 파이썬에서 해당 데이터를 사용할 때 호출됩니다.
- 따라서, `Result Cache`를 통해 미리 데이터를 캐싱해두는 것이 더 효율적입니다. `user_list=list(User.objects.all())`
- 지연 로딩의 또 다른 문제는, 외래키 관계에 있는 데이터를 참조해서 호출할 때 발생합니다. lazy-loading은 쿼리문이 날라갈 때 당장 필요하지 않기 때문에 참조모델의 데이터는 가지고 오지 않고 해당 모델이 갖는 한개의 데이터를 가져옵니다.
- 따라서, 외래키 값을 호출할 때 한 번 더 쿼리가 날라가는 `N+1 문제`가 발생하게 됩니다.

### Eager Loading

- N+1 문제를 해결하기 위해, `select_related()`와 `prefetch_related()` 메서드로 즉시 로딩할 수 있습니다.
- `select_related()`는 join을 통해 데이터를 즉시 로딩하는 방법으로, 정참조 외래키에서 사용됩니다.
- `prefetch_related()`: 추가 쿼리를 수행해서 데이터를 즉시 로딩하는 방법으로, 역참조 외래키에서 사용됩니다.

## 참고
- [bentist님의 블로그](https://bentist.tistory.com/109)