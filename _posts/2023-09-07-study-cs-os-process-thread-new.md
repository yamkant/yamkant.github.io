---
layout: archive
title:  "[Study] Operating System - Process, Thread, System call"
date:   2023-09-07 00:05:07 +0900
categories: 
    - Study
---

## 컴퓨터의 구조 (코어와 스레드)
- OS kernel은 사용자 프로그램과 Memory, CPU, Device를 다루는 연결고리 역할을 합니다.

### 코어와 스레드
- 코어는 코어 자체의 연산작업에 비해, 메모리에서 데이터를 기다리는 시간이 오래 걸립니다. 이는 결국 코어의 자원 낭비로 이어집니다.
- Q. OS 스레드 여덟 개를 하이퍼 스레딩이 적용된 인텔 듀얼코드 위에서 동작시키려면 OS 스레드들을 어떻게 코어에 균등하게 할 수 있을까요? 라는 질문의 답을 찾을 수 있습니다.

### 하드웨어 스레드
- 메모리에서 데이터를 기다리는 중에도 계속해서 작업을 하고자 합니다. 따라서 병렬적인 작업을 실행하기 위한 처리, 즉 하드웨어 스레드 개념이 등장합니다.  
  (인텔은 이를 Hyper-threading이라고 명명하였으며, 물리적인 코어마다 하드웨어 스레드가 두 개인 경우를 의미합니다.)
- Hardware thread는 OS 관점에서 볼 때는 가상의(logical) `코어`입니다. 따라서, 싱글 코어 CPU에서 하드웨어 스레드가 두 개라면 OS는 CPU를 듀얼코어로 인식합니다. 이에 맞춰 OS 레벨의 스레드들을 스케줄링합니다.

### OS 스레드
- 일반적으로 알고 있는 스레드 개념으로, OS 커널 레벨에서 생성되고 관리되는 스레드입니다.
- 네이티브 스레드, 커널 스레드, 커널-레벨 스레드, OS-레벨 스레드로 불리기도 합니다.
- CPU에서 실제로 실행되는 단위이며 CPU 스케줄링의 단위가 OS 스레드입니다.
- OS 스레드의 컨텍스트 스위칭은 커널이 주도적으로 진행합니다. [유저모드 -> 커널모드] -> 커널코드 CPU에서 실행(CPU 리소스 사용) -> [커널모드 -> 유저모드]
- System call 유저모드는 System call을 통해 커널 모드로 진입하고, 커널코드를 실행시킬 수 있게 됩니다. 사용자 코드와 커널코드 모두 OS 스레드에서 실행됩니다. ㅎ
- A. OS는 가상의 코어를 4개라고 생각하기 때문에 각각의 코어의 OS 스레드를 2개씩 사용하여 8개의 스레드를 균등하게 배치할 수 있습니다.

### User Thread
- 유저-레벨 스레드라고 불리며, 스레드 개념을 프로그래밍 레벨에서 추상화한 것을 의미합니다. OS와는 독립적으로 유저레벨에서 스케줄링되는 스레드입니다.
- 유저 스레드가 CPU에서 실행되려면 OS 스레드와 반드시 연결돼야 합니다.
- Java에서 `Thread.start()`라는 코드를 통해 OS의 system call의 clone(리눅스의 경우)이라는 호출되고 OS level의 thread를 생성하여 연결됩니다.
- 유저 스레드와 OS 스레드를 어떻게 연결시킬 것인가?

**One-to-One Model**
- 시스템 콜을 통해 유저 스레드와 OS 레벨의 스레드를 1:1로 연결되는 모델로, 스케쥴링을 포함한 스레드 관리를 OS에 위임합니다.
- 따라서, 커널 레벨에서 스레드가 아닌 코어를 할당하는 경우에도 같은 방식으로 작업이 진행됩니다.
- 한 스레드가 블락되어도 다른 스레드는 잘 동작합니다. 
- 실행 방법에 따라 race condition이 발생할 확률이 높습니다.

**Many-to-One Model**
- 여러 유저-레벨 스레드가 하나의 OS 스레드와 연결되는 경우입니다.
- 커널이 개입하지 않기 때문에 유저 스레드 간 context switching 속도가 빠릅니다.
- 배정되는 OS 스레드가 하나이기 때문에 멀티코어를 활용할 수 없습니다.
- 한 스레드가 블락될 때 모든 스레드가 블락됩니다. (-> non block I/O를 사용하기 됨)
- race condition이 발생할 확률이 낮습니다.

**Many-toMany Model**
- 위의 두 모델의 장점을 합쳐 사용하는 경우입니다.
- 유저 스레드 간에 스위칭이 빠르면서 멀티 코어를 활용하게 되고, 하나의 OS 스레드가 블락되더라도 다른 스레드를 사용할 수 있습니다.
- 하지만 구현이 어렵다는 단점이 있습니다.

### Green Thread
- 과거에는 자바의 초창기 스레딩 모델의 초창기 스레드 모델로, Many-to-One 모델의 스레드를 의미합니다.
- 현재는 OS와는 독립적으로 유저 레벨에서 스케쥴링되는 스레드로, Many-to-One, Many-to-Many 모델을 사용하는 유저 스레드를 의미합니다.

### Kernel Thread
- OS 커널의 역할을 수행하는 스레드를 의미하기도 하지만, 커널 코드(시스템콜)를 실제로 실행하는 OS 커널의 역할을 담당하는 스레드로 해석할 수도 있습니다.

## Thread Pool
- `Thread per request model`: 하나의 쓰레드가 하나의 리퀘스트를 사용하는 방식입니다. 만약, 이 모델에서 요청마다 스레드를 새로 만들어서 처리하고 처리가 끝난 스레드는 버리는 식으로 동작한다면? 스레드 생성에 소요되는 시간 때문에 요청 처리가 오래 걸릴 것입니다.
- 처리 속도보다 빠르게 요청이 늘어나는 경우, 스레드 수 증가에 따른 컨텍스트 스위칭 빈도 급증, CPU 오버헤드 증가와 같은 문제가 발생할 수 있습니다.
- 위의 문제들을 해결하기 위해 스레드 풀이라는 개념이 등장합니다. 정해진 개수만큼의 스레드를 미리 생성하고, 들어오는 요청들을 서버 내부에서 관리하게 됩니다. (제한된 개수의 스레드를 운용하므로써 무제한으로 스레드가 생성되는 것을 방지합니다.)
- 사용하는 경우
  - thread per request 모델의 task를 subtask로 나누어 동시에 처리하고 싶은 경우
  - 순서에 상관없이 동시 실행이 가능한 task를 처리하는 경우

### 사용시 고려사항
**몇 개의 스레드를 만드는 것이 적절할까?**
- CPU 코어 개수와 task의 성향(CPU-bound / I/O-bound)에 따라 다릅니다.
  - CPU-bound task의 경우: 코어 개수만큼 혹은 그보다 몇 개 더 많은 정도
    코어개수보다 스레드를 아무리 만들어도 CPU 작업을 주로 하기 때문에 별로 의미가 없습니다. (CPU-bound: cpu를 많이 사용하는 태스크)
  - I/O-bound task의 경우: 코어개수의 몇 배가 적당할지를 경험적으로 찾아야 합니다.
- 스레드 풀에서 실행될 task의 개수에 제한이 없다면, 스레드 풀 큐의 사이즈가 제한이 있는지 확인해야합니다.
  - 만약, 제한이 없다면 큐에 계속해서 요청이 쌓일 것이고 이를 모두 해결할 수 없기 때문에 전체 시스템이 망가지는 경우가 발생할 수 있습니다.
  - 따라서, 제한을 두어 몇 개의 요청은 버리더라도 전체 시스템을 안전하게 하는 식으로 처리합니다.

### Pool
- Thread Pool 외에도 Connection Pool, Process Pool이 있습니다.
- 특히 파이썬에서는, Global Interpreter Lock이라는 개념 때문에, 동시에 여러 개의 쓰레드가 CPU에서는 실행될 수 없기 때문에 Process Pool을 사용해야 합니다.

## 유저모드, 커널모드
- 우리가 개발하는 프로그램은 유저모드에서 실행됩니다.
- 프로그램 실행 중, 인터럽트(interrupt)나 시스템 콜(system call)이 발생하면 커널모드에 진입합니다.
- 커널모드로 진입 시, 다시 유저모드로 돌아와 작업할 수 있도록 하기 위해, 프로그램의 현재 CPU의 상태를 저장하는 작업도 함께 수행합니다.
- 커널 모드에서는 커널이 인터럽트나 시스템 콜을 직접 처리합니다. 모든 처리가 완료되면 중단되었던 프로그램의 CPU 상태를 복원하고, 유저 모드에 실행권을 넘깁니다.

### 커널
- 운영체제의 핵심으로, 시스템의 전반을 관리/감독하는 역할을 합니다.
- 하드웨어(device)와 관련된 작업을 직접 수행합니다.
- 유저와 하드웨어 사이에서 안정적으로 시스템을 사용하도록 제어하기 위해 존재합니다.

### 인터럽트
- 시스템에서 발생한 다양한 종류의 이벤트 혹은 이벤트를 알리는 메커니즘
- 전원에 발생한 문제, I/O 작업 완료 시, timer가 측정하는 시간이 만료될 때 등의 종류가 있습니다.
- 0으로 나누어질 때, 잘못된 메모리 공간에 접근을 시도할 때 -> 프로그램 레벨에서 발생하는 인터럽트로, 보통 트랩이라고 불립니다.
- 인터럽트 발생 시, CPU에서는 즉각적으로 커널코드를 커널 모드에서 실행합니다.

### 시스템콜
- 프로그램이 OS 커널이 제공하는 서비스를 이용하고자 할 때 사용하는 기능입니다.
- 프로세스/스레드 제어(생성/삭제) 관련, 파일 I/O 관련, 소켓 관련, 장치(device) 관련(키보드 인풋 등), 프로세스 통신 관련 등의 종류가 있습니다.

## 컨텍스트 스위칭
- CPU/코어에서 실행 중이던 프로세스가 다른 프로세스로, 스레드가 다른 스레드로 교체되는 것을 의미하며, 여러 프로그램을 동시에 실행시키기 위해 필요합니다.
- 컨텍스트란 무엇인가? 프로세스 혹은 스레드의 상태로, CPU(레지스터들)나 메모리의 상태입니다.
- 컨텍스트 스위칭은 언제 발생할까?
  - 주어진 time slice(quantum)를 다 사용한 경우
  - I/O 작업을 해야 하는 경우
  - 다른 리소스를 기다리는 경우
- OS 커널(각종 리소스를 관리 및 감독하는 역할을 함)에 의해 컨텍스트 스위칭은 실행됩니다. (통제권을 커널이 가짐)
- 프로세스 컨텍스트 스위칭과 스레드 컨텍스트 스위칭 두 종류가 있습니다. 둘 다 커널모드에서 실행되며, CPU의 레지스터 상태(프로그램이 어디까지 실행되었는지에 대한 정보를 저장)를 교체한다는 공통점이 있습니다.
- 컨텍스트 스위칭이 미치는 간접적인 영향은 캐시가 오염된다는 것입니다. 일반적으로 프로그램이 실행되면, 메모리에 자주 접근하는 것을 피하기 위해 캐시를 사용하는데, 컨텍스트 스위칭 발생시 캐시에 있는 값이 오염될 수 있습니다.
- 따라서, 몇몇 CPU 아키텍처는 프로세스 컨텍스트 스위칭이 발생할 때 캐시까지 비우기도 합니다.

### 프로세스 컨텍스트 스위칭
- 멀티 프로세스 작업의 경우, 서로 다른 프로그램이 서로 다른 메모리 주소를 가지므로, 가상 메모리 주소 체계가 다릅니다.
- 따라서 가상 메모리 주소 관련 처리를 추가적으로 수행하기 때문에 쓰레드 컨텍스트 스위칭보다 느립니다. (참고: MMV, TLB를 비워줘야 함)

## CPU bound, I/O bound
- CPU: 프로세스의 명령어를 해석하고 실행하는 장치입니다.
- IO: 파일을 읽고 쓰거나 네트워크의 어딘가에 있는 데이터를 주고받거나, 입출력 장치와 데이터를 주고받는 것을 의미합니다.
- 버스트: 버스트란 어떤 현상이 짧은 시간 안에 집중적으로 일어나는 것입니다.
- CPU 버스트: 메모리에 올라가 있는 프로세스가 자신의 차례가 되어 CPU에서 실행되었을 때, 자신의 명령어가 CPU에서 한 번에 연속적으로 실행되는 시간을 의미합니다.
- I/O 버스트: 프로세스가 I/O 작업을 요청하고 그 결과를 기다리는 시간을 의미합니다.
- 따라서, 프로세스는 CPU 버스트와 I/O 버스트의 연속적인 과정으로 볼 수 있습니다.

### CPU bound 프로세스
- CPU 버스트가 많은 프로세스를 의미합니다.
- CPU 버스트가 많은 프로세스
  - 동영상 편집 프로그램
  - 머신러닝 프로그램: 연산작업이 많기 때문에, CPU도 부족하여 GPU를 활용한 병렬처리 작업을 수행합니다.

### I/O bound 프로세스
- I/O 버스트가 많은 프로세스를 의미합니다.
- 일반적인 백엔드 API 서버로, HTTP request를 받으면 DB 서버나 캐시 서버에 데이터를 요청하여 요청 데이터를 받은 후, 이를 가공하여 응답합니다.
- DB 서버 및 캐시 서버를 요청하는 작업이 I/O 작업입니다. 이는 CPU에서 명령을 수십 개 처리하는 것보다 시간이 오래 걸립니다.

### 적당한 코어 및 스레드 할당량
- 컨텍스트 스위칭과 연관이 있습니다. 스레드를 많이 만든다고 무조건 좋은 것이 아닙니다. 어떤 바운드이냐에 따라 전략을 다르게 가져가야 합니다.
- CPU bound 프로그램에서 적절한 스레드 수는 CPU의 수 + 1입니다. (Goetz)
- API 서버가 thread per request 방식이라면 스레드의 수를 미리 정해야 하는데, 이때 여러 상황을 고려하여 그 개수를 결정하는 것이 필요합니다.



## 참고
- [쉬운코드님 운영체제 - 스레드 종류](https://youtu.be/vorIqiLM7jc?si=Dg18EAWVIsaatwHc)
- [쉬운코드님 운영체제 - 스레드풀](https://youtu.be/B4Of4UgLfWc?si=o8eit1DoM0_S-IRe)
- [쉬운코드님 운영체제 - 컨텍스트 스위칭](https://youtu.be/Xh9Nt7y07FE?si=OtGfc4S82qOJ2U2d)