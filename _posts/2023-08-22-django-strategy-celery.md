---
layout: archive
title:  "[Django] 테스트는 어떻게 수행할까? (query count 포함)"
date:   2024-08-22 00:05:07 +0900
categories: [Strategy]
---

### Celery란?
- Distributed Task Queue. 종합적인 비동기 처리기입니다.
- 동기적으로 수행하지 않아도 되는 일들을 처리해주는 역할을 합니다. 결과를 즉시 받을 필요가 없거나 지연하여 처리해야 되는 일들을 비동기로 처리합니다.


### `Celery()` 설정
`backend`
- 작업 상태와 결과를 추적하는데 사용됩니다.
- 기본적으로 결과가 비활성화 되어있습니다.
- `@task(ignore_result=True)` 옵션을 설정하여 개별 작업에 대해 결과를 비활성화할 수도 있습니다.


## 참고
### 참고링크
- [nuung님 블로그 - 작업량 많은 경우 다루기](https://velog.io/@qlgks1/Django-Celery-%EB%8B%A8%EC%A0%90-Task-subTask-Signature-%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%9E%91%EC%97%85-%EB%8B%A4%EB%A3%A8%EA%B8%B0-with-network-IO)

### RPC란
- 프로세스간 통신을 위해 사용하는 IPC(Inter Process Communication) 방법의 한 종류입니다.
- 원격지의 프로세스에 접근하여 프로시저 또는 함수를 호출하여 사용합니다. 말 그대로 원격지의 프로시저를 호출하는 것입니다.
- 일반적으로 프로세스는 자신의 주소공간 안에 있는 함수만 호출하여 실행하지만, RPC를 이용하면 다른 주소공간에서 동작하는 프로세스의 함수를 실행하게 됩니다.
- RPC는 분산 컴퓨팅과 client-server 베이스로한 앱을 위한 강력한 기술로, 로컬 프로시저 호출을 확장하는 것을 기반으로 합니다.
- 호출된 프로시저의 필요가 호출하는 프로시저처럼 같은 주소 공간에 존재하지 않습니다.
- 두 프로세스들이 같은 시스템에 있거나 다른 시스템에 존재하며 네트워크가 그들을 연결하는 형태로 존재합니다.

### 프로시저와 함수의 차이
- 함수는 input에 따른 output을 반환하는 것을 목표로 합니다.
- 프로시저는 결과값 보다는 '명령 단위가 수행하는 절차'를 목적으로 합니다.

### RPC의 궁극적인 목표
- 클라이언트와 서버 간의 커뮤니케이션에 필요한 상세정보를 최대한 감추는 것입니다.
- 클라이언트가 일반 메서드를 호출하는 것처럼 원격지의 프로시저를 호출할 수 있도록 하는 것입니다.
- 서버도 마찬가지로 일반 메서드를 다루는 것처럼 원격 메서드를 다루도록 하는 것입니다.


