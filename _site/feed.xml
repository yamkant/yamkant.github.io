<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-11-07T15:14:34+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Yam’s Dev Logs</title><subtitle>An amazing website.</subtitle><author><name>Yeham Kim</name></author><entry><title type="html">[Architecture] Clean Architecture in Python</title><link href="http://localhost:4000/study/study-architecture-ddd/" rel="alternate" type="text/html" title="[Architecture] Clean Architecture in Python" /><published>2023-11-07T00:05:07+09:00</published><updated>2023-11-07T00:05:07+09:00</updated><id>http://localhost:4000/study/study-architecture-ddd</id><content type="html" xml:base="http://localhost:4000/study/study-architecture-ddd/"><![CDATA[<p><a href="https://github.com/Enforcer/clean-architecture">https://github.com/Enforcer/clean-architecture</a></p>

<p><a href="https://velog.io/@jahoy/Python%EC%9C%BC%EB%A1%9C-Clean-Architecture-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0">Python으로 클린 아키텍처 적용하기</a></p>

<h2 id="도메인-주도-설계-ddd가-필요하게-된-이유">도메인 주도 설계 (DDD)가 필요하게 된 이유</h2>

<p><strong>일반적 설계 모델(CRUD 방식)의 문제점</strong></p>

<ul>
  <li>생명주기(Invariant Span)가 single model을 넘어서는 경우에 로직이 복잡해집니다.</li>
  <li>code가 서로 강하게 결합(tightly coupled)되어 있는 경우, 비즈니스 로직을 테스트하기 위해 미리 많은 작업을 세팅해야하는 경우가 생깁니다. (db 불러오기, 웹 프레임워크 코드 실행)</li>
  <li>써드파티 서비스들과의 결합이 어려워집니다. 예를 들어, 외부 결제 모듈과 처음 코드를 결합시켰다면, 다른 결제 모듈로 대체하는 경우 수정하기 어려워집니다.</li>
</ul>

<p><strong>Clean Architecture의 장점</strong></p>

<ul>
  <li>Framework의 독립성: 프레임워크를 업그레이드 하거나, 교체하기 쉬워집니다.</li>
  <li>Testaiblity: 모든 비즈니스 로직을 unit test할 수 있습니다.</li>
  <li>UI/API, 서드파티 모듈, 데이터베이스를 독립적으로 사용할 수 있습니다.</li>
  <li>매우 유연하며, 확장 가능이 쉽습니다. (CQRS, Event-Sourcing, DDD 방식을 필요로 한다면 적용 가능)</li>
</ul>

<p><strong>비즈니스 룰</strong></p>

<ul>
  <li>컴퓨터 프로그램에서 실세계의 규칙에 따라 데이터를 생성, 표시, 저장, 변경하는 부분을 일컬으며, 도메인 로직이라고도 말합니다.</li>
  <li>유저의 입력(UI)과 DB 사이에서 발생한 정보 교환을 위한 특정 알고리즘이나 규칙이 정의되며, 고객의 요구에 따라 변경될 수 있습니다.</li>
</ul>

<p><strong>시스템 아키텍쳐</strong></p>

<ul>
  <li>시스템의 구조(structure), 행위(behavior), 뷰(views)를 정의하는 개념 모델입니다.</li>
  <li>시스템의 목적을 달성하기 위해 각 컴포넌트가 어떻게 상호작용하며, 어떻게 정보가 교환 되는지 설명합니다.</li>
</ul>

<h2 id="layers-of-clean-architecture"><strong>Layers of Clean Architecture</strong></h2>

<ul>
  <li>External World: DB, API, Network등 코드의 바깥쪽 외부 세계를 의미합니다.</li>
  <li>
    <p>Infrastructure: DB와 API와 같은 것들에 대한 adapter의 역할을 의미합니다.</p>

    <p><strong>Adapters</strong></p>

    <ul>
      <li>Domain과 Infrastructure 사이의 번역기 역할을 수행합니다.</li>
      <li>GUI의 MVC 아키텍처를 완전히 내포합니다. GUI(클라이언트)의 데이터를 받아 Use case들과 Entity들에게 편리한 형태로 repackage 합니다.</li>
    </ul>
  </li>
  <li>Application
    <ul>
      <li>Use Case: 하나의 비즈니스 로직으로, 유저 하나의 액션으로 구성됩니다. 입찰하기, 입찰 취소하기 등을 의미합니다. (interface의 구체화 버전으로 생각할 수 있습니다.)</li>
      <li>Interface: 추상화된 use case와 infrastructure을 추상화합니다.</li>
    </ul>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1"># application/interfaces/email_sender.py
</span>  <span class="kn">import</span> <span class="n">abc</span>
  <span class="k">class</span> <span class="nc">EmailSender</span><span class="p">(</span><span class="n">abc</span><span class="p">.</span><span class="n">ABC</span><span class="p">):</span>
         <span class="nd">@abc.abstractmethod</span>
         <span class="k">def</span> <span class="nf">send</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="n">EmailMessage</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
             <span class="k">pass</span>
  <span class="c1"># infrastructure/adapters/email_sender.py
</span>  <span class="kn">import</span> <span class="n">smtplib</span>
  <span class="kn">from</span> <span class="n">application.interfaces.email_sender</span> <span class="kn">import</span> <span class="n">EmailSender</span>
  <span class="k">class</span> <span class="nc">LocalhostEmailSender</span><span class="p">(</span><span class="n">EmailSender</span><span class="p">):</span>
      <span class="k">def</span> <span class="nf">send</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="n">EmailMessage</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
          <span class="n">server</span> <span class="o">=</span> <span class="n">smtplib</span><span class="p">.</span><span class="nc">SMTP</span><span class="p">(</span><span class="sh">'</span><span class="s">localhost</span><span class="sh">'</span><span class="p">,</span> <span class="mi">1025</span><span class="p">)</span>
          <span class="c1"># etc
</span></code></pre></div>    </div>
  </li>
  <li>Domain: identity를 가진 Entity로 구성되며, 비즈니스 룰을 담고 있습니다</li>
</ul>

<h3 id="클린-아키텍쳐의-계층과-방향성">클린 아키텍쳐의 계층과 방향성</h3>

<ul>
  <li>
    <p>External World → Infrastructure → Application → Domain의 방향성을 가집니다.</p>
  </li>
  <li><strong>Dependency Rule</strong>: 화살표 방향으로 의존성을 가지고 있습니다.
    <ul>
      <li>Application은 Domain을 사용해도, Domain은 Application을 사용하지 못합니다.</li>
      <li>Infrastructure은 Application을 사용해도, Application은 Infrastructure을 사용하지 못합니다.</li>
    </ul>
  </li>
  <li><strong>Business Rules, Processes</strong>: Application Layer와 Domain Layer 상에서 이루어지며, External World를 전혀 모르는 상태로 쉽게 Buisiness Logic의 테스트 코드를 작성할 수 있습니다.</li>
  <li><strong>Boundary</strong>: 여러개의 Interface들로 정의 됩니다. 모든 detail은 boundary 뒤에 숨어있습니다.</li>
  <li><strong>Input DTO, Output DTO, Input Boundary</strong>: Application Layer 안에 Detail을 숨기는 Boundary를 형성합니다.
    <ul>
      <li>Input DTO: Boundary에 진입할 수 있는 input argument(Request)입니다.</li>
      <li>Output DTO: Response</li>
      <li>Input Boundary: Use Case들을 추상화한 Interface입니다.</li>
    </ul>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">PlacingBidInputDto</span><span class="p">:</span>
    <span class="n">bidder_id</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">auction_id</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">amount</span><span class="p">:</span> <span class="n">Decimal</span>   
    
<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">PlacingBidOutputDto</span><span class="p">:</span>
    <span class="n">is_winning</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">current_price</span><span class="p">:</span> <span class="n">Decimal</span>                                   
    
<span class="k">class</span> <span class="nc">PlacingBidInputBoundary</span><span class="p">:</span>
    <span class="nd">@abc.abstractmethod</span>
    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">request</span><span class="p">:</span> <span class="n">PlacingBidInputDto</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
</code></pre></div></div>

<h2 id="control-flow-in-architecture">Control Flow in Architecture</h2>

<ol>
  <li>Controller: HTTP 요청을 repack하여 Input DTO로 보내며, 이는 Input Boundary(Use Case의 인터페이스)의 input으로 전달됩니다.</li>
  <li>Input Boundary: Input DTO를 이용하여 Input DTO의 데이터를 사용하며, 필요한 Entity들을 데이터 액세스 인터페이스를 통해 DB로부터 fetch합니다.</li>
  <li>Entity: 비즈니스 로직을 수행합니다. 데이터 액세스 인터페이스를 통해 변경 사항을 저장합니다.</li>
  <li>Use Case: Output Boundary(Presenter의 인터페이스 역할을 함)에 Output DTO를 전달합니다. 이 때, Presenter는 Output DTO의 데이터를 reformat하여 View에 최종적으로 보여주는 역할을 합니다.</li>
</ol>

<ul>
  <li>Input DTO, Input Boundary, Output Boundary, OutputDto, UseCase, Data Access Interface는 Application Layer에 속합니다.</li>
  <li>Entity는 Domain Layer에 속합니다.</li>
</ul>

<h3 id="sequence-diagram">Sequence diagram</h3>

<h4 id="비즈니스-요구사항-예시">비즈니스 요구사항 (예시)</h4>

<ul>
  <li>입찰자들은 경매에 입찰할 수 있다.</li>
  <li>경매에는 모든 입찰자가 볼 수 있는 실시간 가격이 있다.
    <ul>
      <li>현재 가격은 가장 낮은 낙찰가의 양에 따라 결정된다.</li>
      <li>승자가 되려면, 현재 가격보다 높은 가격을 제공해야 한다.</li>
    </ul>
  </li>
  <li>경매에는 시작 가격이 있으며, 시작 가격보다 낮은 금액의 새로운 입찰은 수락되지 않는다.</li>
</ul>

<h4 id="input-boundary-input-dto">Input Boundary, Input DTO</h4>

<p><a href="https://velog.io/@sawol/%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%81%B4%EB%9E%98%EC%8A%A4dataclasses">데이터 클래스(dataclasses)</a></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">PlacingBidInputDto</span><span class="p">:</span>
    <span class="n">bidder_id</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">auction_id</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">amount</span><span class="p">:</span> <span class="n">Decimal</span>
 
<span class="k">class</span> <span class="nc">PlacingBidInputBoundary</span><span class="p">(</span><span class="n">abc</span><span class="p">.</span><span class="n">ABC</span><span class="p">):</span>
    <span class="nd">@abc.abstractmethod</span>
    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">input_dto</span><span class="p">:</span> <span class="n">PlacingBidInputDto</span><span class="p">,</span> 
    		<span class="n">presenter</span><span class="p">:</span> <span class="n">PlacingBidOutputBoundary</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
	<span class="k">pass</span>
</code></pre></div></div>

<ul>
  <li>입력 데이터와 관련된 부분입니다.</li>
  <li><code class="language-plaintext highlighter-rouge">@dataclass</code>는 클래스 내부의 필드들의 형식을 정의함과 동시에, 매직 메서드(<strong>init</strong>, <strong>repr</strong> 등)을 기본적으로 세팅해주어 편리합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">@abc.abstractmethod</code>는 해당 추상 클래스를 상속받는 구체 클래스에서 반드시 메서드를 사용하도록 강제하는 애노테이션입니다.</li>
  <li>Input Boundary는 Use Case를 추상화합니다.</li>
</ul>

<h4 id="use-case">Use Case</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">PlacingBidUseCase</span><span class="p">(</span><span class="n">PlacingBidInputBoundary</span><span class="p">):</span>
<span class="sh">"""</span><span class="s">
1. Auction entity를 data access를 통해 retrieve
2. entity의 place bid 메소드 호출 (비즈니스 로직 수행)
3. Command 역할: 업데이트 상태변경 및 저장, return 값 없는 것이 특징
4. Output DTO 생성
5. Output DTO를 Output Boundary에 전달
</span><span class="sh">"""</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">data_access</span><span class="p">:</span> <span class="n">AuctionsDataAccess</span><span class="p">,</span> <span class="n">output_boundary</span><span class="p">:</span>
       <span class="n">PlacingBidOutputBoundary</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">self</span><span class="p">.</span><span class="n">_data_access</span> <span class="o">=</span> <span class="n">data_access</span>
        <span class="n">self</span><span class="p">.</span><span class="n">_output_boundary</span> <span class="o">=</span> <span class="n">output_boundary</span>
        
    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">input_dto</span><span class="p">:</span> <span class="n">PlacingBidInputDto</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">auction</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">_data_access</span><span class="p">.</span><span class="nf">get_auction</span><span class="p">(</span><span class="n">input_dto</span><span class="p">.</span><span class="n">auction_id</span><span class="p">)</span>
        <span class="n">auction</span><span class="p">.</span><span class="nf">place_bid</span><span class="p">(</span><span class="n">input_dto</span><span class="p">.</span><span class="n">bidder_id</span><span class="p">,</span> <span class="n">input_dto</span><span class="p">.</span><span class="n">amount</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">_data_access</span><span class="p">.</span><span class="nf">save_auction</span><span class="p">(</span><span class="n">auction</span><span class="p">)</span>
        <span class="n">output_dto</span> <span class="o">=</span> <span class="nc">PlacingBidOutputDto</span><span class="p">(</span>
            <span class="n">input_dto</span><span class="p">.</span><span class="n">bidder_id</span> <span class="ow">in</span> <span class="n">auction</span><span class="p">.</span><span class="n">winners</span><span class="p">,</span> <span class="n">auction</span><span class="p">.</span><span class="n">current_price</span>
        <span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">_output_boundary</span><span class="p">.</span><span class="nf">present</span><span class="p">(</span><span class="n">output_dto</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>모든 비즈니스 로직이 담긴 부분입니다.</li>
  <li>interface들(Higher Layer)과 코드를 구성하고 결합합니다.</li>
  <li>앞서 말한 방향성에 따라, 뒷단에서 이루어지는 concrete Implementation은 모릅니다.
(Dependency Injection을 통해 Mapping 해주게 될 것이기 때문)</li>
  <li>PlacingBidUseCase는 Use Case로, Input Boundary를 구체화합니다.</li>
</ul>

<h4 id="output-boundary-output-dto">Output Boundary, Output DTO</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">PlacingBidOutputDto</span><span class="p">:</span>
    <span class="n">is_winning</span><span class="p">:</span> <span class="nb">bool</span>
	<span class="n">current_price</span><span class="p">:</span> <span class="n">Decimal</span>

<span class="k">class</span> <span class="nc">PlacingBidOutputBoundary</span><span class="p">(</span><span class="n">abc</span><span class="p">.</span><span class="n">ABC</span><span class="p">):</span>
    <span class="nd">@abc.abstractmethod</span>
    <span class="k">def</span> <span class="nf">present</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">output_dto</span><span class="p">:</span> <span class="n">PlacingBidOutputDto</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    	<span class="k">pass</span>
        
    <span class="nd">@abc.abstractmethod</span>
    <span class="k">def</span> <span class="nf">get_presented_data</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    	<span class="k">pass</span>
</code></pre></div></div>

<ul>
  <li>Output Boundary는 Presenter를 추상화합니다.</li>
</ul>

<h4 id="presenter">Presenter</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Presenter: 최종적으로 view에 보여줄 data를 reformat 시키는 역할
</span><span class="k">class</span> <span class="nc">PlacingBidWebPresenter</span><span class="p">(</span><span class="n">PlacingBidOutputBoundary</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">present</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">output_dto</span><span class="p">:</span> <span class="n">PlacingBidOutputDto</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">self</span><span class="p">.</span><span class="n">_formatted_data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="sh">'</span><span class="s">current_price</span><span class="sh">'</span><span class="p">:</span> <span class="sa">f</span><span class="sh">'</span><span class="s">$</span><span class="si">{</span><span class="n">output_dto</span><span class="p">.</span><span class="n">current_price</span><span class="p">.</span><span class="nf">quantize</span><span class="p">(</span><span class="sh">"</span><span class="s">.01</span><span class="sh">"</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">,</span>
            <span class="sh">'</span><span class="s">is_winning</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">Congratulations!</span><span class="sh">'</span> <span class="k">if</span> <span class="n">output_dto</span><span class="p">.</span><span class="n">is_winning</span> <span class="k">else</span> <span class="sh">'</span><span class="s">:(</span><span class="sh">'</span>
        <span class="p">}</span>
        
    <span class="k">def</span> <span class="nf">get_presented_data</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">_formatted_data</span>
</code></pre></div></div>

<ul>
  <li>Presenter는 View에 최종 결과를 보여주게 됩니다.</li>
</ul>

<h3 id="inject-모듈을-사용한-dependency-rule-생성">inject 모듈을 사용한 Dependency Rule 생성</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">inject</span>

<span class="k">def</span> <span class="nf">di_config</span><span class="p">(</span><span class="n">binder</span><span class="p">:</span> <span class="n">inject</span><span class="p">.</span><span class="n">Binder</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">binder</span><span class="p">.</span><span class="nf">bind</span><span class="p">(</span><span class="n">AuctionsDataAccess</span><span class="p">,</span> <span class="nc">DbAuctionsDataAccess</span><span class="p">())</span>
    <span class="n">binder</span><span class="p">.</span><span class="nf">bind_to_provider</span><span class="p">(</span><span class="n">PlacingBidOutputBoundary</span><span class="p">,</span> <span class="n">PlacingBidWebPresenter</span><span class="p">)</span>

<span class="n">inject</span><span class="p">.</span><span class="nf">configure</span><span class="p">(</span><span class="n">di_config</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">di_config</code>: 추상 클래스와 구현체를 연결하여 Dependency Rule을 생성합니다. 이를 통해, 추상 클래스를 사용할 때 특정 Implementation이 사용되도록 할 수 있습니다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">AuctionsDataAccess</span><span class="p">(</span><span class="n">abc</span><span class="p">.</span><span class="n">ABC</span><span class="p">):</span>
    <span class="nd">@abc.abstractmethod</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">auction_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">pass</span>
        
    <span class="nd">@abc.abstractmethod</span>
    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">auction</span><span class="p">:</span> <span class="n">Auction</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    	<span class="k">pass</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Data Access</code>: 데이터베이스의 인터페이스 역할을 수행합니다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Bid</span><span class="p">:</span>
    <span class="nb">id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
    <span class="n">bidder_id</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">amount</span><span class="p">:</span> <span class="n">Decimal</span>

<span class="c1"># Entities - Auction
</span><span class="k">class</span> <span class="nc">Auction</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">starting_price</span><span class="p">:</span> <span class="n">Decimal</span><span class="p">,</span> <span class="n">bids</span><span class="p">:</span> <span class="n">typing</span><span class="p">.</span><span class="n">List</span><span class="p">[</span><span class="n">Bid</span><span class="p">]):</span>
       <span class="n">self</span><span class="p">.</span><span class="nb">id</span> <span class="o">=</span> <span class="nb">id</span>
       <span class="n">self</span><span class="p">.</span><span class="n">starting_price</span> <span class="o">=</span> <span class="n">starting_price</span>
       <span class="n">self</span><span class="p">.</span><span class="n">bids</span> <span class="o">=</span> <span class="n">bids</span>
       
    <span class="k">def</span> <span class="nf">place_bid</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">user_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="n">Decimal</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
       <span class="k">pass</span>
       
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">current_price</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Decimal</span><span class="p">:</span>
       <span class="k">pass</span>
       
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">winners</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="p">.</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
       <span class="k">pass</span>
</code></pre></div></div>

<h2 id="clean-architecture-변형할-수-있는-형태-소개">Clean Architecture 변형할 수 있는 형태 소개</h2>

<h3 id="presenter에서-get-함수-사용">Presenter에서 get 함수 사용</h3>

<ul>
  <li>View의 return 값으로 Presenter의 템플릿을 반환하므로써, Presenter가 렌더링 역할을 담당하도록 합니다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="n">request</span><span class="p">:</span> <span class="n">HttpRequest</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HttpResponse</span><span class="p">:</span>
	<span class="k">return</span> <span class="nc">HttpResponse</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">Hello, world!</span><span class="sh">'</span><span class="p">)</span>
<span class="o">---</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="n">request</span><span class="p">:</span> <span class="n">HttpRequest</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">HttpResponse</span><span class="p">:</span>
	<span class="bp">...</span>
	<span class="k">return</span> <span class="n">presenter</span><span class="p">.</span><span class="nf">get_html_response</span><span class="p">()</span>
</code></pre></div></div>

<h3 id="cqrs-방식">CQRS 방식</h3>

<ul>
  <li>Output DTO와 Output Boundary 대신, CQRS 방식으로 처리하는 방법도 있습니다.</li>
</ul>

<h3 id="input-boundary-제거가능">Input Boundary 제거가능</h3>

<h2 id="user-case-대안">User Case 대안</h2>

<h3 id="facade-패턴">Facade 패턴</h3>

<ul>
  <li>User Case가 복잡하지 않은 형태라면 Facade 패턴을 사용하여 디자인할 수 있습니다.</li>
  <li>순차적인 메서드들을 single function 안에 넣어서 구현하는 방식입니다.</li>
  <li>get an Entity using Data Access Interface, call an Entity’s method, then save it back.</li>
</ul>

<h3 id="mediatorcommand-bus">Mediator(Command Bus)</h3>

<ul>
  <li>Output DTO를 사용하지 않는다면, Input DTO를 CQRS의 Commands로 대체하고, Command Bus라고 불리는 Mediator를 도입하는 것도 좋은 대안이 될 수 있습니다.</li>
  <li>이 때, Use Case는 Command Handler가 되며, Command는 DTO가 됩니다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">placing_bid_view</span><span class="p">(...)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
	<span class="n">command</span> <span class="o">=</span> <span class="nc">PlaceBid</span><span class="p">(..)</span>
	<span class="n">command_bus</span><span class="p">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="n">command</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>Handler로부터 완전히 decouple 시킬 수 있습니다. 따라서, Command classes와 Command Bus만 알고 있으면 됩니다.</li>
</ul>

<h2 id="dependency-injection">Dependency Injection</h2>

<ul>
  <li>추상화에 대응되는 어떤 Implementation을 mapping 합니다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CreditCardPaymentGateway</span><span class="p">(</span><span class="n">PaymentGateway</span><span class="p">):</span>
	<span class="k">pass</span>

<span class="c1"># tight coupling (implementation을 그대로 사용한 경우)
</span><span class="k">class</span> <span class="nc">Order</span><span class="p">:</span>
	<span class="k">def</span> <span class="nf">finalise</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
		<span class="n">payment_gateway</span> <span class="o">=</span> <span class="nc">CreditCardPaymentGateway</span><span class="p">(</span>
			<span class="n">settings</span><span class="p">.</span><span class="n">payment</span><span class="p">[</span><span class="sh">'</span><span class="s">url</span><span class="sh">'</span><span class="p">],</span> <span class="n">settings</span><span class="p">.</span><span class="n">payment</span><span class="p">[</span><span class="sh">'</span><span class="s">credentials</span><span class="sh">'</span><span class="p">]</span>
		<span class="p">)</span>
		<span class="n">payment_gateway</span><span class="p">.</span><span class="nf">pay</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">total</span><span class="p">)</span>

<span class="c1"># loose coupling (payment_gateway로 추상화한 class를 사용하는 경우)
</span><span class="k">class</span> <span class="nc">Order</span><span class="p">:</span>
	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">payment_gateway</span><span class="p">:</span> <span class="n">PaymentGateway</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
		<span class="n">self</span><span class="p">.</span><span class="n">_payment_gateway</span> <span class="o">=</span> <span class="n">PaymentGateway</span>
	<span class="k">def</span> <span class="nf">finalise</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
		<span class="n">self</span><span class="p">.</span><span class="n">_payment_gateway</span><span class="p">.</span><span class="nf">pay</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">total</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>Configuration을 통해 Dependency Injection을 관리하면, if문을 사용하지 않아도 됩니다.</li>
</ul>

<h2 id="cqrs">CQRS</h2>

<ul>
  <li>시스템의 상태를 변경하는 코드와 상태 변경없이 data를 read하는 코드를 분리합니다.</li>
  <li>CQRS는 writing을 위해 정규화된 데이터를 사용는 것과, 주기적인 간격으로 업데이트를 유지하는 데이터 메커니즘을 쿼링하기 위해 비정규화된 데이터를 사용하는 것을 허용합니다.</li>
  <li>Event Sourcing 방식과의 궁합이 좋습니다.</li>
</ul>

<h3 id="commands"><strong>Commands</strong></h3>

<ul>
  <li>시스템의 상태를 변화시킵니다.</li>
  <li>Business requirements 변화에 영향을 많이 받습니다.</li>
  <li>실행 순서가 중요합니다.</li>
</ul>

<h3 id="queries"><strong>Queries</strong></h3>

<ul>
  <li>시스템의 상태를 변경하지 않기 때문에, 간단하고 안전합니다.</li>
</ul>

<p><img src="Clean%20Architecture%20in%20Python%2002f338c7dcc741178f7b7df9c3804592/Untitled%204.png" alt="Untitled" /></p>

<h3 id="command"><strong>Command</strong></h3>

<ul>
  <li>Commands는 DTO역할을 하며 Command Handlers에 의해 실행됩니다.</li>
  <li>개발자는 application에서 service들을 사용하기 위해 Command Handler의 존재를 알 필요가 없습니다.</li>
  <li>
    <p>Use Case를 sending a Command로 대체해서 생각합니다.</p>

    <p>Command(DTO) - Command Bus - Command Handler</p>
  </li>
</ul>

<h3 id="query"><strong>Query</strong></h3>

<h4 id="query를-dto로-다루는-방법">Query를 DTO로 다루는 방법</h4>

<ul>
  <li>Command를 다루는 방식과 동일하게 동작합니다. 각각의 쿼리를 single class (DTO) 형태로 나타냅니다.</li>
  <li>개발자는 Query Handler의 존재를 알 필요가 없습니다.</li>
  <li>
    <p>Query class는 Application Layer에 속하고, Query Handler는 Infrastructure layer에 속합니다.</p>

    <p>Query(DTO) - Query Bus - Query Handler</p>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">GetListOfDeliveryAddresses</span><span class="p">(</span><span class="n">Query</span><span class="p">):</span>
	<span class="n">Dto</span> <span class="o">=</span> <span class="n">List</span><span class="p">[</span><span class="n">DeliveryAddress</span><span class="p">]</span>
	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">user_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
		<span class="n">self</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">user_id</span>
	<span class="k">def</span> <span class="nf">query_handler</span><span class="p">(</span><span class="n">query</span><span class="p">:</span> <span class="n">GetListOfDeliveryAddreses</span><span class="p">)</span>
			<span class="o">-&gt;</span> <span class="n">GetListOfDeliveryAddresses</span><span class="p">.</span><span class="n">Dto</span><span class="p">:</span>
		<span class="bp">...</span>

<span class="c1"># using via QueryBus
</span><span class="n">query</span> <span class="o">=</span> <span class="nc">GetListOfDeliveryAddresses</span><span class="p">(</span><span class="n">user_id</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">query_bus</span><span class="p">.</span><span class="nf">dispatch</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="queries를-분리된-클래스들로-다루는-방법">Queries를 분리된 클래스들로 다루는 방법</h4>

<ul>
  <li>Query Bus, Query Handler를 사용하지 않고, 각각의 Query는 Abstract class로 Application Layer에 있도록 합니다.</li>
  <li>concrete implementation은 Infrastructure Layer에 위치하도록 합니다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># somewhere in Application Layer
</span><span class="k">class</span> <span class="nc">GettingListOfDeliveryAddresses</span><span class="p">(</span><span class="n">Query</span><span class="p">):</span>
	<span class="n">Dto</span> <span class="o">=</span> <span class="n">List</span><span class="p">[</span><span class="n">DeliveryAddress</span><span class="p">]</span>
	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">user_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
		<span class="n">self</span><span class="p">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">user_id</span>
	<span class="nd">@abc.abstractmethod</span>
	<span class="k">def</span> <span class="nf">excute</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dto</span><span class="p">:</span>
		<span class="k">pass</span>

<span class="c1"># in Infrastructure layer
</span><span class="k">class</span> <span class="nc">SqlGettingListOfDeliveryAddresses</span><span class="p">(</span><span class="n">GettingListOfDeliveryAddresses</span><span class="p">):</span>
	<span class="k">def</span> <span class="nf">excute</span><span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">GettingListOfDeliveryAddresses</span><span class="p">.</span><span class="n">Dto</span><span class="p">:</span>
		<span class="n">models</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">session</span><span class="p">.</span><span class="nf">query</span><span class="p">(</span><span class="n">Address</span><span class="p">).</span><span class="nf">filter</span><span class="p">(</span>
			<span class="p">(</span><span class="n">Address</span><span class="p">.</span><span class="nb">type</span> <span class="o">==</span> <span class="n">Address</span><span class="p">.</span><span class="n">DELIVERY</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">Address</span><span class="p">.</span><span class="n">user_id</span> <span class="o">==</span> <span class="n">self</span><span class="p">.</span><span class="n">user_id</span><span class="p">)</span>
		<span class="p">)</span>
		<span class="k">return</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="nf">_to_dto</span><span class="p">(</span><span class="n">model</span><span class="p">)</span> <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">models</span><span class="p">]</span>

<span class="c1"># 설정파일에서 Sql 관련 설정으로 바인드 해줍니다.
</span><span class="nd">@inject</span><span class="p">(</span><span class="n">config</span><span class="o">=</span><span class="n">Config</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">configure</span><span class="p">(</span><span class="n">binder</span><span class="p">,</span> <span class="n">config</span><span class="p">):</span>
	<span class="n">binder</span><span class="p">.</span><span class="nf">bind</span><span class="p">(</span>
		<span class="n">GettingListOfDeliveryAddresses</span><span class="p">,</span>
		<span class="n">to</span><span class="o">=</span><span class="n">SqlGettingListOfDeliveryAddresses</span><span class="p">,</span>
	<span class="p">)</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="sh">"</span><span class="s">/auction/bids</span><span class="sh">"</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="sh">"</span><span class="s">POST</span><span class="sh">"</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">auction_bids</span><span class="p">(</span><span class="n">query</span><span class="p">:</span> <span class="n">GettingListOfDeliveryAddresses</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Response</span><span class="p">:</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">query</span><span class="p">.</span><span class="nf">excute</span><span class="p">()</span>
	<span class="bp">...</span>

</code></pre></div></div>]]></content><author><name>Yeham Kim</name></author><category term="Study" /><summary type="html"><![CDATA[https://github.com/Enforcer/clean-architecture]]></summary></entry><entry><title type="html">[Algorithm] 부분합을 계산하기 위한 알고리즘</title><link href="http://localhost:4000/algorithm/study-algorithm-partial-sum/" rel="alternate" type="text/html" title="[Algorithm] 부분합을 계산하기 위한 알고리즘" /><published>2023-11-02T00:05:07+09:00</published><updated>2023-11-02T00:05:07+09:00</updated><id>http://localhost:4000/algorithm/study-algorithm-partial-sum</id><content type="html" xml:base="http://localhost:4000/algorithm/study-algorithm-partial-sum/"><![CDATA[<h2 id="부분합">부분합</h2>
<ul>
  <li>입력받은 정수 배열에서 연속된 부분배열의 합이 가장 큰 경우를 구하는 문제입니다.</li>
  <li>입력 값으로 배열의 크기와 요소들이 주어집니다.</li>
</ul>

<h3 id="무식하게-풀기-on--n">무식하게 풀기 O(N * N)</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SolverBruteForce</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="n">psum</span> <span class="o">=</span> <span class="n">INT_MIN</span>
        <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">cand_sum</span> <span class="o">=</span> <span class="nf">sum</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">psum</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">psum</span><span class="p">,</span> <span class="n">cand_sum</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">psum</span>

</code></pre></div></div>
<ul>
  <li>배열을 순회하며 순회하고 있는 요소부터 하나씩 증가시키며 끝까지 더해서 값을 비교합니다.</li>
  <li>순회할 때 O(N)만큼, 순회하고 있는 요소부터 마지막까지 순회해야하기 때문에 O(N)만큼 시간이 함께 소모됩니다.</li>
  <li>따라서, O(N * N)만큼의 시간 복잡도를 가지게 됩니다.</li>
</ul>

<h3 id="분할해서-풀기-onlogn">분할해서 풀기 O(NLogN)</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SolverOptimizer</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">k</span>
        <span class="n">psum</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">process</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">psum</span>

    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">arr</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>

        <span class="n">mid</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

        <span class="n">cand_sum</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">left_sum</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">INT_MIN</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">mid</span><span class="p">,</span> <span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">cand_sum</span> <span class="o">+=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">left_sum</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">left_sum</span><span class="p">,</span> <span class="n">cand_sum</span><span class="p">)</span>
        
        <span class="n">cand_sum</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">right_sum</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">INT_MIN</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">cand_sum</span> <span class="o">+=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">right_sum</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">right_sum</span><span class="p">,</span> <span class="n">cand_sum</span><span class="p">)</span>

        <span class="n">part</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="nf">process</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">mid</span><span class="p">),</span> <span class="n">self</span><span class="p">.</span><span class="nf">process</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
        <span class="k">return</span> <span class="nf">max</span><span class="p">(</span><span class="n">left_sum</span> <span class="o">+</span> <span class="n">right_sum</span><span class="p">,</span> <span class="n">part</span><span class="p">)</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">mid</code> 인덱스를 기준으로 왼쪽 값과 오른쪽 값 각각의 부분합의 최댓값을 계산하고, 병합할 때의 최댓값을 계산하여 모든 경우에서 최댓값을 반환하며 병합해나갑니다.</li>
  <li>분할해나가는데 O(LogN)의 시간이 소모되며, 병합해나가는데 O(N)의 시간이 소모되므로 총 O(NLogN)의 시간 복잡도를 가지게 됩니다.</li>
</ul>

<h3 id="입력을-위한-파트">입력을 위한 파트</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="bp">...</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="n">n</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">input</span><span class="p">())</span>
    <span class="n">arr</span><span class="p">:</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">el</span> <span class="o">=</span> <span class="nf">int</span><span class="p">(</span><span class="nf">input</span><span class="p">())</span>
        <span class="n">arr</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
</code></pre></div></div>]]></content><author><name>Yeham Kim</name></author><category term="Algorithm" /><summary type="html"><![CDATA[부분합 입력받은 정수 배열에서 연속된 부분배열의 합이 가장 큰 경우를 구하는 문제입니다. 입력 값으로 배열의 크기와 요소들이 주어집니다.]]></summary></entry><entry><title type="html">[Study] Database - 동시성 관련 문제</title><link href="http://localhost:4000/study/study-db-concurrency/" rel="alternate" type="text/html" title="[Study] Database - 동시성 관련 문제" /><published>2023-10-30T00:05:07+09:00</published><updated>2023-10-30T00:05:07+09:00</updated><id>http://localhost:4000/study/study-db-concurrency</id><content type="html" xml:base="http://localhost:4000/study/study-db-concurrency/"><![CDATA[<h2 id="트랜잭션-isolation-level">트랜잭션 Isolation Level</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Dirty Read</code>, <code class="language-plaintext highlighter-rouge">Non-repeatable Read</code>, <code class="language-plaintext highlighter-rouge">Phantom Read</code>를 발생하지 않게 만든다면, 제약사항이 많아집니다.</li>
  <li>제약사항이 많아지면 동시처리(concurrency) 가능한 트랜잭션의 수가 줄어들게 되어, 결국 DB의 전체 처리량(throughput)이 하락하게 되는 단점이 있습니다.</li>
  <li>개발자는 격리수준을 설정하여 쓰루풋과 데이터 일관성 사이의 트레이드 오프를 관리할 수 있습니다.</li>
  <li>
    <p>SQL 표준에서 정의하는 격리수준(Isolation Level)의 허용범위는 아래와 같습니다.</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: left">Isolation Level</th>
          <th style="text-align: center">Dirty read</th>
          <th style="text-align: center">Non-repeatable read</th>
          <th style="text-align: center">Phantom read</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: left">Read uncommitted</td>
          <td style="text-align: center">O</td>
          <td style="text-align: center">O</td>
          <td style="text-align: center">O</td>
        </tr>
        <tr>
          <td style="text-align: left">Read committed</td>
          <td style="text-align: center">X</td>
          <td style="text-align: center">O</td>
          <td style="text-align: center">O</td>
        </tr>
        <tr>
          <td style="text-align: left">Repeatable read</td>
          <td style="text-align: center">X</td>
          <td style="text-align: center">X</td>
          <td style="text-align: center">O</td>
        </tr>
        <tr>
          <td style="text-align: left">Serializable</td>
          <td style="text-align: center">X</td>
          <td style="text-align: center">X</td>
          <td style="text-align: center">X</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h4 id="dirty-read">Dirty Read</h4>
<ul>
  <li>다른 트랜잭션에서 아직 커밋되지 않은 값을 읽는 경우입니다.</li>
  <li>
    <p>예시는 다음과 같습니다.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  # given
  - 2번 트랜잭션은 y = y + 20을 수행하고 1번 트랜잭션은 x = x + y를 수행합니다.
  # when
  - 2번 트랜잭션에서 값을 수정하고, 1번 트랜잭션이 그 값을 이용해 값을 수정하고 커밋합니다.
  - 그후, 2번 트랜잭션에서 오류가 발생하여 롤백하게 됩니다.
  # then
  - 1번 트랜잭션은 결과적으로 비정상적인 수정이 되어버린 경우입니다.
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="non-repeatable-read-fuzzy-read">Non-repeatable Read (Fuzzy Read)</h4>
<ul>
  <li>하나의 트랜잭션이 같은 데이터의 값이 조회할 때마다 값이 달라지는 경우입니다.</li>
  <li>
    <p>예시는 다음과 같습니다.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  # given
  - 1번 트랜잭션은 x를 두번 읽습니다. 2번 트랜잭션은 x에 40을 더합니다.
  # when
  - 1번 트랜잭션에서 x를 한 번 읽습니다.
  - 2번 트랜잭션이 x에 40을 더하고 커밋하여 값을 수정합니다.
  # then
  - 1번 트랜잭션에서 다시 x를 읽으면 첫번째 읽은 값과 다른 값이 조회됩니다.
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="phantom-read">Phantom Read</h4>
<ul>
  <li>없던 데이터가 생기게 되는 현상입니다.</li>
  <li>
    <p>예시는 다음과 같습니다.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  # given
  - 1번 트랜잭션은 WHERE v=10인 데이터를 두 번 읽습니다.
  - 2번 트랜잭션은 WHERE v=30인 데이터를 v=10으로 수정합니다.
  # when
  - 1번 트랜잭션에서 조건문을 사용하여 데이터를 읽으면 조회되는 튜플은 하나입니다.
  - 2번 트랜잭션에서 v=30을 v=10으로 수정하고 커밋하면 1번에서 불러올 수 있는 조건이 됩니다.
  # then
  - 1번에서 같은 조건으로 다시 조회하게 되면 v=10에 대한 튜플이 2개가 됩니다.
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="실무에서는-어떻게-사용하는가">실무에서는 어떻게 사용하는가?</h3>
<ul>
  <li>MySQL: 표준에서 정의하는 위의 네개의 격리 수준을 모두 사용합니다.</li>
  <li>SQL server: 표준에서 정의하는 네개의 격리 수준을 모두 사용합니다.</li>
  <li>Oracle: <code class="language-plaintext highlighter-rouge">READ UNCOMMITTED</code>는 사용하지 않습니다. <code class="language-plaintext highlighter-rouge">REPEATABLE READ</code> 대신 <code class="language-plaintext highlighter-rouge">SERIALIZABLE</code>로 설정해야합니다.<br />
결과적으로, <code class="language-plaintext highlighter-rouge">READ COMMITTED</code>와 <code class="language-plaintext highlighter-rouge">SERIALIZABLE</code> 두 개의 격리 수준만 사용합니다.</li>
  <li>Postgre SQL: 표준에서 정의하는 네개의 격리 수준 + <code class="language-plaintext highlighter-rouge">Serialization Anomaly</code> 관련 설정을 사용합니다.<br />
Repeatable read는 snapshot isolation level에 해당합니다.</li>
</ul>

<h2 id="동시성concurrency이란">동시성(Concurrency)이란?</h2>
<ul>
  <li>하나의 CPU 코어에서 시간분할을 통하여 여러 일을 처리하는 것처럼 보여지게 하는 기법을 의미합니다.</li>
  <li>DB에서는 자원에 접근하기 위해 동시성을 허용하여 트랜잭션이 순서에 상관없이 동시에 실행되는 것을 허용합니다.</li>
  <li>이를 제대로 파악하지 못하고 설정하면, 데이터를 수정하여 저장했지만 조회했을 때 다른 값이 반환되는 등의 무결성이 깨지는 문제가 발생하게 됩니다.</li>
</ul>

<h3 id="read-uncommitted">Read uncommitted</h3>
<ul>
  <li>하나의 트랜잭션의 변경 이후 커밋, 롤백과 상관없이 다른 트랜잭션에 영향을 미칩니다.</li>
  <li>1번 트랜잭션이 업데이트를 하고 commit을 하지 않은 상태에서 2번 트랜잭션이 업데이트하고 조회하는 경우입니다.</li>
  <li>이 경우, <code class="language-plaintext highlighter-rouge">Dirty Read</code> 문제가 발생할 수 있습니다.</li>
  <li>만약 다른 트랜잭션이 롤백된다면 다시 읽었을 떄 값이 달라집니다.</li>
  <li>대부분 RDBMS에서는 사용하지 않는 격리 수준입니다.</li>
</ul>

<h3 id="read-committed">Read committed</h3>
<ul>
  <li>하나의 트랜잭션의 변경이 커밋된 후에만 다른 트랜잭션에 변경사항이 반영됩니다.</li>
  <li>1번 트랜잭션이 값을 <code class="language-plaintext highlighter-rouge">Update</code> 후 1번 트랜잭션의 “커밋 이전”에 2번 트랜잭션이 조회한다면 변경 전 값을 읽습니다.</li>
  <li>하지만, 1번 트랜잭션이 삽입, 수정 후 “커밋 이후”에 2번 트랜잭션이 값을 조회한다면 변경 후 값을 조회합니다.</li>
  <li>이 경우, <code class="language-plaintext highlighter-rouge">Non-Repeatable Read</code> 문제가 발생할 수 있습니다.</li>
  <li>Oracle을 포함한 많은 DBMS가 선택하는 격리 수준입니다.</li>
</ul>

<h3 id="repeatable-read">Repeatable Read</h3>
<ul>
  <li>트랜잭션이 시작되고 종료되기 전까지 한 번 조회한 값은 계속해서 같은 값으로 조회됩니다.</li>
  <li>이 때, <code class="language-plaintext highlighter-rouge">Update</code>에 대해서는 데이터의 정합성이 보장되지만, <code class="language-plaintext highlighter-rouge">Insert</code>에 대해서는 보장되지 않습니다.</li>
  <li>이 경우, <code class="language-plaintext highlighter-rouge">Phantom Read</code> 문제가 발생합니다.</li>
</ul>

<h3 id="serializable">Serializable</h3>
<ul>
  <li>가장 엄격한 격리 수준입니다.</li>
  <li>한 트랜잭션이 테이블을 읽으면 다른 트랜잭션은 그 테이블에 대해 추가, 변경, 삭제가 제한됩니다.</li>
  <li>정합성 문제는 발생하지 않겠지만, 동시 처리 성능이 떨어집니다.</li>
</ul>

<h2 id="비관적인-방법">비관적인 방법</h2>
<ul>
  <li>현재 수정하려는 데이터가 언제든 다른 요청에 의해 수정될 가능성을 고려하여 데이터에 Lock을 거는 방식입니다.</li>
  <li>장점: 데이터의 무결성을 완벽히 지킬 수 있습니다.<br />
(수정할 데이터에 row level lock을 걸어, 다른 요청에서 수정할 수 없습니다.)</li>
  <li>단점: lock으로 인하여 다른 요청들은 대기상태가 됩니다.<br />
(기존 Lock의 트랜잭션이 커밋 또는 롤백으로 끝나면 대기하던 요청을 실행합니다.)</li>
</ul>

<h3 id="방법-1-트랜잭션-격리수준-수정">방법 1: 트랜잭션 격리수준 수정</h3>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SHOW</span> <span class="n">TRANSACTION</span> <span class="k">ISOLATION</span> <span class="k">LEVEL</span><span class="p">;</span>
<span class="o">#</span> <span class="k">read</span> <span class="k">committed</span>
</code></pre></div></div>

<ul>
  <li>기본으로 설정되어있던 격리수준을 높여서 동시성을 해결할 수 있습니다.</li>
  <li>
    <p>하지만, 모든 트랜잭션의 격리수준이 올라가게 되며 성능은 하락합니다.</p>
  </li>
  <li>postgres의 경우, 기본 격리수준은 <code class="language-plaintext highlighter-rouge">read committed</code>이지만, <code class="language-plaintext highlighter-rouge">repeatable read</code>나 seralizable`로 향상시킵니다.</li>
</ul>

<h3 id="방법-2-select-for-update">방법 2: select for update</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="n">transaction</span> <span class="mi">1</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">aircraft</span> <span class="k">where</span> <span class="n">id</span><span class="o">=</span> <span class="mi">20231030</span> <span class="k">for</span> <span class="k">update</span>

<span class="o">#</span> <span class="n">transaction</span> <span class="mi">2</span>
<span class="o">#</span> <span class="err">이건</span> <span class="err">가능</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">aircraft</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">20231030</span>

<span class="o">#</span> <span class="n">transaction</span> <span class="mi">2</span>
<span class="o">#</span> <span class="err">이건</span> <span class="err">불가능</span>
<span class="k">update</span> <span class="n">aircraft</span> <span class="k">set</span> <span class="n">remaining_seat</span> <span class="o">=</span> <span class="n">remaining_seat</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">20231030</span>
</code></pre></div></div>

<ul>
  <li>row lock을 제어하는 방식입니다.</li>
  <li>
    <p>DBMS 전체나 테이블에 lock을 거는 것보다, 좁은 범위에 lock을 사용하여 성능 하향을 최소화합니다.</p>
  </li>
  <li>특정 row에 lock을 걸어, 조회는 가능하게 하되, 업데이트는 불가능하도록 막습니다.</li>
</ul>

<h3 id="방법-3-redis">방법 3: redis</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># django-redis 사용
</span>
<span class="kn">from</span> <span class="n">django.core.cache</span> <span class="kn">import</span> <span class="n">cache</span>
<span class="n">aircraft_reserve_key</span> <span class="o">=</span> <span class="sa">f</span><span class="sh">'</span><span class="s">aircraft_reserve_key:</span><span class="si">{</span><span class="n">user_id</span><span class="si">}</span><span class="s">:</span><span class="si">{</span><span class="n">aircraft_id</span><span class="si">}</span><span class="sh">'</span>
<span class="k">if</span> <span class="n">cache</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="sh">'</span><span class="s">aircraft_reserve_key</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">1</span><span class="sh">'</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="n">aircraft</span> <span class="o">=</span> <span class="n">Aircraft</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">aircraft_id</span><span class="p">)</span>
    <span class="n">aircraft</span><span class="p">.</span><span class="n">remaining_seat</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="n">aircraft</span><span class="p">.</span><span class="nf">save</span><span class="p">()</span>
</code></pre></div></div>
<ul>
  <li>redis를 사용하여 application 레벨에서 락을 잡는 방법입니다.</li>
  <li>redis는 setnx(set not exist)를 사용하며, “락이 존재하지 않는다면” “락을 획득한다”는 두 연산을 atomic하게 락을 획득하도록 해줍니다.</li>
</ul>

<h3 id="참고-django에서-지원하는-select-for-update">참고: Django에서 지원하는 select for update</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">with</span> <span class="n">transaction</span><span class="p">.</span><span class="nf">atomic</span><span class="p">():</span>
    <span class="n">aircraft</span> <span class="o">=</span> <span class="n">Aircraft</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="nb">id</span><span class="p">).</span><span class="nf">select_for_update</span><span class="p">()</span>
    <span class="n">aircraft</span><span class="p">.</span><span class="n">remaining_seat</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="n">aircraft</span><span class="p">.</span><span class="nf">save</span><span class="p">()</span>
</code></pre></div></div>
<ul>
  <li>항공기를 예약하는 예시로, 예약 시트의 변경이 있는 동안 특정 id의 레코드에 대해 락을 걸어둡니다.</li>
</ul>

<h4 id="of">of</h4>
<ul>
  <li>기본적으로 장고 ORM은 모든 쿼리에 락을 걸어버립니다. 따라서, 특정 모델 클래스를 대상으로 락을 설정할지 지정할 수 있습니다.</li>
  <li><code class="language-plaintext highlighter-rouge">select_related</code>와 함께 사용하는 경우 join 테이블의 행도 함께 락을 걸기 때문에 명확히 명시할 수 있습니다.</li>
</ul>

<h4 id="skip_locked">skip_locked</h4>
<ul>
  <li>True로 설정하면 락이 걸린 레코드를 무시하고 락이 걸리지 않은 레코드를 찾습니다.</li>
</ul>

<h4 id="nowait">nowait</h4>
<ul>
  <li>기본 값은 False이며, row 락이 걸려있다면 트랜잭션이 끝날때까지 대기했다가 끝나면 작업을 진행합니다.</li>
  <li>True일 때 락이 걸린 트랜잭션이 끝날 때까지 기다리지 않고 바로 <code class="language-plaintext highlighter-rouge">DatabaseError</code>를 발생시킵니다.</li>
</ul>

<h4 id="주의사항">주의사항</h4>
<ol>
  <li><code class="language-plaintext highlighter-rouge">transaction.atomic()</code> 블럭 내에서 <code class="language-plaintext highlighter-rouge">select_for_update()</code>를 사용해아합니다. 
(블럭 내에 있는 동안 블럭 내에서 조회한 쿼리에 락이 걸립니다. 다른 트랜잭션은 이를 획득/수정할 수 없습니다.)</li>
  <li><code class="language-plaintext highlighter-rouge">skip_locked</code> 옵션과 <code class="language-plaintext highlighter-rouge">nowait</code> 옵션은 상호배타적인 관계로, 두 옵션을 모두 사용하게 되면 <code class="language-plaintext highlighter-rouge">ValueError</code>가 발생합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">select_for_update()</code>는 null을 참조하는 경우에는 사용할 수 없습니다.<br />
<code class="language-plaintext highlighter-rouge">Person.objects.select_related('hometown').select_for_update().exclude(hometown=None)</code></li>
  <li>eager loading을 사용하여 참조해야합니다.</li>
</ol>

<h2 id="낙관적인-방법">낙관적인 방법</h2>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">reserve</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
    <span class="n">updated</span> <span class="o">=</span> <span class="n">Aircraft</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span>
        <span class="nb">id</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="nb">id</span><span class="p">,</span>
        <span class="n">version</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="n">version</span><span class="p">,</span>
    <span class="p">).</span><span class="nf">update</span><span class="p">(</span>
        <span class="n">remaining_seat</span><span class="o">=</span><span class="n">remaining_seat</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">version</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="n">version</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">updated</span> <span class="o">&gt;</span> <span class="mi">0</span>
</code></pre></div></div>
<ul>
  <li>version 컬럼이나 updated_at 컬럼을 함께 조회 조건으로 사용하는 방식입니다.</li>
  <li>데이터를 수정할 때마다 version을 1 증가시키거나, updated_at을 현재시간으로 갱신합니다.</li>
  <li>동시에 <code class="language-plaintext highlighter-rouge">reverse</code> 메서드가 호출되어 동일한 버전으로 수정하려고 시도한다면 하나의 transaction은 버전 충돌이나서 실패하게 됩니다.</li>
</ul>]]></content><author><name>Yeham Kim</name></author><category term="Study" /><summary type="html"><![CDATA[트랜잭션 Isolation Level Dirty Read, Non-repeatable Read, Phantom Read를 발생하지 않게 만든다면, 제약사항이 많아집니다. 제약사항이 많아지면 동시처리(concurrency) 가능한 트랜잭션의 수가 줄어들게 되어, 결국 DB의 전체 처리량(throughput)이 하락하게 되는 단점이 있습니다. 개발자는 격리수준을 설정하여 쓰루풋과 데이터 일관성 사이의 트레이드 오프를 관리할 수 있습니다. SQL 표준에서 정의하는 격리수준(Isolation Level)의 허용범위는 아래와 같습니다.]]></summary></entry><entry><title type="html">[Study] 파이썬 의존성 관리 툴 Poetry 사용 방법</title><link href="http://localhost:4000/study/study-python-poetry/" rel="alternate" type="text/html" title="[Study] 파이썬 의존성 관리 툴 Poetry 사용 방법" /><published>2023-10-24T00:05:07+09:00</published><updated>2023-10-24T00:05:07+09:00</updated><id>http://localhost:4000/study/study-python-poetry</id><content type="html" xml:base="http://localhost:4000/study/study-python-poetry/"><![CDATA[<h2 id="poetry란">Poetry란?</h2>
<ul>
  <li>파이썬의 의존성을 관리해주는 툴입니다.</li>
  <li>pip으로만 사용하면, Dependency를 관리하기가 까다로워 버전 충돌이 발생할 수 있습니다.</li>
  <li>툴 내에서 Virtualenv를 생성하여 경리된 환경에서 개발이 가능하도록 합니다.</li>
  <li>기존 파이썬 패키지 관리 툴에서 지원하지 않는 Build, Publish가 가능합니다.</li>
  <li>pyproject.toml을 기준으로 여러 툴들의 config 관리를 명시적으로 할 수 있습니다.</li>
</ul>

<h2 id="참고">참고</h2>
<p>https://velog.io/@whattsup_kim/Python-%ED%8C%8C%EC%9D%B4%EC%8D%AC-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%B6%95%ED%95%98%EA%B8%B0-2-Poetry</p>]]></content><author><name>Yeham Kim</name></author><category term="Study" /><summary type="html"><![CDATA[Poetry란? 파이썬의 의존성을 관리해주는 툴입니다. pip으로만 사용하면, Dependency를 관리하기가 까다로워 버전 충돌이 발생할 수 있습니다. 툴 내에서 Virtualenv를 생성하여 경리된 환경에서 개발이 가능하도록 합니다. 기존 파이썬 패키지 관리 툴에서 지원하지 않는 Build, Publish가 가능합니다. pyproject.toml을 기준으로 여러 툴들의 config 관리를 명시적으로 할 수 있습니다.]]></summary></entry><entry><title type="html">[Study] 파이썬에서는 어떻게 가비지 컬렉팅을 수행할까?</title><link href="http://localhost:4000/study/study-python-garbage-collector/" rel="alternate" type="text/html" title="[Study] 파이썬에서는 어떻게 가비지 컬렉팅을 수행할까?" /><published>2023-10-21T00:05:07+09:00</published><updated>2023-10-21T00:05:07+09:00</updated><id>http://localhost:4000/study/study-python-garbage-collector</id><content type="html" xml:base="http://localhost:4000/study/study-python-garbage-collector/"><![CDATA[<h1 id="가비지-컬렉터">가비지 컬렉터</h1>

<h3 id="메모리를-관리하는-방법">메모리를 관리하는 방법</h3>
<ul>
  <li>더 이상 사용하지 않는 메모리를 해제하지 않으면 memory leak이 발생합니다.</li>
  <li>사용 중이던 메모리를 해제하면 프로그램이 중단되고 데이터가 손실될 수 있습니다.</li>
</ul>

<h3 id="gc의-동작-원리">GC의 동작 원리</h3>
<ul>
  <li>OS가 프로그램을 프로세스로 실행하게 되면, 프로세스는 메모리에 Code, Data, Heap, Stack 영역을 할당받게 됩니다.</li>
  <li>이 때, 힙과 스택 영역에 할당된 메모리들을 해제하는 동작을 수행하는 것이 GC 입니다.</li>
</ul>

<h2 id="파이썬의-gc">파이썬의 GC</h2>
<ul>
  <li>파이썬의 GC는 레퍼런스 카운팅, 제너레이셔널 가비지 컬렉션 두가지 방식으로 동작합니다.</li>
</ul>

<h3 id="reference-counting">Reference Counting</h3>
<ul>
  <li>어떤 객체가 참조되어 사용될 때마다 횟수를 카운팅하여 증가시키고, 해제할 때 1씩 감소시킵니다. 0이 되면 객체의 메모리 할당이 해제됩니다.</li>
  <li>메모리 교체 방식에서 LRU(Least Recently Used)가 참조 횟수를 카운트하여 victim을 고릅니다.</li>
  <li>레퍼런스 카운트를 증가시키는 방법은 1. 객체를 변수에 할당, 2. 객체를 리스트와 튜플과 같은 자료구조에 추가하거나, 인스턴스 프로퍼티로 추가하는 경우, 3. 함수에 파라미터로 전달하는 경우입니다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">sys</span>
<span class="n">a</span> <span class="o">=</span> <span class="sh">"</span><span class="s">Hello world!</span><span class="sh">"</span>
<span class="n">sys</span><span class="p">.</span><span class="nf">getrefcount</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="c1"># a의 레퍼런스 카운트: 2
</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">c</span> <span class="o">=</span> <span class="p">{</span> <span class="sh">'</span><span class="s">key</span><span class="sh">'</span><span class="p">:</span> <span class="n">a</span> <span class="p">}</span>
<span class="n">sys</span><span class="p">.</span><span class="nf">getrefcount</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="c1"># a의 레퍼런스 카운트: 4
</span></code></pre></div></div>
<ul>
  <li>a가 위치한 스택의 주소가 콜스택에서 참조되기 때문에 1번, <code class="language-plaintext highlighter-rouge">getrefcount()</code>에 매개변수로 전달될 때 한번 카운트가 증가됩니다.</li>
</ul>

<h3 id="generational-garbage-collection">Generational Garbage Collection</h3>
<ul>
  <li>어떤 동적 객체가 서로를 순환참조하고 있다면, Reference counting 방식에서는 해당 객체들이 메모리에서 해제될 수 없습니다.</li>
  <li>이를 방지하기 위해, 제너레이셔널 가비지 컬렉션은 순환 참조를 탐지하고 메모리에서 해제합니다.</li>
  <li>레퍼런스 카운팅과 다르게 가비지 컬렉팅은 개발자가 임계값을 직접 설정하여 동작시킬 수 있습니다.</li>
</ul>

<h4 id="핵심-개념">핵심 개념</h4>
<ul>
  <li>Generation: 가비지 컬렉터 객체를 0~2세대로 분리하여 관리하고, 세대가 낮을수록 더욱 자주 가비지 컬렉팅을 수행합니다. 생성된지 오래되지 않은 객체가 오래된 객체보다 해제될 가능성이 높다는 가설에 근거합니다.</li>
  <li>
    <p>Threshold: 세대별 객체의 수가 정해진 스레스홀드를 초과하면, 임계치가 초과된 세대의 객체에 대해 수행합니다.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kn">import</span> <span class="n">gc</span>
  <span class="n">gc</span><span class="p">.</span><span class="nf">get_threshold</span><span class="p">()</span> <span class="c1"># 1. stdout: (700, 10, 10)
</span>  <span class="n">gc</span><span class="p">.</span><span class="nf">get_count</span><span class="p">()</span>     <span class="c1"># 2. stdout: (121, 9, 2)
</span></code></pre></div>    </div>

    <ul>
      <li>1번 결과에서 threshold 0이 700이라는 의미는, 0세대 객체가 700개를 초과하면 가비지 컬렉팅이 수행된다는 뜻입니다. 남은 객체들은 1세대 객체로 옮기고 1세대의 count를 1 증가시킵니다.</li>
      <li>threshold 1, 2가 10이라는 의미는, 객체 수의 임계값이 아닌 가비지 컬렉팅이 발생한 횟수에 대한 임계치입니다. 따라서, 1세대는 7000번 만에, 2세대는 70000번 만에 가비지 컬렉션이 수행됩니다.</li>
    </ul>
  </li>
</ul>

<h4 id="가비지-컬렉션의-라이프-사이클">가비지 컬렉션의 라이프 사이클</h4>
<ul>
  <li>새로운 객체가 만들어질 때 파이썬은 객체를 메모리와 0 세대에 할당합니다. 만약, 0 세대의 객체 수가 threshold 0보다 크다면, <code class="language-plaintext highlighter-rouge">collect_generations()</code>를 실행하게 됩니다.</li>
  <li><code class="language-plaintext highlighter-rouge">collection_generations()</code> 메서드가 호출되면 모든 세대(기본적으로 3개의 세대)를 검사하는데, 가장 오래된 세대인 2세대부터 역으로 확인합니다.</li>
  <li>해당 세대에 객체가 할당된 횟수가 각 세대에 대응되는 threadhold n보다 크면 <code class="language-plaintext highlighter-rouge">collect()</code>를 호출해 가비지 컬렉션을 수행합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">collect()</code> 메서드는 순환 참조 탐지 알고리즘을 수행하고 특정 세대에서 도달할 수 있는 객체와 도달할 수 없는 객체를 구분하여 도달할 수 없는 객체들을 찾습니다.</li>
  <li>도달할 수 있는 객체 집합은 다음 상위 세대로 합쳐지고, 도달할 수 없는 객체 집합은 콜백을 수행한 후 메모리에서 해제됩니다.</li>
</ul>

<h4 id="순환참조-되는-경우">순환참조 되는 경우</h4>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
		<span class="k">pass</span>
<span class="n">a</span> <span class="o">=</span> <span class="nc">MyClass</span><span class="p">()</span>
<span class="n">a</span><span class="p">.</span><span class="n">obj</span> <span class="o">=</span> <span class="n">a</span>
<span class="k">del</span> <span class="n">a</span>
</code></pre></div></div>
<ul>
  <li>위와 같은 경우,  클래스의 인스턴스를 생성한 다음 프로퍼티로 자신을 할당했습니다.</li>
  <li>이 때, 객체를 삭제하더라도 객체의 프로퍼티가 자신이기 때문에 순환참조가 발생하여 객체가 즉시 메모리에서 할당 해제되지 않습니다.</li>
  <li>따라서, 실제 객체를 삭제하더라도 각 객체 내부에서 서로를 참조하기 때문에 레퍼런스가 지워지지 않아, count가 1이 됩니다.</li>
  <li>순환참조는 다음과 같은 방법으로 탐지할 수 있습니다.
    <ol>
      <li>각 객체의 gc_refs 필드를 레퍼런스 카운트와 같은 값으로 설정합니다.</li>
      <li>각 객체에서 참조하는 다른 컨테이너 객체를 찾고, 참조되는 컨테이너의 gc_refs를 감소 시킵니다.</li>
      <li>어느 객체의 gc_refs가 0이 되면, 그 객체는 컨테이너 집합 내부에서 순환참조하고 있다는 뜻입니다.</li>
      <li>해당 객체를 unreachable 객체로 구분하고 메모리에서 해제합니다.</li>
    </ol>
  </li>
</ul>

<h3 id="generational-garbage-collection-모듈">Generational Garbage Collection 모듈</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gc</span><span class="p">.</span><span class="nf">get_count</span><span class="p">():</span> <span class="n">각</span> <span class="n">세대의</span> <span class="n">객체</span> <span class="n">수를</span> <span class="n">확인합니다</span><span class="p">.</span>
<span class="n">gc</span><span class="p">.</span><span class="nf">set_threshold</span><span class="p">():</span> <span class="n">세대별</span> <span class="n">임계치를</span> <span class="n">설정합니다</span><span class="p">.</span>
<span class="n">gc</span><span class="p">.</span><span class="nf">collect_generations</span><span class="p">()</span>
<span class="p">:</span> <span class="n">모든</span> <span class="n">세대에</span> <span class="n">대해</span> <span class="mi">2</span><span class="n">세대부터</span> <span class="mi">0</span><span class="n">세대까지의</span> <span class="n">순서로</span> <span class="n">확인하고</span><span class="p">,</span> <span class="n">임계치</span> <span class="n">초과시</span> <span class="nf">collect</span><span class="p">()</span> <span class="n">호출합니다</span><span class="p">.</span>
<span class="n">gc</span><span class="p">.</span><span class="nf">collect</span><span class="p">():</span> <span class="n">가비지</span> <span class="n">컬렉션을</span> <span class="n">수행하여</span> <span class="n">순환참조</span> <span class="n">객체를</span> <span class="n">메모리에서</span> <span class="n">해제합니다</span><span class="p">.</span>
<span class="n">gc</span><span class="p">.</span><span class="nf">disable</span><span class="p">():</span> <span class="n">가비지</span> <span class="n">컬렉팅을</span> <span class="n">비활성화할</span> <span class="n">수</span> <span class="n">있습니다</span><span class="p">.</span>
</code></pre></div></div>

<h4 id="gc와-프로그램-성능">GC와 프로그램 성능</h4>
<ul>
  <li>가비지 컬렉션을 수행하려면 프로그램을 완전히 중지해야하기 때문에, 객체가 많을수록 가비지 컬렉션을 수행하기 위한 시간이 더 많이 필요합니다.</li>
  <li>가비지 컬렉션 주기가 짧으면 여유 메모리를 확보할 수 있지만, 프로그램이 중단되는 상황이 많이 발생합니다. 주기가 길면 프로그램이 자주 중단되지는 않지만 메모리 공간에 가비지가 많이 쌓입니다.</li>
</ul>

<h2 id="파이썬-글로벌-메모리-관리">파이썬 글로벌 메모리 관리</h2>

<h3 id="리눅스에서의-메모리-관리">리눅스에서의 메모리 관리</h3>
<ul>
  <li>리눅스에서 프로세스가 메모리를 할당 받으면, 프로세스가 종료되기 전까지 할당받은 메모리를 그대로 가지고 있습니다. 따라서, 프로세스에 할당되는 메모리가 시간이 지남에 따라서</li>
  <li>파이썬의 경우, C언어를 기반으로 사용하는 Cpython에서는 <code class="language-plaintext highlighter-rouge">glibc</code>를 사용합니다. <code class="language-plaintext highlighter-rouge">glibc</code>는 동적 메모리 할당에 <code class="language-plaintext highlighter-rouge">malloc()</code>과 <code class="language-plaintext highlighter-rouge">free()</code> 함수를 사용합니다.</li>
  <li>리눅스는 <code class="language-plaintext highlighter-rouge">malloc()</code>을 호출하면 <code class="language-plaintext highlighter-rouge">brk()</code>, <code class="language-plaintext highlighter-rouge">nmap()</code>을 사용하여 메모리를 할당하게 됩니다.</li>
  <li>128KB보다 작은 경우에는 <code class="language-plaintext highlighter-rouge">brk()</code>, 보다 큰 메모리의 경우 <code class="language-plaintext highlighter-rouge">nmap()</code>을 사용합니다.</li>
</ul>

<h3 id="파이썬에서의-메모리-관리">파이썬에서의 메모리 관리</h3>
<ul>
  <li>파이썬은 PyMalloc을 사용하여 메모리를 할당합니다. PyMalloc은 Arena라는 라이브러리를 기반으로 동작합니다.</li>
  <li>Arena는 힙 메모리 영역에서 256KB를 OS로부터 할당받은 후, 64개의 4KB(x86 아키텍처 페이지 사이즈) 단위의 메모리 풀(pool)로 나뉘게 됩니다. 각 풀은 다시 512B의 블록으로 나뉘어집니다. 블럭은 객체가 저장될 공간이며, 메모리 풀은 블럭을 관리하는데 사용되고, Arena는 메모리 풀을 관리합니다.</li>
  <li>객체별로 얼로케이터들은 Arena에서 순서대로 풀을 가지고 옵니다. 각 풀을 사용 가능한 블럭들을 이용해 자신의 객체들을 할당합니다. 풀에 사용 가능한 블록이 없다면 다음 풀로 넘어가고 풀이 없다면 새로운 Arena가 할당되어 Arena의 풀에 실제 객체가 할당됩니다.</li>
  <li><code class="language-plaintext highlighter-rouge">del</code> 명령어를 사용해 객체를 지우고, reference count가 0이 되거나 순환참조되어 가비지 컬렉션이 진행되더라도 실제로 운영체제로 메모리가 반환되지 않는 이유는 메모리가 Arena 단위로 관리되기 때문입니다.</li>
  <li>Arena는 하위 64개 풀이 모두 할당되지 않은 상태여야만 운영체제로 반환됩니다.</li>
</ul>

<h2 id="참고">참고</h2>
<h4 id="garbage-collectiong">Garbage Collectiong</h4>
<p><a href="https://velog.io/@zihs0822/Python의-GC와-GIL">Python의 Garbage Collecting</a>
<a href="https://devbull.xyz/python-garbace-collection/">파이썬의 가비지 콜렉션에 대해서</a>
<a href="https://deeppago.tistory.com/69">Deeppago님의 블로그</a></p>
<h4 id="파이썬-메모리-관리">파이썬 메모리 관리</h4>
<p><a href="https://changmyeong.tistory.com/52">파이썬의 메모리 관리</a></p>]]></content><author><name>Yeham Kim</name></author><category term="Study" /><summary type="html"><![CDATA[가비지 컬렉터]]></summary></entry><entry><title type="html">[Django] SOLID 원칙에 따른 Django ORM 사용</title><link href="http://localhost:4000/study/django-solid/" rel="alternate" type="text/html" title="[Django] SOLID 원칙에 따른 Django ORM 사용" /><published>2023-10-19T00:05:07+09:00</published><updated>2023-10-19T00:05:07+09:00</updated><id>http://localhost:4000/study/django-solid</id><content type="html" xml:base="http://localhost:4000/study/django-solid/"><![CDATA[<h2 id="글을-작성하게-된-이유">글을 작성하게 된 이유</h2>
<ul>
  <li>Spring과 같은 웹 프레임 워크에서는 자바의 클래스 기반의 특성을 활용하여 OOP 방식으로 코드를 작성하는 것이 수월하다는 것을 익히 들어왔고, 공부해왔습니다.</li>
  <li>Django에서는 DRF라는 프레임워크가 이에 대한 역할을 어느정도 수행해주지만, 커스텀한 코드들을 짤 때 어떻게 SOLID한 방식으로 작성할 수 있을 것인지, 역할과 책임을 어떻게 분리하여 좋은 코드를 만들 수 잇을 것인지 고민하게 되었습니다.</li>
  <li>다양한 자료를 보며 실용적인 코드를 작성할 수 있는 팁을 모아두어 공부하기 위해 블로깅하게 되었습니다.</li>
</ul>

<h3 id="introduction">Introduction</h3>
<ul>
  <li>SOLID 원칙은 개발자들이 소프트웨어 시스템을 유연하게 하여, 더 유지보수가 쉽고 확장이 가능하도록 하는 방법입니다.</li>
  <li>Django의 파트 중 ORM에 대한 부분에 이를 적용하여 쿼리 빌딩을 최적화하고 앱 성능을 향상시키는 방법을 알아보겠습니다.</li>
</ul>

<h3 id="single-responsibility-principle-srp">Single Responsibility Principle (SRP)</h3>
<ul>
  <li>SRP는 클래스가 변경되어야하는 이유는 단 하나의 이유 때문이라는 원칙입니다. (클래스의 단일 책임)</li>
  <li>Django ORM에서는 SRP를 통해 더 작고 모놀리식 모델을 피해 모델에 집중하여 다양한 태스크를 수행하는 방식으로 작성해야합니다.</li>
  <li>따라서, SRP를 준수하기 위해 장고 모델에 단일 목적을 제공하고 한 가지 유형의 데이터만 처리하도록 합니다.</li>
</ul>

<h3 id="openclosed-principle-ocp">Open/Closed Principle (OCP)</h3>
<ul>
  <li>소프트웨어 객체는 확장에는 열려있고 수정에는 닫혀있어야 한다는 원칙입니다.</li>
  <li>Django ORM에서, 이 원칙는 추상 기본 클래스(abstract base class)와 믹스인을 사용하여 기존 코드를 수정하지 않고 기능을 확장함으로써 적용할 수 있습니다.</li>
  <li>코드 예시는 다음과 같습니다.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kn">from</span> <span class="n">django.db</span> <span class="kn">import</span> <span class="n">models</span>
  <span class="kn">import</span> <span class="n">datetime</span>

  <span class="k">class</span> <span class="nc">TimestampMixin</span><span class="p">(</span><span class="n">models</span><span class="p">.</span><span class="n">Model</span><span class="p">):</span>
      <span class="n">created_at</span> <span class="o">=</span> <span class="n">models</span><span class="p">.</span><span class="nc">DateTimeField</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">datetime</span><span class="p">.</span><span class="n">datetime</span><span class="p">.</span><span class="n">now</span><span class="p">)</span>
      <span class="n">updated_at</span> <span class="o">=</span> <span class="n">models</span><span class="p">.</span><span class="nc">DateTimeField</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">datetime</span><span class="p">.</span><span class="n">datetime</span><span class="p">.</span><span class="n">now</span><span class="p">)</span>
      <span class="k">class</span> <span class="nc">Meta</span><span class="p">:</span>
          <span class="n">abstract</span> <span class="o">=</span> <span class="bp">True</span>

  <span class="k">class</span> <span class="nc">Post</span><span class="p">(</span><span class="n">TimestampMixin</span><span class="p">,</span> <span class="n">models</span><span class="p">.</span><span class="n">Model</span><span class="p">):</span>
      <span class="n">title</span> <span class="o">=</span> <span class="n">models</span><span class="p">.</span><span class="nc">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
      <span class="n">content</span> <span class="o">=</span> <span class="n">models</span><span class="p">.</span><span class="nc">TextField</span><span class="p">()</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="liskov-substitution-principle-lsp">Liskov Substitution Principle (LSP)</h3>
<ul>
  <li>LSP는 슈퍼클래스의 객체가 프로그램의 일관성에 영향을 미치지 않고 서브클래스의 객체로 대체될 수 있어야 한다는 원칙입니다.</li>
  <li>Django ORM에서 이 원칙은 모델을 상속하고, 상속된 모델이 기본 클래스의 예상되는 동작을 유지하도록 할 수 있습니다.</li>
  <li>코드 예시는 다음과 같습니다.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">Content</span><span class="p">(</span><span class="n">models</span><span class="p">.</span><span class="n">Model</span><span class="p">):</span>
      <span class="n">text</span> <span class="o">=</span> <span class="n">models</span><span class="p">.</span><span class="nc">TextField</span><span class="p">()</span> 
      <span class="k">def</span> <span class="nf">word_count</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
          <span class="k">return</span> <span class="nf">len</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">text</span><span class="p">.</span><span class="nf">split</span><span class="p">())</span> 

  <span class="k">class</span> <span class="nc">Article</span><span class="p">(</span><span class="n">Content</span><span class="p">):</span>
      <span class="n">title</span> <span class="o">=</span> <span class="n">models</span><span class="p">.</span><span class="nc">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
      <span class="n">author</span> <span class="o">=</span> <span class="n">models</span><span class="p">.</span><span class="nc">ForeignKey</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">on_delete</span><span class="o">=</span><span class="n">models</span><span class="p">.</span><span class="n">CASCADE</span><span class="p">)</span>    
      <span class="k">def</span> <span class="nf">word_count</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
          <span class="k">return</span> <span class="nf">super</span><span class="p">().</span><span class="nf">word_count</span><span class="p">()</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="interface-segregation-principle-isp">Interface Segregation Principle (ISP)</h3>
<ul>
  <li>고객이 사용하지 않는 인터페이스에 대해서는 의존하지 않도록 인터페이스 각각을 구체적으로 작성하여 서로 분리해야한다는 원칙입니다. (인터페이스의 단일 책임)</li>
  <li>Django ORM에서, 사용자 지정 <code class="language-plaintext highlighter-rouge">Model Manger</code>와 <code class="language-plaintext highlighter-rouge">queryset</code>을 만들어 적용할 수 있으며, 고객이 필요한 관련된 기능만을 사용할 수 있도록 합니다.</li>
  <li>코드 예시는 다음과 같습니다.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">ActiveUserManager</span><span class="p">(</span><span class="n">models</span><span class="p">.</span><span class="n">Manager</span><span class="p">):</span>
      <span class="k">def</span> <span class="nf">active_users</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
          <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="n">is_active</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
      <span class="k">def</span> <span class="nf">inactive_users</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
          <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="n">is_active</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

  <span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">models</span><span class="p">.</span><span class="n">Model</span><span class="p">):</span>
      <span class="n">is_active</span> <span class="o">=</span> <span class="n">models</span><span class="p">.</span><span class="nc">BooleanField</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
      <span class="n">objects</span> <span class="o">=</span> <span class="nc">ActiveUserManager</span><span class="p">()</span>
</code></pre></div>    </div>
    <ul>
      <li>커스텀 <code class="language-plaintext highlighter-rouge">model manager</code>를 통해 기본 objects의 기능을 사용할 뿐만 아니라(ActiveUserManager가 기본 매니저 상속) 커스텀 매니저 기능도 사용할 수 있게 됩니다.<br />
  (상황에 따라서는 커스텀 매니저와 기본 매니저를 분리해서 지정하는 것도 가능)</li>
    </ul>
  </li>
</ul>

<h3 id="dependency-inversion-principle-dip">Dependency Inversion Principle (DIP)</h3>
<ul>
  <li>높은 수준의 모듈이 낮은 수준의 모듈에 의존하면 안된다는 원칙입니다. 대신, 추상화에 의존해야합니다.</li>
  <li>Django ORM에서 이 원리는 ForeignKey, OneToOneField 및 ManyToManyField와 같은 모델 관계를 사용자 정의하기 위해 Django의 내장 기능을 사용하여 지킬 수 있습니다.</li>
  <li>이러한 추상화에 의존함으로써, 높은 수준의 애플리케이션 로직을 데이터베이스 스키마의 낮은 수준의 세부 사항과 분리할 수 있다는 장점이 있습니다.</li>
  <li>코드 예시는 다음과 같습니다.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kn">from</span> <span class="n">django.conf</span> <span class="kn">import</span> <span class="n">settings</span>
  <span class="kn">from</span> <span class="n">django.db</span> <span class="kn">import</span> <span class="n">models</span>

  <span class="k">class</span> <span class="nc">Post</span><span class="p">(</span><span class="n">models</span><span class="p">.</span><span class="n">Model</span><span class="p">):</span>
      <span class="n">author</span> <span class="o">=</span> <span class="n">models</span><span class="p">.</span><span class="nc">ForeignKey</span><span class="p">(</span><span class="n">settings</span><span class="p">.</span><span class="n">AUTH_USER_MODEL</span><span class="p">,</span> <span class="n">on_delete</span><span class="o">=</span><span class="n">models</span><span class="p">.</span><span class="n">CASCADE</span><span class="p">)</span>
      <span class="n">title</span> <span class="o">=</span> <span class="n">models</span><span class="p">.</span><span class="nc">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
      <span class="n">content</span> <span class="o">=</span> <span class="n">models</span><span class="p">.</span><span class="nc">TextField</span><span class="p">()</span>
</code></pre></div>    </div>
    <ul>
      <li>외래 키 관계에서, 장고의 내장 설정인 AUTH_USER_MODEL을 추상화로 사용할 수 있습니다.</li>
    </ul>
  </li>
</ul>

<h3 id="결론">결론</h3>
<ul>
  <li>Django의 내장 ORM 기능과 DRF가 알게 모르게 SOLID 원칙에 기반하여 각각의 기능들이 구성되있음을 파악할 수 있었습니다.</li>
  <li>특히, ORM에서 Manager의 기능에 대해 더 학습하고 공부해야겠다고 생각하여, 계속해서 Django Manager의 기능에 대해 작성해보겠습니다.</li>
</ul>

<h2 id="django-manager-활용하기">Django Manager 활용하기</h2>

<h3 id="manager를-통해-queryset에-대한-중복-코드를-제거하는-방법">Manager를 통해 QuerySet에 대한 중복 코드를 제거하는 방법</h3>
<h4 id="일반적인-사용">일반적인 사용</h4>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">models</span><span class="p">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="p">.</span><span class="nc">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
    <span class="n">active</span> <span class="o">=</span> <span class="n">models</span><span class="p">.</span><span class="nc">BooleanField</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</code></pre></div></div>
<ul>
  <li>이 때 활성화된 유저만 사용하기 위해서는 필요한 구간마다, <code class="language-plaintext highlighter-rouge">User.objects.filter(active=True)</code>와 같은 방식으로 호출하게 됩니다.</li>
  <li>만약, <code class="language-plaintext highlighter-rouge">active=True</code> 조건 이외에도 활성화된 유저를 찾는 방식에 추가적인 조건이 사용된다면(ex. 일정날짜 이후 가입 유저만 활성화 유저로 인정하겠다), 모든 구문을 찾아서 변경해주어야 할 것입니다.</li>
</ul>

<h4 id="코드-수정-이후">코드 수정 이후</h4>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ActiveManager</span><span class="p">(</span><span class="n">models</span><span class="p">.</span><span class="n">Manager</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get_queryset</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nf">super</span><span class="p">().</span><span class="nf">get_queryset</span><span class="p">().</span><span class="nf">filter</span><span class="p">(</span><span class="n">active</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">models</span><span class="p">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">objects</span> <span class="o">=</span> <span class="n">models</span><span class="p">.</span><span class="nc">Manager</span><span class="p">()</span>
    <span class="n">active_objects</span> <span class="o">=</span> <span class="nc">ActiveManager</span><span class="p">()</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">ActiveManager</code> 클래스를 추가하여, 메서드로 기입된 기능을 User에게 위임합니다.</li>
  <li>이때, <code class="language-plaintext highlighter-rouge">ActiveManager</code>는 기본 매니저를 상속받기 때문에, <code class="language-plaintext highlighter-rouge">User.active_objects.exclude(name="admin")</code>와 같은 기능도 사용할 수 있습니다.</li>
</ul>

<h4 id="default-manager-설정시-주의사항">Default Manager 설정시 주의사항</h4>
<ul>
  <li>Default Manager은 기본적으로 Django 프레임워크 내부에서 우선순위에 따라 선정합니다.
    <ol>
      <li>Meta.default_manager_name 설정</li>
      <li>부모(다중 상속받는 경우 가장 첫 번째 클래스) 클래스의 Meta.default_manager_name 설정</li>
      <li>해당 모델내에서 manager를 정의했다면, 가장 첫 번째 설정된 manager</li>
    </ol>
  </li>
  <li>따라서, 모델 내에서 아래와 같이 명시적으로 작성을 해주는 것이 좋습니다.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">models</span><span class="p">.</span><span class="n">Model</span><span class="p">):</span>
      <span class="n">active_objects</span> <span class="o">=</span> <span class="nc">ActiveManager</span><span class="p">()</span>
      <span class="n">objects</span> <span class="o">=</span> <span class="n">models</span><span class="p">.</span><span class="nc">Manager</span><span class="p">()</span>

      <span class="k">class</span> <span class="nc">Meta</span><span class="p">:</span>
          <span class="n">default_manager_name</span> <span class="o">=</span> <span class="sh">'</span><span class="s">objects</span><span class="sh">'</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="custom-queryset-사용하기">Custom QuerySet 사용하기</h3>
<h4 id="manager-사용에서-queryset-중복-제거">Manager 사용에서 QuerySet 중복 제거</h4>
<ul>
  <li>
    <p>ORM 중복코드를 사용하면, 내부에서 QuerySet 중복 코드가 발생하게 됩니다.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">PersonQuerySet</span><span class="p">(</span><span class="n">models</span><span class="p">.</span><span class="n">QuerySet</span><span class="p">):</span>
      <span class="k">def</span> <span class="nf">authors</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
          <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="n">role</span><span class="o">=</span><span class="sh">'</span><span class="s">A</span><span class="sh">'</span><span class="p">)</span>
      <span class="k">def</span> <span class="nf">editors</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
          <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="n">role</span><span class="o">=</span><span class="sh">'</span><span class="s">E</span><span class="sh">'</span><span class="p">)</span>

  <span class="c1"># class PersonManager(models.Manager):
</span>  <span class="c1">#     def get_queryset(self):
</span>  <span class="c1">#         return PersonQuerySet(self.model, using=self._db)
</span>  <span class="c1">#     def authors(self):
</span>  <span class="c1">#         return self.get_queryset()
</span>  <span class="c1">#     def editors(self):
</span>  <span class="c1">#         return self.get_queryset()
</span>
  <span class="k">class</span> <span class="nc">ActivePersonManager</span><span class="p">(</span><span class="n">models</span><span class="p">.</span><span class="n">Manager</span><span class="p">):</span>
      <span class="k">def</span> <span class="nf">get_queryset</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
          <span class="k">return</span> <span class="n">PersonQuerySet</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="n">active</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
      <span class="c1"># def authors(self):
</span>      <span class="c1">#     return self.get_queryset()
</span>      <span class="c1"># def editors(self):
</span>      <span class="c1">#     return self.get_queryset()
</span>
  <span class="k">class</span> <span class="nc">Person</span><span class="p">(</span><span class="n">models</span><span class="p">.</span><span class="n">Model</span><span class="p">):</span>
      <span class="n">first_name</span> <span class="o">=</span> <span class="n">models</span><span class="p">.</span><span class="nc">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
      <span class="n">last_name</span> <span class="o">=</span> <span class="n">models</span><span class="p">.</span><span class="nc">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
      <span class="n">role</span> <span class="o">=</span> <span class="n">models</span><span class="p">.</span><span class="nc">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">choices</span><span class="o">=</span><span class="p">[</span>
          <span class="p">(</span><span class="sh">'</span><span class="s">A</span><span class="sh">'</span><span class="p">,</span> <span class="nf">_</span><span class="p">(</span><span class="sh">'</span><span class="s">Author</span><span class="sh">'</span><span class="p">)),</span> <span class="p">(</span><span class="sh">'</span><span class="s">E</span><span class="sh">'</span><span class="p">,</span> <span class="nf">_</span><span class="p">(</span><span class="sh">'</span><span class="s">Editor</span><span class="sh">'</span><span class="p">))</span>
      <span class="p">])</span>
      <span class="n">active</span> <span class="o">=</span> <span class="n">models</span><span class="p">.</span><span class="nc">BooleanField</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
      <span class="n">people</span> <span class="o">=</span> <span class="n">PersonManager</span><span class="p">.</span><span class="nf">as_manager</span><span class="p">()</span>
      <span class="n">active_people</span> <span class="o">=</span> <span class="n">ActivePeopleManager</span><span class="p">.</span><span class="nf">from_queryset</span><span class="p">(</span><span class="n">PersonQuerySet</span><span class="p">)()</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">as_manager</code> 메서드를 통해 커스텀 쿼리셋 자체를 매니저로서 사용할 수 있습니다. 아래와 같은 역할을 합니다.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">PersonManager</span><span class="p">(</span><span class="n">models</span><span class="p">.</span><span class="n">Manager</span><span class="p">):</span>
      <span class="k">def</span> <span class="nf">get_queryset</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
          <span class="k">return</span> <span class="nc">PersonQuerySet</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">model</span><span class="p">,</span> <span class="n">using</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="n">_db</span><span class="p">)</span>
      <span class="k">def</span> <span class="nf">authors</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
          <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">get_queryset</span><span class="p">().</span><span class="nf">filter</span><span class="p">(</span><span class="n">role</span><span class="o">=</span><span class="sh">'</span><span class="s">A</span><span class="sh">'</span><span class="p">)</span>
      <span class="k">def</span> <span class="nf">editors</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
          <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">get_queryset</span><span class="p">().</span><span class="nf">filter</span><span class="p">(</span><span class="n">role</span><span class="o">=</span><span class="sh">'</span><span class="s">B</span><span class="sh">'</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">from_queryset</code> 메서드를 통해 기존 매니저에 기본 쿼리셋으로 설정할 커스텀 쿼리셋을 추가할 수 있습니다.</p>
  </li>
</ul>

<h2 id="references">References</h2>
<ul>
  <li><a href="https://www.nextree.co.kr/p6960/">넥스트리소프트 - 객체지향 개발 5대 원리:SOLID</a></li>
  <li><a href="https://medium.com/@dkthelearner/leveraging-solid-principles-in-django-orm-for-optimized-query-building-fd52e60133e8">Dinesh Kumar님의 블로그</a></li>
  <li><a href="https://blog.hwahae.co.kr/all/tech/tech-tech/4108">화해블로그 - Django Manager 적용</a></li>
</ul>]]></content><author><name>Yeham Kim</name></author><category term="Study" /><summary type="html"><![CDATA[글을 작성하게 된 이유 Spring과 같은 웹 프레임 워크에서는 자바의 클래스 기반의 특성을 활용하여 OOP 방식으로 코드를 작성하는 것이 수월하다는 것을 익히 들어왔고, 공부해왔습니다. Django에서는 DRF라는 프레임워크가 이에 대한 역할을 어느정도 수행해주지만, 커스텀한 코드들을 짤 때 어떻게 SOLID한 방식으로 작성할 수 있을 것인지, 역할과 책임을 어떻게 분리하여 좋은 코드를 만들 수 잇을 것인지 고민하게 되었습니다. 다양한 자료를 보며 실용적인 코드를 작성할 수 있는 팁을 모아두어 공부하기 위해 블로깅하게 되었습니다.]]></summary></entry><entry><title type="html">[Django] 파이썬에서 프레임워크에서 구현하는 동기화 / 비동기화</title><link href="http://localhost:4000/study/django-sync-async/" rel="alternate" type="text/html" title="[Django] 파이썬에서 프레임워크에서 구현하는 동기화 / 비동기화" /><published>2023-10-18T00:05:07+09:00</published><updated>2023-10-18T00:05:07+09:00</updated><id>http://localhost:4000/study/django-sync-async</id><content type="html" xml:base="http://localhost:4000/study/django-sync-async/"><![CDATA[<h2 id="기억해야할-용어와-각-기능의-차이">기억해야할 용어와 각 기능의 차이</h2>
<h3 id="동시성과-병렬성">동시성과 병렬성</h3>
<ul>
  <li>동시성: 하나의 시스템이 여러 작업을 동시에 처리하는 것처럼 보이게 하는 것입니다. 논리적인 개념으로, 싱글 코어에서 멀티 쓰레드를 동작시키는 방식입니다.</li>
  <li>병렬성: 여러 작업을 실제로 동시에 처리하는 것입니다. 물리적인 개념으로, 멀티코어에서 멀티 스레드를 동작시키는 방식입니다.</li>
</ul>

<h3 id="sync--async">sync &amp; async</h3>
<ul>
  <li>프로그램의 주 실행흐름을 멈추지 않고 진행할 수 있는가에 대한 여부로 판단할 수 있습니다.</li>
  <li>코드의 실행 결과 처리 및 활용하는 것을 별도의 채널에 맡겨둔 뒤 결과를 기다리지 않고 바로 다음 코드를 실행하는 방식으로 프로그램을 진행합니다.</li>
</ul>

<h3 id="blocking--none-blocking">Blocking &amp; None-blocking</h3>
<ul>
  <li>입출력 처리가 완료될 때까지 기다릴 것인지 혹은 시작만 해두고 다음 작업을 계속 진행할 것인지에 대한 여부로 판단할 수 있습니다.</li>
  <li>I/O 작업이 완료된 이후에 연결하여 진행할 후속 작업이 있는 경우, Polling이나 Callback 함수를 사용합니다.</li>
</ul>

<h3 id="async-vs-non-blocking">async vs non-blocking</h3>
<ul>
  <li>Blocking I/O를 사용하더라도 별도의 채널을 통한 작업으로 이루어짐으로써 어떤 프로그램의 주 실행흐름을 막지 않는다면 Asynchronous Programming으로 개발했다고 볼 수 있습니다.</li>
  <li>만약, A라는 작업과 B라는 작업이 있다면 블로킹 상태에서 B 작업이 CPU에서 실행되기 시작할 때, 제어권을 A에게 넘겨주지 않습니다. 따라서 A 작업은 B 작업이 끝나기 전에 CPU에서 실행될 수 없습니다.</li>
  <li>하지만, Non-blocking 상태라면 B 작업은 실행과 동시에 A에게도 제어권을 넘겨주어, A는 B가 작업하는 동안 자신도 CPU에서 작업을 수행할 수 있는 상태가 됩니다.</li>
  <li>I/O 처리를 하여 작업을 수행하다가 커널에서 해당 작업이 끝나면 Interrupt를 진행하는 방식으로 Non-blocking 처리를 합니다.</li>
</ul>

<h3 id="sync-상황에서-blocking-non-blocking">Sync 상황에서 Blocking, Non-blocking</h3>
<h4 id="blocking">Blocking</h4>
<ul>
  <li>A가 작업을 요청하면 B 작업은 A를 블로킹합니다.</li>
  <li>따라서, A는 B가 작업을 마칠 때까지 아무것도 하지 못하게 됩니다.</li>
  <li>B 작업이 마쳐지면 응답으로 작업의 결과와 함께 다시 제어권이 주어지게 됩니다.</li>
</ul>

<h4 id="non-blocking">Non-blocking</h4>
<ul>
  <li>B 작업은 시작과 동시에 A에게 반환을 하며 제어권을 넘깁니다.</li>
  <li>A 작업은 수행이 되지만, A는 B의 작업이 언제 끝마칠지 알 수 없기 때문에 지속적으로 결과를 확인합니다. (Polling)</li>
  <li>B 작업이 끝나기 전에 다른 작업을 요청할 수 없습니다.</li>
</ul>

<h3 id="async-상황에서-blocking-non-blocking">Async 상황에서 Blocking, Non-blocking</h3>
<h4 id="blocking-1">Blocking</h4>
<ul>
  <li>Sync의 블로킹 상황과 동일합니다.</li>
</ul>

<h4 id="non-blocking-1">Non-blocking</h4>
<ul>
  <li>자원과 시간이 모두 효율적인 구조입니다.</li>
  <li>A는 자신의 작업을 수행하며 여러 작업을 요청 또한 할 수 있습니다. 각각의 요청은 완전히 독립적이며, 어떤 작업이 얼마나 걸리는지를 예측할 수가 없습니다.</li>
  <li>따라서, 결과를 받아서 처리하는 부분을 Callback 함수를 통해 전달해야하고, 콜백 로직을 제대로 사용해야합니다.</li>
</ul>

<h3 id="python에서의-비동기-처리">Python에서의 비동기 처리</h3>
<ul>
  <li>새로운 실행 흐름을 만들기 위해서는 Thread와 Process를 이해해야합니다.</li>
  <li>CPython은 GIL에 의해 한 번에 하나의 스레드 밖에 처리하지 못합니다. 여러 스레드를 생성하더라도 하나의 CPU에서 Context-Switching을 반복하며 수행합니다.</li>
  <li>따라서, 비동기 처리를 위해 multiprocessing 모듈을 활용한 병렬 프로그래밍을 해야합니다.</li>
  <li>하지만 I/O-bound 작업의 경우에는 스레드 기반의 병렬 처리 모델이 효과적이기 때문에 파이썬은 멀티 스레드를 관리하기 위해 asyncio 라이브러리를 비동기 표준 라이브러리로 지원하게 됩니다.</li>
</ul>

<h3 id="asyncio">asyncio</h3>
<ul>
  <li>async/await 구문을 사용하여 동시성 코드를 작성하는 라이브러리입니다.</li>
  <li>Coroutine과 Task를 동작시키기 위한 고수준 API들을 의미합니다.</li>
  <li>저수준 API 제공: 네트워킹, 자식 프로세스 실행, OS 시그널 처리 등의 비동기 API를 제공하는 이벤트 루프를 만들고 관리합니다.</li>
</ul>

<h4 id="coroutine">Coroutine</h4>
<ul>
  <li>시작과 종료만 존재하는 서브루틴과 달리 코루틴은 중간에 다양한 시점에서 정지하고 재개하는 것이 가능합니다.</li>
  <li>제너레이터의 특별한 형태로, <code class="language-plaintext highlighter-rouge">yield</code>를 통해 값을 받아올 수 있습니다. 코루틴의 값을 보낼 때는 <code class="language-plaintext highlighter-rouge">send</code>를 통해 값을 보낼 수 있으며, 예시는 다음과 같습니다.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">number_coroutine</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="k">yield</span><span class="p">)</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">x</span>
            <span class="nf">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="sh">'</span><span class="s"> </span><span class="sh">'</span><span class="p">)</span>
    <span class="k">except</span> <span class="nb">GeneratorExit</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">()</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">코루틴 종료</span><span class="sh">'</span><span class="p">)</span>
    <span class="k">except</span> <span class="nb">RuntimeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">total</span> <span class="c1"># 코루틴 바깥으로 값전달
</span>  
<span class="n">co</span> <span class="o">=</span> <span class="nf">number_coroutine</span><span class="p">()</span>
<span class="nf">next</span><span class="p">(</span><span class="n">co</span><span class="p">)</span>
  
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">20</span><span class="p">):</span>
    <span class="n">co</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    
<span class="nf">print</span><span class="p">(</span><span class="n">co</span><span class="p">.</span><span class="nf">throw</span><span class="p">(</span><span class="nb">RuntimeError</span><span class="p">,</span> <span class="sh">'</span><span class="s">예외로 코루틴 끝내기</span><span class="sh">'</span><span class="p">))</span>
<span class="c1"># co.close()
</span></code></pre></div>    </div>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">next()</code>메서드로 <code class="language-plaintext highlighter-rouge">yield</code>까지 코드를 실행해둔 후, <code class="language-plaintext highlighter-rouge">send()</code> 메서드를 통해 값을 전송합니다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">프로세스 &gt; 스레드 &gt; 코루틴</code> 순서로 가볍습니다. 그 이유는 프로세스와 스레드는 운영체제의 관리 안에서 돌아가는 실행 흐름이지만 코루틴은 프로그래밍 언어 내에서 관리되는 실행흐름이기 때문입니다.</li>
  <li>코루틴은 Promise처럼 하나의 객체로 구현되며 <code class="language-plaintext highlighter-rouge">async def</code> 키워드를 통해 정의할 수 있습니다.</li>
  <li><code class="language-plaintext highlighter-rouge">asyncio.run()</code>은 코루틴을 실행하도록 하는 함수이며, <code class="language-plaintext highlighter-rouge">await</code> 는 코루틴의 실행과 완료를 기다리도록 하는 키워드입니다.</li>
  <li>asyncio에서 이러한 코루틴들을 수행하고 멀티태스킹을 관리하는 주체를 이벤트 루프라고 합니다. <code class="language-plaintext highlighter-rouge">run()</code> 의 매개변수로 코루틴을 넣고, 직접 실행시킴으로써 이벤트 루프를 생성하고 해당 코루틴을 메인 엔트리로 등록하여 코루틴이 종료되면 이벤트 루프를 종료합니다.</li>
  <li>메인 스레드에 하나의 이벤트 루프가 생기면 각종 스레드 풀과 프로세스 풀까지 관리하며 동시성을 수행하는 구조이기 때문에, <code class="language-plaintext highlighter-rouge">run()</code> 메서드도 현재 스레드에 다른 이벤트 루프가 동작 중이면 호출할 수 없습니다.</li>
</ul>

<h4 id="사용-예시">사용 예시</h4>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">asyncio</span>
<span class="kn">import</span> <span class="n">time</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">myTask</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="n">content</span><span class="p">):</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="n">delay</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">content</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">started at </span><span class="si">{</span><span class="n">time</span><span class="p">.</span><span class="nf">strftime</span><span class="p">(</span><span class="sh">'</span><span class="s">%X</span><span class="sh">'</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

    <span class="n">task1</span> <span class="o">=</span> <span class="n">asyncio</span><span class="p">.</span><span class="nf">create_task</span><span class="p">(</span><span class="nf">myTask</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="sh">'</span><span class="s">Task 1 done.</span><span class="sh">'</span><span class="p">))</span>
    <span class="n">task2</span> <span class="o">=</span> <span class="n">asyncio</span><span class="p">.</span><span class="nf">create_task</span><span class="p">(</span><span class="nf">myTask</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="sh">'</span><span class="s">Task 2 done.</span><span class="sh">'</span><span class="p">))</span>

    <span class="k">await</span> <span class="n">task1</span>
    <span class="k">await</span> <span class="n">task2</span>

    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">finished at </span><span class="si">{</span><span class="n">time</span><span class="p">.</span><span class="nf">strftime</span><span class="p">(</span><span class="sh">'</span><span class="s">%X</span><span class="sh">'</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

<span class="n">asyncio</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="nf">main</span><span class="p">())</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">create_task()</code> 메서드를 통해 코루틴을 Task 객체로 감싸준 이후 동작시켜야만 비동기적으로 처리됩니다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">asyncio</span>
<span class="kn">import</span> <span class="n">time</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">myTask</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="n">content</span><span class="p">):</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="n">delay</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">content</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">async</span> <span class="k">with</span> <span class="n">asyncio</span><span class="p">.</span><span class="nc">TaskGroup</span><span class="p">()</span> <span class="k">as</span> <span class="n">tg</span><span class="p">:</span>
        <span class="n">tg</span><span class="p">.</span><span class="nf">create_task</span><span class="p">(</span><span class="nf">myTask</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="sh">'</span><span class="s">Task 1 done.</span><span class="sh">'</span><span class="p">))</span>
        <span class="n">tg</span><span class="p">.</span><span class="nf">create_task</span><span class="p">(</span><span class="nf">myTask</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="sh">'</span><span class="s">Task 2 done.</span><span class="sh">'</span><span class="p">))</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">started at </span><span class="si">{</span><span class="n">time</span><span class="p">.</span><span class="nf">strftime</span><span class="p">(</span><span class="sh">'</span><span class="s">%X</span><span class="sh">'</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">finished at </span><span class="si">{</span><span class="n">time</span><span class="p">.</span><span class="nf">strftime</span><span class="p">(</span><span class="sh">'</span><span class="s">%X</span><span class="sh">'</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

<span class="n">asyncio</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="nf">main</span><span class="p">())</span>
</code></pre></div></div>
<ul>
  <li>파이썬 3.11 이상의 버전부터는 <code class="language-plaintext highlighter-rouge">asyncio.TaskGroup</code>을 통해 여러개의 task를 생성하여 동시에 수행할 수 있게 됩니다.</li>
</ul>

<h3 id="uvloop">uvloop</h3>
<ul>
  <li>uvloop은 Python의 asyncio에서 구현되어있는 이벤트 루프를 대체합니다.</li>
  <li>uvloop은 CPython이 아닌 Cython으로 구현되어있으며, libuv(C로 작성된 모듈)를 기반으로 합니다.</li>
</ul>

<h4 id="설정방법">설정방법</h4>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">asyncio</span>
<span class="kn">import</span> <span class="n">uvloop</span>

<span class="n">asyncio</span><span class="p">.</span><span class="nf">set_event_loop_policy</span><span class="p">(</span><span class="n">uvloop</span><span class="p">.</span><span class="nc">EventLoopPolicy</span><span class="p">())</span>
</code></pre></div></div>

<h4 id="libuv란">libuv란?</h4>
<ul>
  <li>크로스 플랫폼을 지원하는 라이브러리이며, Node.js를 위해서 만들어졌습니다.</li>
  <li>이벤트 드리븐 비동가 I/O 모델을 기반으로 구성되어있으며, kqueue, epoll, IOCP 등을 추상화합니다.</li>
</ul>

<h3 id="io-loop">I/O loop</h3>
<ul>
  <li>각각 다른 스레드에서 실행되는 여러 이벤트를 이벤트 루프에서 실행되도록 합니다.</li>
  <li>libuv의 이벤트 루프는 직접 언급되어 있지 않다면 안전하지 않은 스레드입니다.
(thread safe하지 않습니다.)</li>
  <li>모든 I/O는 각 OS에 맞는 non-blocking 소켓에서 수행됩니다.</li>
</ul>

<h2 id="파이썬-프레임워크에서의-동기화와-비동기화">파이썬 프레임워크에서의 동기화와 비동기화</h2>
<h3 id="멀티-프로세싱과-멀티-스레딩">멀티 프로세싱과 멀티 스레딩</h3>
<ul>
  <li>파이썬은 GIL 개념이 있기 때문에, 하나의 프로세스 내에서 여러 개의 스레드가 병렬적으로 실행될 수 없습니다.</li>
  <li>즉, 멀티코어 CPU에서 동작한다고 하더라도 하나의 프로세스는 동시에 여러개의 코어를 사용할 수 없습니다.</li>
  <li>I/O bound 태스크라면, 멀티 스레드 환경에서 동작하는 것이 효율적이지만,</li>
</ul>

<h2 id="동기화와-비동기화">동기화와 비동기화</h2>
<ul>
  <li>웹 애플리케이션은 짧은 시간 내에 서로 다른 클라이언트에서 받은 요청을 처리해야 하는 경우가 많습니다.</li>
  <li>짧은 기간 안에 처리하고 지연을 방지하려면, 동시에 요청들을 처리할 수 있을지에 대해 고려해야하며, 이를 동시성이라고 합니다.</li>
  <li>“sync”, “async”는 동시성을 사용하는 애플리케이션을 작성하는 두가지 방법을 나타냅니다.</li>
</ul>

<h3 id="요청에-대해-동기적으로-처리하는-방식-server-workers">요청에 대해 동기적으로 처리하는 방식 (Server workers)</h3>
<ul>
  <li>“sync” 서버는 동시성(Concurrency)을 구현하기 위해 스레드와 프로세스의 기본적으로 OS가 지원하는 기능을 사용합니다. 웹서버 및 로드밸런서는 클라이언트들의 요청에 대해 server workers pool로 요청을 분배합니다.</li>
  <li>이 때, server workers pool은 프로세스들, 스레드들 혹은 둘의 조합으로 생성되며 웹 애플리케이션 프레임워크인 Flask나 Django에 전달됩니다.</li>
  <li>multiple CPU인 경우, CPU의 코어 수에 따라서 worker들의 수를 정할 수 있습니다. 이를 통해, GIL에 의해 멀티 스레딩이 제한되어있는 경우라도 균일하게 작업을 분배할 수 있습니다.</li>
  <li>이러한 방식의 단점은, 다섯명의 클라이언트가 요청하지만 네 개의 워커가 동작하는 상황에서, race condition에 의해 남은 하나의 요청은 큐에 남아 워커에 전달될 때까지 대기 상태에 있게 된다는 것입니다.</li>
  <li>따라서, 차단된 요청을 막거나 최소화 하기 위해 막기 위해 적절한 수의 워커를 선택하는 것이 중요합니다.</li>
</ul>

<h3 id="요청에-대해-비동기적으로-처리하는-방식-task">요청에 대해 비동기적으로 처리하는 방식 (Task)</h3>
<ul>
  <li>비동기 타입의 서버는 loop에 의해 제어되는 하나의 프로세스에서 동작합니다.</li>
  <li>이러한 루프는 클라이언트에 의해 보내어진 요청들을 실행하거나 태스크를 생성하는 매우 효율적인 태스크 매니저이며, 스케쥴러입니다.</li>
  <li>풀 형태로 게속해서 상주하는 서버 워커들과 다르게 async 태스크는 특정 요청이 처리되어야 할 때마다 루프에 추가되며, 요청이 완료되면 태스크는 소멸됩니다.</li>
  <li>async 서버는 수백 혹은 수천개의 활성화된 태스크들을 가지고, 모든 태스크는 loop에서 관리되며 작업을 수행하게 됩니다.</li>
  <li>비동기 애플리케이션은 비동기 태스크들을 위해 <a href="https://en.wikipedia.org/wiki/Cooperative_multitasking">cooperative multitasking</a>에 의존합니다. 즉, 하나의 태스크가 데이터베이스 서버로부터의 응답과 같은 외부의 이벤트를 대기하는 경우, sync worker처럼 대기하는 대신 이벤트 루프에 기다려야할 사항을 알려주고 제어권을 반환합니다.</li>
  <li>async 스타일을 이용한 장점을 얻기 위해서는 애플리케이션은 “I/O에 의해 블록”되거나 “너무 많은 CPU 작업을 갖지 않는” 태스크를 가져야할 필요가 있습니다.</li>
  <li>제어권을 가진 루프는 이 작업이 데이터베이스에 의해 차단되는 동안 실행할 준비가 된 다른 작업을 찾을 수 있습니다. 따라서, 데이터베이스는 응답을 보내고 루프는 첫 번째 작업을 다시 실행할 준비가 된 것으로 간주하여 가능한 빨리 작업을 이어서 수행합니다.</li>
  <li>비동기 애플리케이션은 전체적으로 단일 프로세스와 단일 스레드에서 실행됩니다. 물론, 너무 오랫동안 CPU를 유지하는 작업을 수행하는 경우나 다른 작업을 수행할 수 없는 경우에 대한 처리는 항상 고려해야합니다.</li>
  <li>비동기적으로 동작하려면 모든 작업이 자발적으로 일시 중지되어, 제 때 제어권을 루프에 반환해야합니다. 따라서, 비동기 스타일의 이점을 활용하려면 애플리케이션에 I/O에 의해 자주 차단되고 CPU 작업이 너무 많지 않은 작업이어야 합니다.</li>
</ul>]]></content><author><name>Yeham Kim</name></author><category term="Study" /><summary type="html"><![CDATA[기억해야할 용어와 각 기능의 차이 동시성과 병렬성 동시성: 하나의 시스템이 여러 작업을 동시에 처리하는 것처럼 보이게 하는 것입니다. 논리적인 개념으로, 싱글 코어에서 멀티 쓰레드를 동작시키는 방식입니다. 병렬성: 여러 작업을 실제로 동시에 처리하는 것입니다. 물리적인 개념으로, 멀티코어에서 멀티 스레드를 동작시키는 방식입니다.]]></summary></entry><entry><title type="html">[Study] Database - 쿼리 최적화를 위한 인덱스</title><link href="http://localhost:4000/study/study-db-index/" rel="alternate" type="text/html" title="[Study] Database - 쿼리 최적화를 위한 인덱스" /><published>2023-10-17T00:05:07+09:00</published><updated>2023-10-17T00:05:07+09:00</updated><id>http://localhost:4000/study/study-db-index</id><content type="html" xml:base="http://localhost:4000/study/study-db-index/"><![CDATA[<h3 id="인덱스란-무엇인가">인덱스란 무엇인가?</h3>
<ul>
  <li>인덱스를 사용하는 이유: 조건(<code class="language-plaintext highlighter-rouge">WHERE</code>)을 만족하는 튜플들을 빠르게 조회하기 위해 사용합니다.</li>
  <li>빠르게 <code class="language-plaintext highlighter-rouge">ORDER BY</code>하거나 <code class="language-plaintext highlighter-rouge">GROUP BY</code>하기 위해 사용합니다.</li>
</ul>

<h2 id="인덱스-사용방법">인덱스 사용방법</h2>

<h3 id="인덱스-관련-명령어-예시">인덱스 관련 명령어 예시</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- name column을 기준으로 인덱스를 생성합니다.</span>
<span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">player_name_idx</span> <span class="k">ON</span> <span class="n">player</span> <span class="p">(</span><span class="n">name</span><span class="p">);</span>

<span class="c1">-- team_id와 backnumber에 대해 복합 인덱스를 생성합니다.</span>
<span class="k">CREATE</span> <span class="k">UNIQUE</span> <span class="k">INDEX</span> <span class="n">item_id_backnumber_idx</span> <span class="k">ON</span> <span class="n">player</span> <span class="p">(</span><span class="n">team_id</span><span class="p">,</span> <span class="n">backnumber</span><span class="p">);</span>

<span class="c1">-- 테이블 생성시 인덱스 설정을 포함합니다.</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">player</span> <span class="p">(</span>
  <span class="n">id</span>  <span class="nb">INT</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
  <span class="n">name</span>  <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">team_id</span> <span class="nb">INT</span><span class="p">,</span>
  <span class="n">backnumber</span> <span class="nb">INT</span><span class="p">,</span>
  <span class="k">INDEX</span> <span class="n">player_name_idx</span> <span class="p">(</span><span class="n">name</span><span class="p">),</span>
  <span class="k">UNIQUE</span> <span class="k">INDEX</span> <span class="n">team_id_backnumber_idx</span> <span class="p">(</span><span class="n">team_id</span><span class="p">,</span> <span class="n">backnumber</span><span class="p">)</span>
<span class="p">);</span>

<span class="c1">-- 해당 테이블에 대한 인덱스 정보를 알고 싶은 경우에 사용합니다.</span>
<span class="k">SHOW</span> <span class="k">INDEX</span> <span class="k">FROM</span> <span class="n">player</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="인덱스의-동작-방식">인덱스의 동작 방식</h3>
<ul>
  <li>기존 방식대로라면 원본테이블에서 원하는 조건들을 만족하는 경우에 대해 풀스캔 해야하지만, 인덱스를 사용하면 다음과 같이 동작합니다.</li>
  <li>인덱스 테이블은 인덱스 생성시 설정한 <code class="language-plaintext highlighter-rouge">INDEX(a)</code> 값에 해당하는 포인터가 원본 테이블의 a 컬럼의 값의 튜플을 가리키는 방식입니다.</li>
  <li>a에 대한 조건이 입력될 때 인덱스 테이블에서 이에 해당하는 값을 Binary Search 형태로 검색하고, 해당 조건에 대한 인덱스 검색이 완료되면 포인터가 가리키는 원본 테이블의 튜플을 찾게 됩니다.</li>
  <li><code class="language-plaintext highlighter-rouge">WHERE a=7</code>이라는 조건으로 검색된다면, 인덱스 테이블에서 <code class="language-plaintext highlighter-rouge">a=7</code>인 값을 Binary Search로 검색하고, 해당 포인터가 가리키는 원본 테이블의 값을 불러오는 방식입니다.</li>
</ul>

<h3 id="복합-인덱스를-사용하는-이유">복합 인덱스를 사용하는 이유</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">WHERE a=7 AND b=95</code>와 같은 조건으로 검색되고 인덱스 테이블에 <code class="language-plaintext highlighter-rouge">a=7</code>을 만족하는 값이 많다면, 모든 <code class="language-plaintext highlighter-rouge">a=7</code>에 대한 포인터를 통해 원본 테이블에 찾아가서 <code class="language-plaintext highlighter-rouge">b=95</code>라는 값을 일일이 확인해야합니다.</li>
  <li>인덱스 테이블에서 해당 조건을 재빠르게 먼저 찾아서 원본테이블을 참조하는 횟수를 줄이기 위해 복합인덱스를 구성할 수 있습니다. <code class="language-plaintext highlighter-rouge">CREATE INDEX(a,b)</code>: a 컬럼이 먼저 정렬되고, 이후 b 컬럼이 정렬됩니다.</li>
  <li>따라서, <code class="language-plaintext highlighter-rouge">WHERE a=7 AND b=95</code> 조건에 대해 인덱스 테이블의 튜플을 검색하고 원본 테이블에 참조하게 됩니다.</li>
  <li>하지만, 복합 인덱스만 위와 같이 설정하고 <code class="language-plaintext highlighter-rouge">WHERE b=95</code>에 대해서만 검색한다면, 결국 복합인덱스를 사용하지 않고, 원본 테이블을 풀스캔하기 때문에 조건절에 따라 인덱스를 생성하는 것이 매우 중요합니다.</li>
</ul>

<h3 id="covering-index">Covering index</h3>
<ul>
  <li>인덱스 테이블에서 조회하는 조건에 대한 모든 값을 가지고 있는 경우로, 조회 속도가 빠르다는 장점이 있기 때문에 의도적으로 사용하곤 합니다.</li>
  <li>예를 들어, <code class="language-plaintext highlighter-rouge">CREATE UNIQUE INDEX item_id_backnumber_idx ON player (team_id, backnumber)</code>로 설정을 하고, <code class="language-plaintext highlighter-rouge">SELECT * team_id, backnumber FROM players WHERE team_id = 5</code>와 같이 검색하는 경우입니다.</li>
</ul>

<h3 id="hash-index">Hash index</h3>
<ul>
  <li>hash table을 사용하여 인덱스를 구현하는 방식으로, 시간복잡도가 O(1)로 매우 빠릅니다.</li>
  <li>해시 테이블이 매우 커지면서 발생하는 rehashing 문제에 대한 부담이 있고, 값의 equality 비교만 가능하여 range 비교는 불가능하다는 단점이 있습니다.</li>
  <li>복합 인덱스 설정시 <code class="language-plaintext highlighter-rouge">INDEX (a,b)</code>로 설정할 경우 (a,b)를 동시 조건으로 처리하는 경우에만 이용할 수 있습니다. (기존 방식은 첫번쨰 인덱스인 <code class="language-plaintext highlighter-rouge">a</code>만 사용해도 인덱 동작 가능)</li>
</ul>

<h3 id="인덱스-지정하는-방법">인덱스 지정하는 방법</h3>
<ul>
  <li>기본적으로 DBMS의 optimizer가 인덱스를 스스로 반영하여 조회에 사용하지만, 사용자가 이를 커스터마이징 하여 원하는 인덱스를 사용하도록 설정할 수 있습니다.</li>
  <li>확인 방법: <code class="language-plaintext highlighter-rouge">EXPLAIN SELECT 스* FROM player WHERE backnumber=7;</code> 어떤 key를 이용하여 인덱스 참조했는지 분석할 수 있습니다.</li>
  <li>제안 설정: <code class="language-plaintext highlighter-rouge">SELECT * FROM player USE INDEX (player_name_idx) WHERE name="sonny";</code></li>
  <li>강제 설정: <code class="language-plaintext highlighter-rouge">SELECT * FROM player FORCE INDEX (player_name_idx) WHERE name="sonny";</code></li>
  <li>제외 설정: <code class="language-plaintext highlighter-rouge">SELECT * FROM player IGNORE INDEX (player_name_idx) WHERE name="sonny";</code></li>
</ul>

<h2 id="고려사항">고려사항</h2>
<ul>
  <li>인덱스를 많이 만든다는 것은 인덱스 테이블을 많이 만든다는 의미와 같습니다. 따라서, 추가 저장 공간이 발생하게 됩니다.</li>
  <li>또한, table을 수정하거나 변경할 때마다 영향을 받는 인덱스에 함께 적용되기 때문에 불필요한 인덱스를 많이 만들면 이에 대한 수정 시간도 변경되게 됩니다.</li>
</ul>

<h3 id="추가-공부">추가 공부</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">ORDER BY</code>나 <code class="language-plaintext highlighter-rouge">GROUP BY</code>에 index를 사용하는 경우</li>
  <li>이미 데이터가 매우 큰 경우에 인덱스를 추가하는 작업을 한다면 오랜 시간이 소모되어 DB 성능을 악화시킬 수 있습니다.</li>
</ul>

<h3 id="참고-자료">참고 자료</h3>
<ul>
  <li><a href="https://youtu.be/IMDH4iAQ6zM?si=U2NoBBtyJD5BQSGG">쉬운코드님 유튜브 영상</a></li>
</ul>]]></content><author><name>Yeham Kim</name></author><category term="Study" /><summary type="html"><![CDATA[인덱스란 무엇인가? 인덱스를 사용하는 이유: 조건(WHERE)을 만족하는 튜플들을 빠르게 조회하기 위해 사용합니다. 빠르게 ORDER BY하거나 GROUP BY하기 위해 사용합니다.]]></summary></entry><entry><title type="html">[Study] elastic search 사용하기</title><link href="http://localhost:4000/study/elastic-search/" rel="alternate" type="text/html" title="[Study] elastic search 사용하기" /><published>2023-10-12T00:05:07+09:00</published><updated>2023-10-12T00:05:07+09:00</updated><id>http://localhost:4000/study/elastic-search</id><content type="html" xml:base="http://localhost:4000/study/elastic-search/"><![CDATA[<h2 id="설치-및-간단한-설정">설치 및 간단한 설정</h2>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker pull docker.elastic.co/elasticsearch/elasticsearch:8.7.0
<span class="nv">$ </span>docker run <span class="nt">-p</span> 9200:9200 <span class="nt">-p</span> 9300:9300 <span class="se">\</span>
  <span class="nt">--name</span> my-elasticsearch <span class="se">\</span>
  <span class="nt">-e</span> <span class="s2">"discovery.type=single-node"</span> <span class="se">\</span>
  docker.elastic.co/elasticsearch/elasticsearch:8.7.0
</code></pre></div></div>
<ul>
  <li>9200 포트를 통해 엘라스틱 서치에 접속할 수 있도록, 9300 포트를 통해 내부에서 통신하도록 설정합니다.</li>
  <li>단일 노드로 실행하기 위해 <code class="language-plaintext highlighter-rouge">discovery.type=signle-node</code> 옵션을 추가합니다.</li>
  <li>https://localhost:9200/으로 접속하면 로그인을 통해 접속 가능합니다.</li>
</ul>

<h3 id="elastic-search-로그인을-위한-비밀번호-변경">elastic search 로그인을 위한 비밀번호 변경</h3>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> my-elasticsearch /bin/bash
<span class="nv">$ </span>elasticsearch@...:~<span class="nv">$ </span>bin/elasticsearch-setup-passwords interactive
</code></pre></div></div>
<ul>
  <li>docker 컨테이너 내부에 접속하여 계정 관련 정보를 수정할 수 있습니다.</li>
</ul>

<h2 id="엘라스틱서치-데이터-삽입조회수정삭제">엘라스틱서치 데이터 삽입/조회/수정/삭제</h2>
<h4 id="삽입">삽입</h4>
<ul>
  <li>방식: <code class="language-plaintext highlighter-rouge">PUT &lt;인덱스&gt;/_doc/&lt;도큐먼트번호&gt;</code></li>
  <li>예시
    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>curl  <span class="nt">-k</span> <span class="nt">-u</span> <span class="s2">"elastic:elastic"</span> <span class="se">\</span>
  <span class="nt">-H</span> <span class="s2">"Content-Type: application/json"</span> <span class="se">\</span>
  <span class="nt">-d</span> <span class="s1">'{ "id" : "1", "message" : "1번 데이터 입니다." }'</span> <span class="se">\</span>
  <span class="nt">-X</span> PUT https://localhost:9200/ksb/_doc/1
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="조회">조회</h4>
<ul>
  <li>방식: <code class="language-plaintext highlighter-rouge">GET &lt;인덱스&gt;/_doc/&lt;도큐먼트번호&gt;</code></li>
  <li>예시:
    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>curl  <span class="nt">-k</span> <span class="nt">-u</span> <span class="s2">"elastic:elastic"</span> <span class="se">\</span>
  <span class="nt">-H</span> <span class="s2">"Content-Type: application/json"</span> <span class="se">\</span>
  <span class="nt">-X</span> GET https://localhost:9200/ksb/_doc/1
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="수정">수정</h4>
<ul>
  <li>방식: <code class="language-plaintext highlighter-rouge">POST &lt;인덱스&gt;/_update/&lt;도큐먼트번호&gt;</code></li>
  <li>예시:
    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>curl  <span class="nt">-k</span> <span class="nt">-u</span> <span class="s2">"elastic:elastic"</span> <span class="se">\</span>
  <span class="nt">-H</span> <span class="s2">"Content-Type: application/json"</span> <span class="se">\</span>
  <span class="nt">-d</span> <span class="s1">'{ "doc": { "message": "0번 데이터 입니다." } }'</span> <span class="se">\</span>
  <span class="nt">-X</span> POST https://localhost:9200/ksb/_doc/1
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="삭제">삭제</h4>
<ul>
  <li>방식: <code class="language-plaintext highlighter-rouge">DELETE &lt;인덱스&gt;/_doc/&lt;도큐먼트번호&gt;</code></li>
  <li>예시:
    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>curl  <span class="nt">-k</span> <span class="nt">-u</span> <span class="s2">"elastic:elastic"</span> <span class="se">\</span>
  <span class="nt">-H</span> <span class="s2">"Content-Type: application/json"</span> <span class="se">\</span>
  <span class="nt">-X</span> DELETE https://localhost:9200/ksb/_doc/1
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="_bulk-api">_bulk API</h4>
<ul>
  <li>방식: <code class="language-plaintext highlighter-rouge">POST _bulk</code></li>
  <li>얘시:
    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">echo</span> <span class="s1">'
  { "index" : { "_index" : "ksb", "_id" : "1" } }
  { "field1" : "value1" }
  { "delete" : { "_index" : "ksb", "_id" : "2" } }
  { "create" : { "_index" : "ksb", "_id" : "3" } }
  { "field1" : "value3" }
  { "update" : {"_id" : "1", "_index" : "ksb"} }
  { "doc" : {"field2" : "value2"} }

  '</span> <span class="o">&gt;</span> query.json
<span class="nv">$ </span>curl  <span class="nt">-k</span> <span class="nt">-u</span> <span class="s2">"elastic:elastic"</span> <span class="se">\</span>
  <span class="nt">-H</span> <span class="s2">"Content-Type: application/json"</span> <span class="se">\</span>
  <span class="nt">-X</span> POST https://localhost:9200/_bulk <span class="se">\</span>
  <span class="nt">--data-binary</span> @query.json
</code></pre></div>    </div>
  </li>
</ul>]]></content><author><name>Yeham Kim</name></author><category term="Study" /><summary type="html"><![CDATA[설치 및 간단한 설정 $ docker pull docker.elastic.co/elasticsearch/elasticsearch:8.7.0 $ docker run -p 9200:9200 -p 9300:9300 \ --name my-elasticsearch \ -e "discovery.type=single-node" \ docker.elastic.co/elasticsearch/elasticsearch:8.7.0 9200 포트를 통해 엘라스틱 서치에 접속할 수 있도록, 9300 포트를 통해 내부에서 통신하도록 설정합니다. 단일 노드로 실행하기 위해 discovery.type=signle-node 옵션을 추가합니다. https://localhost:9200/으로 접속하면 로그인을 통해 접속 가능합니다.]]></summary></entry><entry><title type="html">[Django] web server, was, cgi, wsgi, asgi</title><link href="http://localhost:4000/django%20strategy/django-cgi/" rel="alternate" type="text/html" title="[Django] web server, was, cgi, wsgi, asgi" /><published>2023-09-24T00:05:07+09:00</published><updated>2023-09-24T00:05:07+09:00</updated><id>http://localhost:4000/django%20strategy/django-cgi</id><content type="html" xml:base="http://localhost:4000/django%20strategy/django-cgi/"><![CDATA[<h2 id="각-용어의-정의">각 용어의 정의</h2>
<h3 id="웹서버">웹서버</h3>
<ul>
  <li>인터넷을 통해서 요청된 웹 컨텐츠의 전달을 도와주는 하드웨어와 소프트웨어입니다.</li>
  <li>웹서버는 기본적으로 ‘정적’인 파일을 전달합니다.</li>
  <li>클라이언트가 HTTP 요청을 통해 리소스를 요청하면, 리소스를 그대로 보내줍니다.</li>
</ul>

<h3 id="cgi-common-gateway-interface">CGI (Common Gateway Interface)</h3>
<ul>
  <li>웹서버에서 애플리케이션(프로그램, 스크립트)을 동작시키기 위한 인터페이스입니다.</li>
  <li>정적인 웹서버를 동적으로 기능하기 위해서 등장하였으며, 서버 프로그램과 외부 프로그램 간의 인터페이스가 CGI입니다.</li>
  <li>기존에는 클리아이언트에서 외부 프로그램이 필요한 요청이 오면 CGI를 통해 외부 프로그램을 실행시켜 요청에 응답하도록 했지만, 현재는 웹서버에 인터프리터를 내장하여 프로세스를 fork해서 외부 프로그램을 실행시키지 않고 내부에서 처리합니다.</li>
</ul>

<h3 id="was-web-application-server">WAS (Web Application Server)</h3>
<ul>
  <li>동적으로 기능을 하는 웹서버로, Web Server + CGI입니다.</li>
  <li>접속자가 많은 경우 CGI 방식보다 애플리케이션 서버 방식의 처리량(Throughput)이 더 좋습니다.</li>
  <li>만약, 5개의 웹 브라우저가 동일한 프로그램을 요청했을 때 CGI는 5개의 요청에 대한 프로그램을 모두 메모리에 적재합니다.</li>
  <li>애플리케이션 서버 방식은 메모리에 한번만 적재하여 CGI 방식에 비해 전체적인 메모리 사용량이 적으며, 이는 더 많은 요청을 처리할 수 있음을 의미합니다.</li>
</ul>

<h3 id="wsgiweb-server-gateway-interface">WSGI(Web Server Gateway Interface)</h3>
<ul>
  <li>파이썬 애플리케이션, 파이썬 스크립트가 웹서버와 통신하기 위한 인터페이스입니다.</li>
  <li>wsgi는 서버와 게이트웨이, 애플리케이션과 프레임워크 양단으로 니눠져있습니다. wsgi 요청을 처리하려면 서버단에서 <code class="language-plaintext highlighter-rouge">환경정보</code>와 <code class="language-plaintext highlighter-rouge">콜백함수</code>를 애플리케이션단에 제공해야합니다.</li>
  <li>역할
    <ul>
      <li>환경변수가 변하면 타겟 URL에 따라서 요청 경로를 지정해줍니다.</li>
      <li>같은 프로세스에서 여러 애플리케이션과 프레임워크가 실행됩니다.</li>
      <li>XSLT 스타일시트를 적용하는 것과 가이 전처리합니다.</li>
    </ul>
  </li>
  <li>wsgi는 보통 application(=app)이라는 이름의 파이썬 함수를 웹서버에 제공합니다. 해당 함수는 다음 두가지의 매개변수를 전달받습니다.
    <ul>
      <li>environ: 웹서버가 제공한 환경변수와 현재 요청에 대한 정보가 포함된 Dictionary</li>
      <li>start_response: 클라이언트로 HTTP 응답을 보내는 작업을 시작하는데 사용하는 함수
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">application</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
  <span class="nf">start_response</span><span class="p">(</span><span class="sh">'</span><span class="s">200 OK</span><span class="sh">'</span><span class="p">,</span> <span class="p">[(</span><span class="sh">'</span><span class="s">Content-Type</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">text/plain</span><span class="sh">'</span><span class="p">)])</span>
<span class="k">return</span> <span class="p">[</span><span class="sa">b</span><span class="sh">'</span><span class="s">Greetings universe</span><span class="sh">'</span><span class="p">]</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>방식: 요청 -&gt; 웹서버 -&gt; wsgi server (=middleware) -&gt; Djnago, Flask..</li>
  <li>단점
    <ul>
      <li>한 번에 하나의 요청과 응답만 처리하며, 응답이 즉시 반환된다고 전제합니다. 따라서, 롱폴링 HTTP 연결과 같은 장시간 연결을 처리할 수 없습니다.</li>
      <li>동기 전용으로, 멀티스레드 연결풀을 사용하더라도 응답이 반환될 때까지 각 연결이 차단됩니다.</li>
    </ul>
  </li>
</ul>

<h3 id="asgi">ASGI</h3>
<ul>
  <li>WSGI와 마찬가지로 파이썬 웹애플리케이션과 웹서버 사이에서 통신하기 위한 인터페이스입니다.</li>
  <li>WSGI와의 차이점은 애플리케이션당 여러 개의 비동기 이벤트를 허용한다는 것이며, 동기앱과 비동기앱 모두를 지원합니다.</li>
  <li>asgi를 사용해 새로운 비동기 웹앱을 구축하는 것뿐만 아니라 오래된 동기 wsgi 웹 앱을 asgi로 마이그레이션할 수도 있습니다.</li>
  <li>wsgi와 다르게 3개의 매개변수를 application에 전달합니다.
    <ul>
      <li>scope: 현재 요청에 대한 정보가 포함된 Dictionary (wsgi의 environ과 세부 명명규칙이 다름)</li>
      <li>send: 애플리케이션이 클라이언트로 메시지를 돌려보낼 수 이쏘록 해주는 async callable</li>
      <li>recieve: 애플리케이션이 클라이언트로부터 메시지를 수신할 수 있도록 해주는 async collable
```python
async def application(scope, receive, send):
await send({
  ‘type’: ‘http.response.start’,
  ‘status’: 200,
  ‘headers’: [
      [b’content-type’, b’text/plain’],
  ],
})</li>
    </ul>

    <p>await send({
    ‘type’: ‘http.response.body’,
    ‘body’: b’Hello, world!’,
})
```</p>
    <ul>
      <li>asgi의 가장 큰 특징은 함수 전반에서 비동기 메타포를 사용한다는 것입니다.</li>
      <li>함수 자체는 async이며 HTTP 헤더와 응답 본문을 별도의 두가지 await send() 명령으로 보냅니다. 따라서, 많은 연결의 application 및 send 호출과 동시에 교차가 가능합니다.</li>
      <li>receive 역시 async 함수로, 다른 작업을 차단하지 않고도 요청 본문을 받을 수 있습니다.</li>
    </ul>
  </li>
</ul>

<h3 id="asgi에서-동기-및-비동기-함수-사용하기">ASGI에서 동기 및 비동기 함수 사용하기</h3>
<ul>
  <li>동기 전용 함수에 대한 장기 실행 호출은 전체 호출 체인을 차단하기 때문에, 비동기 사용의 장점이 사라집니다.</li>
  <li>따라서, 장기 실행 동기 호출을 쓸 수 밖에 없는 상황이라면, asyncio.run_in_executor를 사용해 스레드 또는 프로세스 풀에 대한 호출을 맡깁니다.</li>
  <li>예를 들어, Pillow 이미지 라이브러리를 사용하는 경우, run_in_executor를 프로세스 풀과 함께 사용해야합니다.</li>
  <li>프로세스 간에 데이터를 주고받는 오버헤드가 있지만, run_in_executor는 다른 이벤트를 차단하지 않습니다.</li>
</ul>

<h3 id="wsgi-cgi-방식의-차이점">WSGI, CGI 방식의 차이점</h3>
<ul>
  <li>CGI 서브프로세스는 소켓과 stdout을 포함하여 OS 환경을 상속합니다.</li>
  <li>CGI 서브프로세스가 response를 작성하고, 이를 웹서브로 응답하면 웹서브는 해당 응답을 브라우저로 전송합니다.</li>
  <li>대부분의 CGI는 모든 요청마다 서브프로세스를 fork하게 됩니다.</li>
</ul>

<p>WSGI는 CGI 디자인 패턴에 기반한 인터페이스입니다.</p>
<ul>
  <li>WSGI는 모든 요청에 대해 서브프로세스를 fork하지 않습니다.</li>
  <li>HTTP 요청 헤더를 파싱하여 이를 환경에 추가합니다.</li>
  <li>file-like object로써 POST oriented input을 제공합니다.</li>
  <li>사용자로 하여금 수많은 format 디테일로부터 해방시키고 response를 만들 수 있는 기능을 제공합니다.</li>
</ul>]]></content><author><name>Yeham Kim</name></author><category term="Django Strategy" /><summary type="html"><![CDATA[각 용어의 정의 웹서버 인터넷을 통해서 요청된 웹 컨텐츠의 전달을 도와주는 하드웨어와 소프트웨어입니다. 웹서버는 기본적으로 ‘정적’인 파일을 전달합니다. 클라이언트가 HTTP 요청을 통해 리소스를 요청하면, 리소스를 그대로 보내줍니다.]]></summary></entry></feed>