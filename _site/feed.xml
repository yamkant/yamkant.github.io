<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-10-17T16:25:27+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Yam’s Dev Logs</title><subtitle>An amazing website.</subtitle><author><name>Yeham Kim</name></author><entry><title type="html">[Study] Database - 쿼리 최적화를 위한 인덱스</title><link href="http://localhost:4000/study/study-db-index/" rel="alternate" type="text/html" title="[Study] Database - 쿼리 최적화를 위한 인덱스" /><published>2023-10-17T00:05:07+09:00</published><updated>2023-10-17T00:05:07+09:00</updated><id>http://localhost:4000/study/study-db-index</id><content type="html" xml:base="http://localhost:4000/study/study-db-index/"><![CDATA[<h3 id="인덱스란-무엇인가">인덱스란 무엇인가?</h3>
<ul>
  <li>인덱스를 사용하는 이유: 조건(<code class="language-plaintext highlighter-rouge">WHERE</code>)을 만족하는 튜플들을 빠르게 조회하기 위해 사용합니다.</li>
  <li>빠르게 <code class="language-plaintext highlighter-rouge">ORDER BY</code>하거나 <code class="language-plaintext highlighter-rouge">GROUP BY</code>하기 위해 사용합니다.</li>
</ul>

<h2 id="인덱스-사용방법">인덱스 사용방법</h2>

<h3 id="인덱스-관련-명령어-예시">인덱스 관련 명령어 예시</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- name column을 기준으로 인덱스를 생성합니다.</span>
<span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">player_name_idx</span> <span class="k">ON</span> <span class="n">player</span> <span class="p">(</span><span class="n">name</span><span class="p">);</span>

<span class="c1">-- team_id와 backnumber에 대해 복합 인덱스를 생성합니다.</span>
<span class="k">CREATE</span> <span class="k">UNIQUE</span> <span class="k">INDEX</span> <span class="n">item_id_backnumber_idx</span> <span class="k">ON</span> <span class="n">player</span> <span class="p">(</span><span class="n">team_id</span><span class="p">,</span> <span class="n">backnumber</span><span class="p">);</span>

<span class="c1">-- 테이블 생성시 인덱스 설정을 포함합니다.</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">player</span> <span class="p">(</span>
  <span class="n">id</span>  <span class="nb">INT</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
  <span class="n">name</span>  <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">team_id</span> <span class="nb">INT</span><span class="p">,</span>
  <span class="n">backnumber</span> <span class="nb">INT</span><span class="p">,</span>
  <span class="k">INDEX</span> <span class="n">player_name_idx</span> <span class="p">(</span><span class="n">name</span><span class="p">),</span>
  <span class="k">UNIQUE</span> <span class="k">INDEX</span> <span class="n">team_id_backnumber_idx</span> <span class="p">(</span><span class="n">team_id</span><span class="p">,</span> <span class="n">backnumber</span><span class="p">)</span>
<span class="p">);</span>

<span class="c1">-- 해당 테이블에 대한 인덱스 정보를 알고 싶은 경우에 사용합니다.</span>
<span class="k">SHOW</span> <span class="k">INDEX</span> <span class="k">FROM</span> <span class="n">player</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="인덱스의-동작-방식">인덱스의 동작 방식</h3>
<ul>
  <li>기존 방식대로라면 원본테이블에서 원하는 조건들을 만족하는 경우에 대해 풀스캔 해야하지만, 인덱스를 사용하면 다음과 같이 동작합니다.</li>
  <li>인덱스 테이블은 인덱스 생성시 설정한 <code class="language-plaintext highlighter-rouge">INDEX(a)</code> 값에 해당하는 포인터가 원본 테이블의 a 컬럼의 값의 튜플을 가리키는 방식입니다.</li>
  <li>a에 대한 조건이 입력될 때 인덱스 테이블에서 이에 해당하는 값을 Binary Search 형태로 검색하고, 해당 조건에 대한 인덱스 검색이 완료되면 포인터가 가리키는 원본 테이블의 튜플을 찾게 됩니다.</li>
  <li><code class="language-plaintext highlighter-rouge">WHERE a=7</code>이라는 조건으로 검색된다면, 인덱스 테이블에서 <code class="language-plaintext highlighter-rouge">a=7</code>인 값을 Binary Search로 검색하고, 해당 포인터가 가리키는 원본 테이블의 값을 불러오는 방식입니다.</li>
</ul>

<h3 id="복합-인덱스를-사용하는-이유">복합 인덱스를 사용하는 이유</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">WHERE a=7 AND b=95</code>와 같은 조건으로 검색되고 인덱스 테이블에 <code class="language-plaintext highlighter-rouge">a=7</code>을 만족하는 값이 많다면, 모든 <code class="language-plaintext highlighter-rouge">a=7</code>에 대한 포인터를 통해 원본 테이블에 찾아가서 <code class="language-plaintext highlighter-rouge">b=95</code>라는 값을 일일이 확인해야합니다.</li>
  <li>인덱스 테이블에서 해당 조건을 재빠르게 먼저 찾아서 원본테이블을 참조하는 횟수를 줄이기 위해 복합인덱스를 구성할 수 있습니다. <code class="language-plaintext highlighter-rouge">CREATE INDEX(a,b)</code>: a 컬럼이 먼저 정렬되고, 이후 b 컬럼이 정렬됩니다.</li>
  <li>따라서, <code class="language-plaintext highlighter-rouge">WHERE a=7 AND b=95</code> 조건에 대해 인덱스 테이블의 튜플을 검색하고 원본 테이블에 참조하게 됩니다.</li>
  <li>하지만, 복합 인덱스만 위와 같이 설정하고 <code class="language-plaintext highlighter-rouge">WHERE b=95</code>에 대해서만 검색한다면, 결국 복합인덱스를 사용하지 않고, 원본 테이블을 풀스캔하기 때문에 조건절에 따라 인덱스를 생성하는 것이 매우 중요합니다.</li>
</ul>

<h3 id="covering-index">Covering index</h3>
<ul>
  <li>인덱스 테이블에서 조회하는 조건에 대한 모든 값을 가지고 있는 경우로, 조회 속도가 빠르다는 장점이 있기 때문에 의도적으로 사용하곤 합니다.</li>
  <li>예를 들어, <code class="language-plaintext highlighter-rouge">CREATE UNIQUE INDEX item_id_backnumber_idx ON player (team_id, backnumber)</code>로 설정을 하고, <code class="language-plaintext highlighter-rouge">SELECT * team_id, backnumber FROM players WHERE team_id = 5</code>와 같이 검색하는 경우입니다.</li>
</ul>

<h3 id="hash-index">Hash index</h3>
<ul>
  <li>hash table을 사용하여 인덱스를 구현하는 방식으로, 시간복잡도가 O(1)로 매우 빠릅니다.</li>
  <li>해시 테이블이 매우 커지면서 발생하는 rehashing 문제에 대한 부담이 있고, 값의 equality 비교만 가능하여 range 비교는 불가능하다는 단점이 있습니다.</li>
  <li>복합 인덱스 설정시 <code class="language-plaintext highlighter-rouge">INDEX (a,b)</code>로 설정할 경우 (a,b)를 동시 조건으로 처리하는 경우에만 이용할 수 있습니다. (기존 방식은 첫번쨰 인덱스인 <code class="language-plaintext highlighter-rouge">a</code>만 사용해도 인덱 동작 가능)</li>
</ul>

<h3 id="인덱스-지정하는-방법">인덱스 지정하는 방법</h3>
<ul>
  <li>기본적으로 DBMS의 optimizer가 인덱스를 스스로 반영하여 조회에 사용하지만, 사용자가 이를 커스터마이징 하여 원하는 인덱스를 사용하도록 설정할 수 있습니다.</li>
  <li>확인 방법: <code class="language-plaintext highlighter-rouge">EXPLAIN SELECT 스* FROM player WHERE backnumber=7;</code> 어떤 key를 이용하여 인덱스 참조했는지 분석할 수 있습니다.</li>
  <li>제안 설정: <code class="language-plaintext highlighter-rouge">SELECT * FROM player USE INDEX (player_name_idx) WHERE name="sonny";</code></li>
  <li>강제 설정: <code class="language-plaintext highlighter-rouge">SELECT * FROM player FORCE INDEX (player_name_idx) WHERE name="sonny";</code></li>
  <li>제외 설정: <code class="language-plaintext highlighter-rouge">SELECT * FROM player IGNORE INDEX (player_name_idx) WHERE name="sonny";</code></li>
</ul>

<h2 id="고려사항">고려사항</h2>
<ul>
  <li>인덱스를 많이 만든다는 것은 인덱스 테이블을 많이 만든다는 의미와 같습니다. 따라서, 추가 저장 공간이 발생하게 됩니다.</li>
  <li>또한, table을 수정하거나 변경할 때마다 영향을 받는 인덱스에 함께 적용되기 때문에 불필요한 인덱스를 많이 만들면 이에 대한 수정 시간도 변경되게 됩니다.</li>
</ul>

<h3 id="추가-공부">추가 공부</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">ORDER BY</code>나 <code class="language-plaintext highlighter-rouge">GROUP BY</code>에 index를 사용하는 경우</li>
  <li>이미 데이터가 매우 큰 경우에 인덱스를 추가하는 작업을 한다면 오랜 시간이 소모되어 DB 성능을 악화시킬 수 있습니다.</li>
</ul>

<h3 id="참고-자료">참고 자료</h3>
<ul>
  <li><a href="https://youtu.be/IMDH4iAQ6zM?si=U2NoBBtyJD5BQSGG">쉬운코드님 유튜브 영상</a></li>
</ul>]]></content><author><name>Yeham Kim</name></author><category term="Study" /><summary type="html"><![CDATA[인덱스란 무엇인가? 인덱스를 사용하는 이유: 조건(WHERE)을 만족하는 튜플들을 빠르게 조회하기 위해 사용합니다. 빠르게 ORDER BY하거나 GROUP BY하기 위해 사용합니다.]]></summary></entry><entry><title type="html">[Study] elastic search 사용하기</title><link href="http://localhost:4000/study/elastic-search/" rel="alternate" type="text/html" title="[Study] elastic search 사용하기" /><published>2023-10-12T00:05:07+09:00</published><updated>2023-10-12T00:05:07+09:00</updated><id>http://localhost:4000/study/elastic-search</id><content type="html" xml:base="http://localhost:4000/study/elastic-search/"><![CDATA[<h2 id="설치-및-간단한-설정">설치 및 간단한 설정</h2>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker pull docker.elastic.co/elasticsearch/elasticsearch:8.7.0
<span class="nv">$ </span>docker run <span class="nt">-p</span> 9200:9200 <span class="nt">-p</span> 9300:9300 <span class="se">\</span>
  <span class="nt">--name</span> my-elasticsearch <span class="se">\</span>
  <span class="nt">-e</span> <span class="s2">"discovery.type=single-node"</span> <span class="se">\</span>
  docker.elastic.co/elasticsearch/elasticsearch:8.7.0
</code></pre></div></div>
<ul>
  <li>9200 포트를 통해 엘라스틱 서치에 접속할 수 있도록, 9300 포트를 통해 내부에서 통신하도록 설정합니다.</li>
  <li>단일 노드로 실행하기 위해 <code class="language-plaintext highlighter-rouge">discovery.type=signle-node</code> 옵션을 추가합니다.</li>
  <li>https://localhost:9200/으로 접속하면 로그인을 통해 접속 가능합니다.</li>
</ul>

<h3 id="elastic-search-로그인을-위한-비밀번호-변경">elastic search 로그인을 위한 비밀번호 변경</h3>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> my-elasticsearch /bin/bash
<span class="nv">$ </span>elasticsearch@...:~<span class="nv">$ </span>bin/elasticsearch-setup-passwords interactive
</code></pre></div></div>
<ul>
  <li>docker 컨테이너 내부에 접속하여 계정 관련 정보를 수정할 수 있습니다.</li>
</ul>

<h2 id="엘라스틱서치-데이터-삽입조회수정삭제">엘라스틱서치 데이터 삽입/조회/수정/삭제</h2>
<h4 id="삽입">삽입</h4>
<ul>
  <li>방식: <code class="language-plaintext highlighter-rouge">PUT &lt;인덱스&gt;/_doc/&lt;도큐먼트번호&gt;</code></li>
  <li>예시
    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>curl  <span class="nt">-k</span> <span class="nt">-u</span> <span class="s2">"elastic:elastic"</span> <span class="se">\</span>
  <span class="nt">-H</span> <span class="s2">"Content-Type: application/json"</span> <span class="se">\</span>
  <span class="nt">-d</span> <span class="s1">'{ "id" : "1", "message" : "1번 데이터 입니다." }'</span> <span class="se">\</span>
  <span class="nt">-X</span> PUT https://localhost:9200/ksb/_doc/1
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="조회">조회</h4>
<ul>
  <li>방식: <code class="language-plaintext highlighter-rouge">GET &lt;인덱스&gt;/_doc/&lt;도큐먼트번호&gt;</code></li>
  <li>예시:
    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>curl  <span class="nt">-k</span> <span class="nt">-u</span> <span class="s2">"elastic:elastic"</span> <span class="se">\</span>
  <span class="nt">-H</span> <span class="s2">"Content-Type: application/json"</span> <span class="se">\</span>
  <span class="nt">-X</span> GET https://localhost:9200/ksb/_doc/1
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="수정">수정</h4>
<ul>
  <li>방식: <code class="language-plaintext highlighter-rouge">POST &lt;인덱스&gt;/_update/&lt;도큐먼트번호&gt;</code></li>
  <li>예시:
    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>curl  <span class="nt">-k</span> <span class="nt">-u</span> <span class="s2">"elastic:elastic"</span> <span class="se">\</span>
  <span class="nt">-H</span> <span class="s2">"Content-Type: application/json"</span> <span class="se">\</span>
  <span class="nt">-d</span> <span class="s1">'{ "doc": { "message": "0번 데이터 입니다." } }'</span> <span class="se">\</span>
  <span class="nt">-X</span> POST https://localhost:9200/ksb/_doc/1
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="삭제">삭제</h4>
<ul>
  <li>방식: <code class="language-plaintext highlighter-rouge">DELETE &lt;인덱스&gt;/_doc/&lt;도큐먼트번호&gt;</code></li>
  <li>예시:
    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>curl  <span class="nt">-k</span> <span class="nt">-u</span> <span class="s2">"elastic:elastic"</span> <span class="se">\</span>
  <span class="nt">-H</span> <span class="s2">"Content-Type: application/json"</span> <span class="se">\</span>
  <span class="nt">-X</span> DELETE https://localhost:9200/ksb/_doc/1
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="_bulk-api">_bulk API</h4>
<ul>
  <li>방식: <code class="language-plaintext highlighter-rouge">POST _bulk</code></li>
  <li>얘시:
    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">echo</span> <span class="s1">'
  { "index" : { "_index" : "ksb", "_id" : "1" } }
  { "field1" : "value1" }
  { "delete" : { "_index" : "ksb", "_id" : "2" } }
  { "create" : { "_index" : "ksb", "_id" : "3" } }
  { "field1" : "value3" }
  { "update" : {"_id" : "1", "_index" : "ksb"} }
  { "doc" : {"field2" : "value2"} }

  '</span> <span class="o">&gt;</span> query.json
<span class="nv">$ </span>curl  <span class="nt">-k</span> <span class="nt">-u</span> <span class="s2">"elastic:elastic"</span> <span class="se">\</span>
  <span class="nt">-H</span> <span class="s2">"Content-Type: application/json"</span> <span class="se">\</span>
  <span class="nt">-X</span> POST https://localhost:9200/_bulk <span class="se">\</span>
  <span class="nt">--data-binary</span> @query.json
</code></pre></div>    </div>
  </li>
</ul>]]></content><author><name>Yeham Kim</name></author><category term="Study" /><summary type="html"><![CDATA[설치 및 간단한 설정 $ docker pull docker.elastic.co/elasticsearch/elasticsearch:8.7.0 $ docker run -p 9200:9200 -p 9300:9300 \ --name my-elasticsearch \ -e "discovery.type=single-node" \ docker.elastic.co/elasticsearch/elasticsearch:8.7.0 9200 포트를 통해 엘라스틱 서치에 접속할 수 있도록, 9300 포트를 통해 내부에서 통신하도록 설정합니다. 단일 노드로 실행하기 위해 discovery.type=signle-node 옵션을 추가합니다. https://localhost:9200/으로 접속하면 로그인을 통해 접속 가능합니다.]]></summary></entry><entry><title type="html">[Django] Push 알람은 어떤식으로 구현할 수 있을까?</title><link href="http://localhost:4000/strategy/django-strategy-push-notification/" rel="alternate" type="text/html" title="[Django] Push 알람은 어떤식으로 구현할 수 있을까?" /><published>2023-09-24T00:05:07+09:00</published><updated>2023-09-24T00:05:07+09:00</updated><id>http://localhost:4000/strategy/django-strategy-push-notification</id><content type="html" xml:base="http://localhost:4000/strategy/django-strategy-push-notification/"><![CDATA[<h2 id="글을-작성하게-된-계기">글을 작성하게 된 계기</h2>
<ul>
  <li>진행하던 사이드 프로젝트에서, 이미지를 업로드 시킬 때, 이미지에 따라 처리 시간이 오래 걸리는 현상이 있었습니다.</li>
  <li>이미지 업로드 진행 중에도, 유저들이 사용하는데 지장이 없도록 Celery를 활용한 비동기처리는 되어있는 상태였습니다.</li>
  <li>하지만, Celery 작업을 마친 후, wsgi 서비스에서 클라이언트에게 알람을 전달하도록 하는 것이 효율적일 것이라고 생각하게 되어서 푸시알람 구현을 고민해보게 되었습니다.</li>
  <li>이를 위해, 클라이언트 단에서 EventSource를 사용했고, 이를 가능하게 하는 Django 모듈인 <code class="language-plaintext highlighter-rouge">django-eventstream</code>을 이용했습니다.</li>
</ul>

<h3 id="동작-순서">동작 순서</h3>
<ol>
  <li>[wsgi] wsgi에서 API request 전달 받습니다.</li>
  <li>[asgi] celery에서 특정 작업에 대한 동작을 처리하도록 합니다.</li>
  <li>[asgi] celery에서 특정 작업에 대한 동작을 처리 후, task result 테이블에 해당 내역을 기록합니다.<br />
(이 때, event stream에서 클라이언트에게 전달하기 위한 <code class="language-plaintext highlighter-rouge">채널명(ex. user.username)</code>을 함께 기록합니다.)</li>
  <li>[asgi] task result DB를 모니터링 하다가, record가 추가되거나 수정되는 등의 signal이 발생하면 wsgi 서버로 request 요청합니다. 이때, task 관련 정보를 전달합니다. <br />
(ex. <code class="language-plaintext highlighter-rouge">requests.get("http://127.0.0.1:8000/tasks/&lt;task_id&gt;/")</code> <code class="language-plaintext highlighter-rouge">task_id</code>는 wsgi에서 파싱)</li>
  <li>[wsgi] asgi의 request 내에 기록된 task 정보(task_id)를 통해 DB에서 어떤 태스크가 완료되었는지 판단합니다.</li>
  <li>[wsgi] task result DB에 기록할 때, 추가 입력한 <code class="language-plaintext highlighter-rouge">user.username(채널명)</code>를 통해 event stream으로 클라이언트에게 작업이 완료되었음을 알립니다.</li>
</ol>

<h2 id="튜토리얼-구현">튜토리얼 구현</h2>
<h3 id="작동-방식">작동 방식</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">/</code> 페이지에 접속하면 버튼이 있습니다. 버튼을 클릭하면, celery task로 지정한 5초를 카운트하는 태스크를 실행시킵니다.</li>
  <li>5초 타이머가 celery task에서 작동하고, task가 정상적으로 마칠 때, celery result 테이블에 태스크 관련 내용을 기록합니다.</li>
  <li>asgi 서버에서 시그널을 통해 result 테이블을 모니터링하다가, 태스크를 마치면 Django eventstream이 클라이언트에게 메시지를 보냅니다.</li>
  <li>클라이언트측에서 버튼을 누른 이후 5초가 지난 후, alert 창을 띄웁니다.</li>
</ul>

<h3 id="들어가기-전">들어가기 전</h3>
<ul>
  <li>작업환경 설정 부분은 공식 홈페이지의 방식을 따랐습니다.
    <ul>
      <li><a href="https://docs.djangoproject.com/en/4.2/topics/signals/">django signal 관련 설정</a></li>
      <li><a href="https://docs.celeryq.dev/en/stable/django/first-steps-with-django.html">django-celery 관련 설정</a></li>
    </ul>
  </li>
  <li>구체적인 설정 예시는 부록에 남기겠습니다.</li>
</ul>

<h3 id="wsgi-task-동작-요청">[wsgi] task 동작 요청</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># config.urls.py
</span>
<span class="k">class</span> <span class="nc">TaskCreateAPIView</span><span class="p">(</span><span class="n">APIView</span><span class="p">):</span>
    <span class="n">queryset</span> <span class="o">=</span> <span class="n">TaskResult</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nf">all</span><span class="p">()</span>
    <span class="n">lookup_field</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">id</span><span class="sh">'</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">post</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">channel_name</span> <span class="o">=</span> <span class="sh">'</span><span class="s">yamkant</span><span class="sh">'</span>
        <span class="n">task_sleep</span><span class="p">.</span><span class="nf">delay</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">channel_name</span><span class="o">=</span><span class="n">channel_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="nc">Response</span><span class="p">({})</span>

<span class="n">urlpatterns</span> <span class="o">=</span> <span class="p">[</span>
    <span class="bp">...</span>
    <span class="nf">path</span><span class="p">(</span><span class="sh">"</span><span class="s">tasks/</span><span class="sh">"</span><span class="p">,</span> <span class="n">TaskCreateAPIView</span><span class="p">.</span><span class="nf">as_view</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="sh">"</span><span class="s">task-create</span><span class="sh">"</span><span class="p">),</span>
    <span class="bp">...</span>
<span class="p">]</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">/tasks/</code>로 POST 요청을 보내는 경우 task가 실행됩니다.</li>
  <li>이 때, 앞서 강조한 바와 같이 channel 이름을 함께 대입하여, 태스크 종료 후 알람을 줄 채널을 지정합니다.</li>
</ul>

<h3 id="asgi-task-수행-및-결과-저장">[asgi] task 수행 및 결과 저장</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@shared_task</span><span class="p">(</span>
    <span class="n">bind</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
    <span class="n">max_retries</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">ignore_result</span><span class="o">=</span><span class="bp">True</span>
<span class="p">)</span>
<span class="k">def</span> <span class="nf">task_sleep</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="kn">from</span> <span class="n">time</span> <span class="kn">import</span> <span class="n">sleep</span>
    <span class="nf">sleep</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="n">task_result</span> <span class="o">=</span> <span class="n">TaskResult</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span>
        <span class="n">task_id</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="nb">id</span><span class="p">,</span>
        <span class="n">status</span><span class="o">=</span><span class="n">states</span><span class="p">.</span><span class="n">SUCCESS</span><span class="p">,</span>
        <span class="n">meta</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="sh">'</span><span class="s">channel_name</span><span class="sh">'</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">task_sleep</code>을 wsgi 서버에서 호출할 때, 인자로 데이터와 <code class="language-plaintext highlighter-rouge">channel_name</code>을 함께 대입하고 이를 메타데이터에 저장합니다.</li>
  <li>이후, 태스크에 따라 발생시키고자 하는 알람을 구분하여 <code class="language-plaintext highlighter-rouge">send_event</code> 해주기 위한 채널명으로 사용됩니다.</li>
  <li>해당 태스크를 실행시킬 때, TaskResult 모델(django-celery-results 모듈에서 생성한 테이블)을 통해 <code class="language-plaintext highlighter-rouge">django_celery_results_taskresult</code>테이블에 레코드를 기록합니다.</li>
</ul>

<h3 id="asgi-task-종료-후-시그널-캐치">[asgi] task 종료 후 시그널 캐치</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">apps</span><span class="p">.</span><span class="n">mycelery</span><span class="p">.</span><span class="n">signals</span><span class="p">.</span><span class="n">py</span>

<span class="nd">@receiver</span><span class="p">(</span><span class="n">post_save</span><span class="p">,</span> <span class="n">sender</span><span class="o">=</span><span class="n">TaskResult</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">process_celery_task_result</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">instance</span><span class="p">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">states</span><span class="p">.</span><span class="n">SUCCESS</span><span class="p">:</span>
        <span class="n">requests</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">http://127.0.0.1:8000/tasks/</span><span class="si">{</span><span class="n">instance</span><span class="p">.</span><span class="nb">id</span><span class="si">}</span><span class="s">/</span><span class="sh">'</span><span class="p">)</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">task_sleep</code>이 마무리 되면, post_save 이벤트를 통해 signal 발생을 감지합니다.</li>
  <li>이 때, 인자로 <code class="language-plaintext highlighter-rouge">TaskResult</code> 모델의 인스턴스가 바로 들어오므로 이를 사용하여 wsgi 서버에 마무리된 태스크를 전달해줍니다.</li>
</ul>

<h3 id="asgi-태스크-호출-클라이언트에-태스크-종료-상황-전달">[asgi] 태스크 호출 클라이언트에 태스크 종료 상황 전달</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># config.urls.py
</span>
<span class="k">class</span> <span class="nc">TaskRetrieveAPIView</span><span class="p">(</span><span class="n">RetrieveAPIView</span><span class="p">):</span>
    <span class="n">queryset</span> <span class="o">=</span> <span class="n">TaskResult</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nf">all</span><span class="p">()</span>
    <span class="n">lookup_field</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">id</span><span class="sh">'</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">retrieve</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="nf">get_object_or_404</span><span class="p">(</span><span class="n">TaskResult</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="sh">'</span><span class="s">id</span><span class="sh">'</span><span class="p">])</span>
        <span class="n">channel_name</span> <span class="o">=</span> <span class="n">instance</span><span class="p">.</span><span class="n">meta</span>
        <span class="nf">send_event</span><span class="p">(</span><span class="n">channel_name</span><span class="p">,</span> <span class="sh">'</span><span class="s">message</span><span class="sh">'</span><span class="p">,</span> <span class="p">{</span><span class="sh">"</span><span class="s">msg</span><span class="sh">"</span><span class="p">:</span> <span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">instance</span><span class="p">.</span><span class="n">task_id</span><span class="si">}</span><span class="s"> Task Finished</span><span class="sh">"</span><span class="p">})</span>
        <span class="k">return</span> <span class="nc">Response</span><span class="p">({})</span>

<span class="n">urlpatterns</span> <span class="o">=</span> <span class="p">[</span>
    <span class="bp">...</span>
    <span class="nf">path</span><span class="p">(</span><span class="sh">"</span><span class="s">tasks/&lt;int:id&gt;/</span><span class="sh">"</span><span class="p">,</span> <span class="n">TaskRetrieveAPIView</span><span class="p">.</span><span class="nf">as_view</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="sh">"</span><span class="s">task-detail</span><span class="sh">"</span><span class="p">),</span>
    <span class="bp">...</span>
<span class="p">]</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">task</code>의 id를 asgi 서버에서 wsgi 서버로 전달하였고, wsgi는 이를 캐치하여 태스크 결과를 DB에서 확인 후 <code class="language-plaintext highlighter-rouge">send_event</code>를 통해 저장된 채널로 알람을 줍니다.</li>
  <li>현재는 string으로 반환하여 task 종료에 대한 내역만 표시했지만, case에 따라서 client가 다른 처리를 하도록 작성할 수 있습니다.</li>
</ul>

<h2 id="부록">부록</h2>
<h3 id="celery-관련-설정">celery 관련 설정</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1"># config.__init__.py
</span>  <span class="kn">from</span> <span class="n">.celery</span> <span class="kn">import</span> <span class="n">app</span> <span class="k">as</span> <span class="n">celery_app</span>

  <span class="n">__all__</span> <span class="o">=</span> <span class="p">(</span><span class="sh">'</span><span class="s">celery_app</span><span class="sh">'</span><span class="p">,)</span>
</code></pre></div></div>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1"># config.settings.py
</span>  <span class="c1"># CELERY SETTINGS
</span>  <span class="n">CELERY_BROKER_URL</span> <span class="o">=</span> <span class="sh">'</span><span class="s">redis://127.0.0.1:6379</span><span class="sh">'</span>
  <span class="n">CELERY_RESULT_BACKEND</span> <span class="o">=</span> <span class="sh">'</span><span class="s">django-db</span><span class="sh">'</span>
  <span class="n">CELERY_CACHE_BACKEND</span> <span class="o">=</span> <span class="sh">'</span><span class="s">defualt</span><span class="sh">'</span>

  <span class="n">CELERY_APP</span><span class="o">=</span><span class="sh">'</span><span class="s">config.celery</span><span class="sh">'</span>
</code></pre></div></div>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1"># config.celery.py
</span>
  <span class="kn">from</span> <span class="n">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span>
  <span class="kn">import</span> <span class="n">os</span>
  <span class="kn">from</span> <span class="n">celery</span> <span class="kn">import</span> <span class="n">Celery</span>

  <span class="n">os</span><span class="p">.</span><span class="n">environ</span><span class="p">.</span><span class="nf">setdefault</span><span class="p">(</span><span class="sh">'</span><span class="s">DJANGO_SETTINGS_MODULE</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">config.settings</span><span class="sh">'</span><span class="p">)</span>

  <span class="n">app</span> <span class="o">=</span> <span class="nc">Celery</span><span class="p">(</span>
      <span class="sh">'</span><span class="s">config</span><span class="sh">'</span><span class="p">,</span>
      <span class="n">broker_connection_retry_on_startup</span><span class="o">=</span><span class="bp">True</span>
  <span class="p">)</span>
  <span class="n">app</span><span class="p">.</span><span class="nf">config_from_object</span><span class="p">(</span><span class="sh">'</span><span class="s">django.conf:settings</span><span class="sh">'</span><span class="p">,</span> <span class="n">namespace</span><span class="o">=</span><span class="sh">'</span><span class="s">CELERY</span><span class="sh">'</span><span class="p">)</span>

  <span class="n">app</span><span class="p">.</span><span class="nf">autodiscover_tasks</span><span class="p">()</span>

  <span class="n">app</span><span class="p">.</span><span class="n">conf</span><span class="p">.</span><span class="n">timezone</span> <span class="o">=</span> <span class="sh">"</span><span class="s">Asia/Seoul</span><span class="sh">"</span>
  <span class="n">app</span><span class="p">.</span><span class="n">conf</span><span class="p">.</span><span class="n">task_track_started</span> <span class="o">=</span> <span class="bp">True</span>
  <span class="n">app</span><span class="p">.</span><span class="n">conf</span><span class="p">.</span><span class="n">task_time_limit</span> <span class="o">=</span> <span class="mi">30</span> <span class="o">*</span> <span class="mi">60</span>
  <span class="n">app</span><span class="p">.</span><span class="n">conf</span><span class="p">.</span><span class="n">task_serializer</span> <span class="o">=</span> <span class="sh">'</span><span class="s">json</span><span class="sh">'</span>



  <span class="nd">@app.task</span><span class="p">(</span><span class="n">bind</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">ignore_result</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">debug_task</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">Request: </span><span class="si">{</span><span class="n">self</span><span class="p">.</span><span class="n">request</span><span class="si">!r}</span><span class="sh">'</span><span class="p">)</span>

</code></pre></div></div>

<h3 id="signal-관련-설정">signal 관련 설정</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># apps.mycelery.apps.py
</span>
<span class="kn">from</span> <span class="n">django.apps</span> <span class="kn">import</span> <span class="n">AppConfig</span>

<span class="k">class</span> <span class="nc">MyceleryConfig</span><span class="p">(</span><span class="n">AppConfig</span><span class="p">):</span>
    <span class="n">default_auto_field</span> <span class="o">=</span> <span class="sh">'</span><span class="s">django.db.models.BigAutoField</span><span class="sh">'</span>
    <span class="n">name</span> <span class="o">=</span> <span class="sh">'</span><span class="s">apps.mycelery</span><span class="sh">'</span>

    <span class="k">def</span> <span class="nf">ready</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="n">.</span> <span class="kn">import</span> <span class="n">signals</span>
</code></pre></div></div>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># apps.mycelery.signals.py
</span>
<span class="kn">from</span> <span class="n">django.db.models.signals</span> <span class="kn">import</span> <span class="n">post_save</span>
<span class="kn">from</span> <span class="n">django.dispatch</span> <span class="kn">import</span> <span class="n">receiver</span>
<span class="kn">from</span> <span class="n">django_celery_results.models</span> <span class="kn">import</span> <span class="n">TaskResult</span>
<span class="kn">from</span> <span class="n">celery</span> <span class="kn">import</span> <span class="n">states</span>

<span class="c1"># NOTE: Signal after celery work -&gt; to wsgi server 
</span><span class="nd">@receiver</span><span class="p">(</span><span class="n">post_save</span><span class="p">,</span> <span class="n">sender</span><span class="o">=</span><span class="n">TaskResult</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">process_celery_task_result</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">instance</span><span class="p">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">states</span><span class="p">.</span><span class="n">SUCCESS</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">SAVED CELERY RESULT</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="간단한-client-htmljs-작성">간단한 client html,js 작성</h3>
<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"en"</span><span class="nt">&gt;</span>
<span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"UTF-8"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">name=</span><span class="s">"viewport"</span> <span class="na">content=</span><span class="s">"width=device-width, initial-scale=1.0"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"static/django_eventstream/eventsource.min.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
    <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"/static/django_eventstream/reconnecting-eventsource.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
    <span class="nt">&lt;title&gt;</span>Push Alarm<span class="nt">&lt;/title&gt;</span>
<span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;h1&gt;</span>Hello World!<span class="nt">&lt;/h1&gt;</span>
    <span class="nt">&lt;button</span> <span class="na">onclick=</span><span class="s">"onClick(this)"</span><span class="nt">&gt;</span>Run Task!<span class="nt">&lt;/button&gt;</span>
    <span class="nt">&lt;script&gt;</span>
        <span class="k">async</span> <span class="kd">function</span> <span class="nf">start</span><span class="p">(</span><span class="nx">username</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">es</span> <span class="o">=</span> <span class="nf">setEventSource</span><span class="p">(</span><span class="nx">username</span><span class="p">)</span>
            <span class="nx">es</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">message</span><span class="dl">'</span><span class="p">,</span> <span class="nf">function </span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
                <span class="nf">alert</span><span class="p">(</span><span class="dl">"</span><span class="s2">Task Finished!</span><span class="dl">"</span><span class="p">)</span>
            <span class="p">},</span> <span class="kc">false</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="kd">function</span> <span class="nf">setEventSource</span><span class="p">(</span><span class="nx">channelName</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">es</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ReconnectingEventSource</span><span class="p">(</span><span class="s2">`/events/</span><span class="p">${</span><span class="nx">channelName</span><span class="p">}</span><span class="s2">/`</span><span class="p">);</span>
            <span class="k">return</span> <span class="nx">es</span>
        <span class="p">}</span>
        <span class="nb">window</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">load</span><span class="dl">'</span><span class="p">,</span> <span class="k">async </span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="nf">start</span><span class="p">(</span><span class="dl">""</span><span class="p">)</span>
        <span class="p">});</span>

        <span class="kd">const</span> <span class="nx">onClick</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="nf">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">http://127.0.0.1:8000/tasks/</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
                <span class="na">method</span><span class="p">:</span> <span class="dl">'</span><span class="s1">POST</span><span class="dl">'</span><span class="p">,</span>
                <span class="na">headers</span><span class="p">:</span> <span class="p">{</span>
                <span class="dl">'</span><span class="s1">Content-Type</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">application/x-www-form-urlencoded</span><span class="dl">'</span>
                <span class="p">},</span>
                <span class="na">body</span><span class="p">:</span> <span class="p">{},</span>
            <span class="p">})</span>
            <span class="p">.</span><span class="nf">then</span><span class="p">(</span><span class="nx">res</span> <span class="o">=&gt;</span> <span class="nx">res</span><span class="p">.</span><span class="nf">json</span><span class="p">())</span>
        <span class="p">}</span>
    <span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>
<ul>
  <li>load 직 후, event source를 설정하여, 서버와의 연결을 유지합니다.</li>
  <li>버튼 클릭시, post 요청을 통해 task를 실행시킵니다.</li>
</ul>

<h2 id="발생한-오류">발생한 오류</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>TypeError: __init__() missing 1 required positional argument: 'get_response'
HTTP GET /events/yamkant/ 500 [0.59, 127.0.0.1:55482]
</code></pre></div></div>
<ul>
  <li>module간 dependency 때문에 일어나는 현상입니다. 아래와 같이 모듈 버전을 맞춰주세요</li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Django</span><span class="o">==</span>4.2.5
django-celery-results<span class="o">==</span>2.5.1
django-eventstream<span class="o">==</span>4.5.1
django-grip<span class="o">==</span>3.4.0
<span class="nv">djangorestframework</span><span class="o">==</span>3.14.0

<span class="nv">celery</span><span class="o">==</span>5.3.4
<span class="nv">channels</span><span class="o">==</span>3.0.4
channels-redis<span class="o">==</span>4.1.0
</code></pre></div></div>]]></content><author><name>Yeham Kim</name></author><category term="Strategy" /><summary type="html"><![CDATA[글을 작성하게 된 계기 진행하던 사이드 프로젝트에서, 이미지를 업로드 시킬 때, 이미지에 따라 처리 시간이 오래 걸리는 현상이 있었습니다. 이미지 업로드 진행 중에도, 유저들이 사용하는데 지장이 없도록 Celery를 활용한 비동기처리는 되어있는 상태였습니다. 하지만, Celery 작업을 마친 후, wsgi 서비스에서 클라이언트에게 알람을 전달하도록 하는 것이 효율적일 것이라고 생각하게 되어서 푸시알람 구현을 고민해보게 되었습니다. 이를 위해, 클라이언트 단에서 EventSource를 사용했고, 이를 가능하게 하는 Django 모듈인 django-eventstream을 이용했습니다.]]></summary></entry><entry><title type="html">[Django] web server, was, cgi, wsgi, asgi</title><link href="http://localhost:4000/django%20strategy/django-cgi/" rel="alternate" type="text/html" title="[Django] web server, was, cgi, wsgi, asgi" /><published>2023-09-24T00:05:07+09:00</published><updated>2023-09-24T00:05:07+09:00</updated><id>http://localhost:4000/django%20strategy/django-cgi</id><content type="html" xml:base="http://localhost:4000/django%20strategy/django-cgi/"><![CDATA[<h2 id="각-용어의-정의">각 용어의 정의</h2>
<h3 id="웹서버">웹서버</h3>
<ul>
  <li>인터넷을 통해서 요청된 웹 컨텐츠의 전달을 도와주는 하드웨어와 소프트웨어입니다.</li>
  <li>웹서버는 기본적으로 ‘정적’인 파일을 전달합니다.</li>
  <li>클라이언트가 HTTP 요청을 통해 리소스를 요청하면, 리소스를 그대로 보내줍니다.</li>
</ul>

<h3 id="cgi-common-gateway-interface">CGI (Common Gateway Interface)</h3>
<ul>
  <li>웹서버에서 애플리케이션(프로그램, 스크립트)을 동작시키기 위한 인터페이스입니다.</li>
  <li>정적인 웹서버를 동적으로 기능하기 위해서 등장하였으며, 서버 프로그램과 외부 프로그램 간의 인터페이스가 CGI입니다.</li>
  <li>기존에는 클리아이언트에서 외부 프로그램이 필요한 요청이 오면 CGI를 통해 외부 프로그램을 실행시켜 요청에 응답하도록 했지만, 현재는 웹서버에 인터프리터를 내장하여 프로세스를 fork해서 외부 프로그램을 실행시키지 않고 내부에서 처리합니다.</li>
</ul>

<h3 id="was-web-application-server">WAS (Web Application Server)</h3>
<ul>
  <li>동적으로 기능을 하는 웹서버로, Web Server + CGI입니다.</li>
  <li>접속자가 많은 경우 CGI 방식보다 애플리케이션 서버 방식의 처리량(Throughput)이 더 좋습니다.</li>
  <li>만약, 5개의 웹 브라우저가 동일한 프로그램을 요청했을 때 CGI는 5개의 요청에 대한 프로그램을 모두 메모리에 적재합니다.</li>
  <li>애플리케이션 서버 방식은 메모리에 한번만 적재하여 CGI 방식에 비해 전체적인 메모리 사용량이 적으며, 이는 더 많은 요청을 처리할 수 있음을 의미합니다.</li>
</ul>

<h3 id="wsgiweb-server-gateway-interface">WSGI(Web Server Gateway Interface)</h3>
<ul>
  <li>파이썬 애플리케이션, 파이썬 스크립트가 웹서버와 통신하기 위한 인터페이스입니다.</li>
  <li>wsgi는 서버와 게이트웨이, 애플리케이션과 프레임워크 양단으로 니눠져있습니다. wsgi 요청을 처리하려면 서버단에서 <code class="language-plaintext highlighter-rouge">환경정보</code>와 <code class="language-plaintext highlighter-rouge">콜백함수</code>를 애플리케이션단에 제공해야합니다.</li>
  <li>역할
    <ul>
      <li>환경변수가 변하면 타겟 URL에 따라서 요청 경로를 지정해줍니다.</li>
      <li>같은 프로세스에서 여러 애플리케이션과 프레임워크가 실행됩니다.</li>
      <li>XSLT 스타일시트를 적용하는 것과 가이 전처리합니다.</li>
    </ul>
  </li>
  <li>wsgi는 보통 application(=app)이라는 이름의 파이썬 함수를 웹서버에 제공합니다. 해당 함수는 다음 두가지의 매개변수를 전달받습니다.
    <ul>
      <li>environ: 웹서버가 제공한 환경변수와 현재 요청에 대한 정보가 포함된 Dictionary</li>
      <li>start_response: 클라이언트로 HTTP 응답을 보내는 작업을 시작하는데 사용하는 함수
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">application</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
  <span class="nf">start_response</span><span class="p">(</span><span class="sh">'</span><span class="s">200 OK</span><span class="sh">'</span><span class="p">,</span> <span class="p">[(</span><span class="sh">'</span><span class="s">Content-Type</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">text/plain</span><span class="sh">'</span><span class="p">)])</span>
<span class="k">return</span> <span class="p">[</span><span class="sa">b</span><span class="sh">'</span><span class="s">Greetings universe</span><span class="sh">'</span><span class="p">]</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>방식: 요청 -&gt; 웹서버 -&gt; wsgi server (=middleware) -&gt; Djnago, Flask..</li>
  <li>단점
    <ul>
      <li>한 번에 하나의 요청과 응답만 처리하며, 응답이 즉시 반환된다고 전제합니다. 따라서, 롱폴링 HTTP 연결과 같은 장시간 연결을 처리할 수 없습니다.</li>
      <li>동기 전용으로, 멀티스레드 연결풀을 사용하더라도 응답이 반환될 때까지 각 연결이 차단됩니다.</li>
    </ul>
  </li>
</ul>

<h3 id="asgi">ASGI</h3>
<ul>
  <li>WSGI와 마찬가지로 파이썬 웹애플리케이션과 웹서버 사이에서 통신하기 위한 인터페이스입니다.</li>
  <li>WSGI와의 차이점은 애플리케이션당 여러 개의 비동기 이벤트를 허용한다는 것이며, 동기앱과 비동기앱 모두를 지원합니다.</li>
  <li>asgi를 사용해 새로운 비동기 웹앱을 구축하는 것뿐만 아니라 오래된 동기 wsgi 웹 앱을 asgi로 마이그레이션할 수도 있습니다.</li>
  <li>wsgi와 다르게 3개의 매개변수를 application에 전달합니다.
    <ul>
      <li>scope: 현재 요청에 대한 정보가 포함된 Dictionary (wsgi의 environ과 세부 명명규칙이 다름)</li>
      <li>send: 애플리케이션이 클라이언트로 메시지를 돌려보낼 수 이쏘록 해주는 async callable</li>
      <li>recieve: 애플리케이션이 클라이언트로부터 메시지를 수신할 수 있도록 해주는 async collable
```python
async def application(scope, receive, send):
await send({
  ‘type’: ‘http.response.start’,
  ‘status’: 200,
  ‘headers’: [
      [b’content-type’, b’text/plain’],
  ],
})</li>
    </ul>

    <p>await send({
    ‘type’: ‘http.response.body’,
    ‘body’: b’Hello, world!’,
})
```</p>
    <ul>
      <li>asgi의 가장 큰 특징은 함수 전반에서 비동기 메타포를 사용한다는 것입니다.</li>
      <li>함수 자체는 async이며 HTTP 헤더와 응답 본문을 별도의 두가지 await send() 명령으로 보냅니다. 따라서, 많은 연결의 application 및 send 호출과 동시에 교차가 가능합니다.</li>
      <li>receive 역시 async 함수로, 다른 작업을 차단하지 않고도 요청 본문을 받을 수 있습니다.</li>
    </ul>
  </li>
</ul>

<h3 id="asgi에서-동기-및-비동기-함수-사용하기">ASGI에서 동기 및 비동기 함수 사용하기</h3>
<ul>
  <li>동기 전용 함수에 대한 장기 실행 호출은 전체 호출 체인을 차단하기 때문에, 비동기 사용의 장점이 사라집니다.</li>
  <li>따라서, 장기 실행 동기 호출을 쓸 수 밖에 없는 상황이라면, asyncio.run_in_executor를 사용해 스레드 또는 프로세스 풀에 대한 호출을 맡깁니다.</li>
  <li>예를 들어, Pillow 이미지 라이브러리를 사용하는 경우, run_in_executor를 프로세스 풀과 함께 사용해야합니다.</li>
  <li>프로세스 간에 데이터를 주고받는 오버헤드가 있지만, run_in_executor는 다른 이벤트를 차단하지 않습니다.</li>
</ul>

<h3 id="wsgi-cgi-방식의-차이점">WSGI, CGI 방식의 차이점</h3>
<ul>
  <li>CGI 서브프로세스는 소켓과 stdout을 포함하여 OS 환경을 상속합니다.</li>
  <li>CGI 서브프로세스가 response를 작성하고, 이를 웹서브로 응답하면 웹서브는 해당 응답을 브라우저로 전송합니다.</li>
  <li>대부분의 CGI는 모든 요청마다 서브프로세스를 fork하게 됩니다.</li>
</ul>

<p>WSGI는 CGI 디자인 패턴에 기반한 인터페이스입니다.</p>
<ul>
  <li>WSGI는 모든 요청에 대해 서브프로세스를 fork하지 않습니다.</li>
  <li>HTTP 요청 헤더를 파싱하여 이를 환경에 추가합니다.</li>
  <li>file-like object로써 POST oriented input을 제공합니다.</li>
  <li>사용자로 하여금 수많은 format 디테일로부터 해방시키고 response를 만들 수 있는 기능을 제공합니다.</li>
</ul>]]></content><author><name>Yeham Kim</name></author><category term="Django Strategy" /><summary type="html"><![CDATA[각 용어의 정의 웹서버 인터넷을 통해서 요청된 웹 컨텐츠의 전달을 도와주는 하드웨어와 소프트웨어입니다. 웹서버는 기본적으로 ‘정적’인 파일을 전달합니다. 클라이언트가 HTTP 요청을 통해 리소스를 요청하면, 리소스를 그대로 보내줍니다.]]></summary></entry><entry><title type="html">[Django] Channels란 무엇일까?</title><link href="http://localhost:4000/strategy/django-strategy-channels/" rel="alternate" type="text/html" title="[Django] Channels란 무엇일까?" /><published>2023-09-24T00:05:07+09:00</published><updated>2023-09-24T00:05:07+09:00</updated><id>http://localhost:4000/strategy/django-strategy-channels</id><content type="html" xml:base="http://localhost:4000/strategy/django-strategy-channels/"><![CDATA[<h2 id="channels-모듈이란">Channels 모듈이란?</h2>
<ul>
  <li>Django에서 기본적으로 제공하는 비동기 뷰를 감싸서 Django가 HTTP 뿐 아니라 웹소켓, 챗봇, 라디오 등의 프로토콜을 처리할 수 있도록 합니다.</li>
  <li>이는 Django의 동기적인 방식과 양립할 수 있고, 원하는 방식으로 작성할 수 있습니다.</li>
  <li>인증, 세션 시스템과 통합될 수 있고, HTTP 용으로 개발된 프로젝트를 다른 프로토콜로 쉽게 확장할 수 있습니다.</li>
  <li>이벤트 주도의 구조를 Channel Layer를 이용해 다루며, Channel Layer는 여러 프로세스 간의 통신을 용이하게 만들면서 프로젝트를 여러 개의 프로세스로 나눌 수 있도록 합니다.</li>
</ul>

<h2 id="channels-동작-원리">Channels 동작 원리</h2>
<h3 id="tutles-all-the-way-down">Tutles All The Way Down</h3>
<ul>
  <li>Consumers는 채팅 메시지나 알림을 처리하는 독립적인 요소로, Channels는 기본적인 컨슈머를 작성하고, URL 라우팅에 연결하고 프로토콜을 감지하는 등의 기능을 제공합니다.</li>
  <li>HTTP와 기존 Django의 애플리케이션을 구성요소로 활용하여, 기존의 코드를 유지한 상태로 HTTP Long-Polling이나 웹소켓을 함께 처리할 수 있습니다.</li>
  <li>URL 라우팅, 미들웨어 모두 ASGI의 애플리케이션입니다.</li>
</ul>

<h3 id="scopes와-event">Scopes와 Event</h3>
<ul>
  <li>Channels와 ASGI는 들어오는 연결을 두 개의 컴포넌트(스코프, 이벤트들의 리스트)로 분리합니다.</li>
</ul>

<p>스코프</p>
<ul>
  <li>하나의 연결에 대한 상세 설명들의 집합입니다.</li>
  <li>요청이 발생한 URL, 웹소켓이 열린 IP 주소, 유저 정보등으로 구성됩니다.</li>
  <li>연결이 종료될 때까지 유지됩니다.</li>
  <li>HTTP의 경우, 스코프는 하나의 요청동안만 유지되지만, 웹소켓의 경우에는 소켓의 수명 전체에 걸쳐 유지됩니다.</li>
  <li>예를 들어, 챗봇 프로토콜은 챗 프로토콜이 상태를 갖지 않더라도 대화가 종료될 때까지 스코프가 유지됩니다.</li>
</ul>

<p>이벤트</p>
<ul>
  <li>스코프의 수명 동안 여러 이벤트들이 발생하며, 이는 유저와의 상호작용을 나타냅니다.</li>
  <li>HTTP 요청을 보내거나 웹소켓 프레임을 전송하는 일들입니다.</li>
  <li>ASGI 애플리케이션은 매 스코프마다 개별 인스턴스화되고, 해당 스코프 안에서 발생하는 이벤트들을 차례로 처리합니다.</li>
</ul>

<p>HTTP 예시</p>
<ol>
  <li>유저가 HTTP 요청 전송</li>
  <li>HTTP의 타입 스코프를 요청 URL, 메서드, 헤더 등을 담아서 생성</li>
  <li>http.request 이벤트를 HTTP body 데이터와 함께 전송</li>
  <li>Channels(or ASGI 애플리케이션)이 이를 처리해 http.response 이벤트를 생성, 브라우저에 응답 및 연결 종료</li>
  <li>HTTP 요청/응답 완결, 스코프 삭제</li>
</ol>

<p>챗봇 예시</p>
<ol>
  <li>유저가 챗봇에게 첫번째 메시지 전송</li>
  <li>유저의 ID, 이름, 유저명이 담긴 스코프 생성</li>
  <li>애플리케이션이 chat.received_message 이벤트를 텍스트 데이터와 함께 수신</li>
  <li>유저가 챗봇에게 메시지를 수차례 전송하며 chat.received_message 이벤트들이 생성</li>
  <li>제한시간이 지나거나 애플리케이션 프로세스 재시작시 스코프 삭제</li>
</ol>

<h3 id="컨슈머">컨슈머</h3>
<ul>
  <li>Channels의 기본적인 단위요소로, 이벤트를 받습니다.</li>
  <li>요청이나 새로운 소켓 요청이 들어오면, Channels는 라우팅 테이블을 찾아 해당 연결에 대한 적절한 컨슈머를 찾고, 인스턴스를 만들어 처리합니다.</li>
  <li>View와는 달리, 스코프가 종료되기까지 더 긴 수명을 갖도록 설계되었습니다.</li>
</ul>

<h4 id="코드로-보는-예시">코드로 보는 예시</h4>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ChatConsumer</span><span class="p">(</span><span class="n">WebsocketConsumer</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">username</span> <span class="o">=</span> <span class="sh">"</span><span class="s">Anonymous</span><span class="sh">"</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">accept</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">text_data</span><span class="o">=</span><span class="sh">"</span><span class="s">[Welcome %s!]</span><span class="sh">"</span> <span class="o">%</span> <span class="n">self</span><span class="p">.</span><span class="n">username</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">receive</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">text_data</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">text_data</span><span class="p">.</span><span class="nf">startswith</span><span class="p">(</span><span class="sh">"</span><span class="s">/name</span><span class="sh">"</span><span class="p">):</span>
            <span class="n">self</span><span class="p">.</span><span class="n">username</span> <span class="o">=</span> <span class="n">text_data</span><span class="p">[</span><span class="mi">5</span><span class="p">:].</span><span class="nf">strip</span><span class="p">()</span>
            <span class="n">self</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">text_data</span><span class="o">=</span><span class="sh">"</span><span class="s">[set your username to %s]</span><span class="sh">"</span> <span class="o">%</span> <span class="n">self</span><span class="p">.</span><span class="n">username</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">text_data</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="n">username</span> <span class="o">+</span> <span class="sh">"</span><span class="s">: </span><span class="sh">"</span> <span class="o">+</span> <span class="n">text_data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">disconnect</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="k">pass</span>
</code></pre></div></div>
<ul>
  <li>각 종류의 프로토콜에서는 서로 다른 타입의 이벤트들이 발생하며, 각 타입은 서로 다른 메서드로 구분됩니다.</li>
  <li>이벤트에 따라 처리하는 코드를 작성하면, Channels가 이들을 스케쥴링하고 병렬적으로 작동시키는 역할을 담당합니다.</li>
  <li>내부적으로 Channels는 완전히 비동기적인 이벤트 루프를 실행합니다.</li>
</ul>

<h4 id="동기적인-처리-예시">동기적인 처리 예시</h4>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">LogConsumer</span><span class="p">(</span><span class="n">WebsocketConsumer</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="n">Log</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span>
            <span class="nb">type</span><span class="o">=</span><span class="sh">"</span><span class="s">connected</span><span class="sh">"</span><span class="p">,</span>
            <span class="n">client</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="n">scope</span><span class="p">[</span><span class="sh">"</span><span class="s">client</span><span class="sh">"</span><span class="p">],</span>
        <span class="p">)</span>
</code></pre></div></div>
<h4 id="비동기적인-처리-예시">비동기적인 처리 예시</h4>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">PingConsumer</span><span class="p">(</span><span class="n">AsyncConsumer</span><span class="p">):</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">websocket_connect</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="k">await</span> <span class="n">self</span><span class="p">.</span><span class="nf">send</span><span class="p">({</span>
            <span class="sh">"</span><span class="s">type</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">websocket.accept</span><span class="sh">"</span><span class="p">,</span>
        <span class="p">})</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">websocket_receive</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">await</span> <span class="n">self</span><span class="p">.</span><span class="nf">send</span><span class="p">({</span>
            <span class="sh">"</span><span class="s">type</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">websocket.send</span><span class="sh">"</span><span class="p">,</span>
            <span class="sh">"</span><span class="s">text</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">pong</span><span class="sh">"</span><span class="p">,</span>
        <span class="p">})</span>
</code></pre></div></div>

<h3 id="라우팅-프로토콜들">라우팅, 프로토콜들</h3>
<ul>
  <li>라우팅을 활용하여 경로마다 기능별로 컨슈머를 사용하도록 할 수 있습니다.</li>
  <li>각각의 프로토콜을 목적에 따른 이벤트들로 분리하여 처리할 수 있도록 합니다.
    <h4 id="코드-예시">코드 예시</h4>
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ChattyBotConsumer</span><span class="p">(</span><span class="n">SyncConsumer</span><span class="p">):</span>

  <span class="k">def</span> <span class="nf">telegram_message</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
      <span class="sh">"""</span><span class="s">
      Simple echo handler for telegram messages in any chat.
      </span><span class="sh">"""</span>
      <span class="n">self</span><span class="p">.</span><span class="nf">send</span><span class="p">({</span>
          <span class="sh">"</span><span class="s">type</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">telegram.message</span><span class="sh">"</span><span class="p">,</span>
          <span class="sh">"</span><span class="s">text</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">You said: %s</span><span class="sh">"</span> <span class="o">%</span> <span class="n">message</span><span class="p">[</span><span class="sh">"</span><span class="s">text</span><span class="sh">"</span><span class="p">],</span>
      <span class="p">})</span>
</code></pre></div>    </div>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ChattyBotConsumer</span><span class="p">(</span><span class="n">SyncConsumer</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">telegram_message</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        Simple echo handler for telegram messages in any chat.
        </span><span class="sh">"""</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">send</span><span class="p">({</span>
            <span class="sh">"</span><span class="s">type</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">telegram.message</span><span class="sh">"</span><span class="p">,</span>
            <span class="sh">"</span><span class="s">text</span><span class="sh">"</span><span class="p">:</span> <span class="sh">"</span><span class="s">You said: %s</span><span class="sh">"</span> <span class="o">%</span> <span class="n">message</span><span class="p">[</span><span class="sh">"</span><span class="s">text</span><span class="sh">"</span><span class="p">],</span>
        <span class="p">})</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">application</span> <span class="o">=</span> <span class="nc">ProtocolTypeRouter</span><span class="p">({</span>

    <span class="sh">"</span><span class="s">websocket</span><span class="sh">"</span><span class="p">:</span> <span class="nc">URLRouter</span><span class="p">([</span>
        <span class="nf">url</span><span class="p">(</span><span class="sa">r</span><span class="sh">"</span><span class="s">^chat/admin/$</span><span class="sh">"</span><span class="p">,</span> <span class="n">AdminChatConsumer</span><span class="p">.</span><span class="nf">as_asgi</span><span class="p">()),</span>
        <span class="nf">url</span><span class="p">(</span><span class="sa">r</span><span class="sh">"</span><span class="s">^chat/$</span><span class="sh">"</span><span class="p">,</span> <span class="n">PublicChatConsumer</span><span class="p">.</span><span class="nf">as_asgi</span><span class="p">()),</span>
    <span class="p">]),</span>

    <span class="sh">"</span><span class="s">telegram</span><span class="sh">"</span><span class="p">:</span> <span class="n">ChattyBotConsumer</span><span class="p">.</span><span class="nf">as_asgi</span><span class="p">(),</span>
<span class="p">})</span>
</code></pre></div></div>

<h2 id="프로세스간-통신">프로세스간 통신</h2>
<ul>
  <li>표준 WSGI 서버와 같이, 애플리케이션은프로토콜 이벤트들을 서버 프로세스 안에서 처리합니다.</li>
  <li>애플리케이션으로 들어오는 소켓이나 연결은 애플리케이션 인스턴스에 의해 처리됩니다. 애플리케이션 인스턴스는 호출되고, 클라이언트에게 다시 데이터를 직접 보내줍니다.</li>
  <li>복잡한 애플리케이션을 구성하다보면 서로 다른 애플리케이션 인스턴스들 간의 통신이 필요한 경우가 생깁니다.</li>
</ul>]]></content><author><name>Yeham Kim</name></author><category term="Strategy" /><summary type="html"><![CDATA[Channels 모듈이란? Django에서 기본적으로 제공하는 비동기 뷰를 감싸서 Django가 HTTP 뿐 아니라 웹소켓, 챗봇, 라디오 등의 프로토콜을 처리할 수 있도록 합니다. 이는 Django의 동기적인 방식과 양립할 수 있고, 원하는 방식으로 작성할 수 있습니다. 인증, 세션 시스템과 통합될 수 있고, HTTP 용으로 개발된 프로젝트를 다른 프로토콜로 쉽게 확장할 수 있습니다. 이벤트 주도의 구조를 Channel Layer를 이용해 다루며, Channel Layer는 여러 프로세스 간의 통신을 용이하게 만들면서 프로젝트를 여러 개의 프로세스로 나눌 수 있도록 합니다.]]></summary></entry><entry><title type="html">[Study] Database - TRIGGER, Transaction</title><link href="http://localhost:4000/study/study-cs-dbms/" rel="alternate" type="text/html" title="[Study] Database - TRIGGER, Transaction" /><published>2023-09-11T00:05:07+09:00</published><updated>2023-09-11T00:05:07+09:00</updated><id>http://localhost:4000/study/study-cs-dbms</id><content type="html" xml:base="http://localhost:4000/study/study-cs-dbms/"><![CDATA[<h2 id="sql-trigger">SQL Trigger</h2>
<ul>
  <li>데이터에 변경(INSERT, UPDATE, DELETE)이 생겼을 때 자동적으로 실행되는 프로시저를 의미합니다.</li>
  <li>INSERT, UPDATE, DELETE를 한 번에 감지하도록 설정 또한 가능합니다. (MySQL은 불가능)</li>
  <li>애플리케이션이 알 수 없는 데이터베이스 서버의 로직이기 때문에, 문제사항 발생 시 대응하기 어렵다는 단점이 있습니다.</li>
  <li>트리거를 지나치게 많이 발생시키면, 연쇄적인 트리거 발생이 생길 수 있고 이는 DB에 부담을 주어 응답을 느리게 할 수 있습니다.</li>
</ul>

<h4 id="사용자-닉네임-변경-이력-기록">사용자 닉네임 변경 이력 기록</h4>
<ul>
  <li>사용자의 닉네임 변경 이력을 저장하는 트리거를 작성한다면,
    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">delimiter</span> <span class="err">$$</span>
<span class="k">CREATE</span> <span class="k">TRIGGER</span> <span class="n">log_user_nickname_trigger</span>
<span class="k">BEFORE</span> <span class="k">UPDATE</span>
<span class="k">ON</span> <span class="n">users</span> <span class="k">FOR</span> <span class="k">EACH</span> <span class="k">ROW</span>
<span class="k">BEGIN</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">user_log</span> <span class="k">values</span><span class="p">(</span><span class="k">OLD</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="k">OLD</span><span class="p">.</span><span class="n">nickname</span><span class="p">,</span> <span class="n">NOW</span><span class="p">());</span>
<span class="k">END</span>
<span class="err">$$</span>
<span class="k">delimiter</span> <span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>닉네임이 UPDATE 될 때마다 그 전에 트리거를 동작시킵니다.</li>
  <li>users 테이블에 대해 업데이트가 발생하면, 트리거가 동작하여 각 ROW에 대해 액션을 실행합니다.</li>
  <li>닉네임이 업데이트될 때마다 기존의 닉네임을 users_log 테이블에 저장하게 됩니다.<br />
(<code class="language-plaintext highlighter-rouge">OLD</code> 업데이트되기 전의 users의 tuple을 가리킴.)</li>
</ul>

<h4 id="사용자-누적-구매-비용-저장-통계-기록">사용자 누적 구매 비용 저장 통계 기록</h4>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">delimiter</span> <span class="err">$$</span>
<span class="k">CREATE</span> <span class="k">TRIGGER</span> <span class="n">sum_buy_prices_trigger</span>
<span class="k">AFTER</span> <span class="k">INSERT</span>
<span class="k">ON</span> <span class="n">buy</span> <span class="k">FOR</span> <span class="k">EACH</span> <span class="k">ROW</span>
<span class="k">BEGIN</span>
  <span class="k">DECLARE</span> <span class="n">total</span> <span class="nb">INT</span><span class="p">;</span>
  <span class="k">DECLARE</span> <span class="n">user_id</span> <span class="nb">INT</span> <span class="k">DEFAULT</span> <span class="k">NEW</span><span class="p">.</span><span class="n">user_id</span><span class="p">;</span>

  <span class="k">select</span> <span class="k">sum</span><span class="p">(</span><span class="n">price</span><span class="p">)</span> <span class="k">into</span> <span class="n">total</span> <span class="k">from</span> <span class="n">buy</span> <span class="k">where</span> <span class="n">user_id</span> <span class="o">=</span> <span class="n">user_id</span><span class="p">;</span>
  <span class="k">update</span> <span class="n">user_buy_stats</span> <span class="k">set</span> <span class="n">price_sum</span> <span class="o">=</span> <span class="n">total</span> <span class="k">where</span> <span class="n">user_id</span> <span class="o">=</span> <span class="n">user_id</span><span class="p">;</span>
<span class="k">END</span>
<span class="err">$$</span>
<span class="k">delimiter</span> <span class="p">;</span>
</code></pre></div></div>
<ul>
  <li>INSERT 이벤트가 발생한 후에 액션을 수행합니다.</li>
  <li>total이라는 INT 변수를 선언하고, user_id라는 INT 변수를 선언합니다. 이 때, 초기 값으로 user_id에 insert된 tuple의 user_id를 넣어줍니다.</li>
</ul>

<h4 id="임직원-평균-연봉-구하기-postgresql">임직원 평균 연봉 구하기 (PostgreSQL)</h4>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TRIGGER</span> <span class="n">avg_empl_salary_trigger</span>
  <span class="k">AFTER</span> <span class="k">INSERT</span> <span class="k">OR</span> <span class="k">UPDATE</span> <span class="k">OR</span> <span class="k">DELETE</span>
  <span class="k">ON</span> <span class="n">employee</span>
  <span class="k">FOR</span> <span class="k">EACH</span> <span class="k">STATEMENT</span>
  <span class="n">EXCUTE</span> <span class="k">FUNCTION</span> <span class="n">update_avg_empl_salary</span><span class="p">();</span>
</code></pre></div></div>
<ul>
  <li>[MySQL X] 하나 이상의 이벤트가 발생하는 조건에 대해서 트리거를 진행할 수 있습니다.</li>
  <li>[MySQL X] <code class="language-plaintext highlighter-rouge">FOR EACH ROW</code>와 <code class="language-plaintext highlighter-rouge">FOR EACH STATEMENT</code>의 차이점에 대해서 학습해 보기.</li>
</ul>

<h2 id="transaction">Transaction</h2>
<ul>
  <li>데이터베이스의 상태를 변화시키기 위해 <code class="language-plaintext highlighter-rouge">수행하는 작업의 단위</code>입니다.</li>
  <li>commit: 하나의 트랜잭션이 성공적으로 끝났고, DB가 일관성있는 상태라면 변경된 상태를 영구적으로 반영하는 것입니다.</li>
  <li>rollback: 테이블 내에 입력/수정/삭제한 데이터에 대해 commit 이전 변경 사항을 취소합니다. 이 때, 관련된 행에 대한 잠금(locking)이 해제되고, 다른 사용자들이 데이터 변경을 가능하도록 합니다.</li>
  <li>savepoint: rollback 시, 트랜잭션에 포함된 전체 작업을 rollback하지 않고, 현시점에서 savepoint까지의 트랜잭션의 일부만 rollback 가능합니다.</li>
</ul>

<h3 id="특징-acid">특징 (ACID)</h3>
<ul>
  <li>Atomic(원자성): 트랜잭션이 DB에 모두 반영되거나, 전혀 반영되지 않아야 합니다.</li>
  <li>Consistency(일관성): 트랜잭션의 작업 처리 결과는 항상 일관성이 있어야 합니다.</li>
  <li>Isolation(독립성): 둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 때, 서로 다른 트랜잭션 연산은 독립적이어야 합니다.</li>
  <li>Durability(지속성): 트랜잭션이 성공적으로 완료된다면, 결과는 영구적으로 반영되어야 합니다. (power faile이나 DB crash가 발생하더라도. 이는 DBMS가 보장합니다.)
    <h4 id="추가">추가</h4>
  </li>
  <li>일관성은 기본 키, 외래 키 제약과 같은 명시적인 무결성 제약 조건들 뿐만 아니라, 이체 예시에서 두 계좌 잔고의 합은 이체 전후가 같아야 한다는 사항과 같은 비명시적인 일관성 조건들도 있습니다.</li>
  <li>Isolation을 엄격하게 구현한다면, DB 서버의 성능에 영향을 주는 요소이기 때문에 여러 종류의 isolationlevel을 제공합니다.</li>
</ul>

<h3 id="autocommit">Autocommit</h3>
<ul>
  <li>각각의 SQL문을 자동으로 transaction 처리하는 개념으로, SQL문이 성공적으로 실행하면 자동으로 commit 합니다. 실패 시, 자동으로 rollback 합니다.</li>
  <li>MySQL의 경우, autocommit이 기본적으로 활성화되어 있으며, transaction 시작 시 autocommit 기능을 off합니다.</li>
  <li>autocommit을 off하게 되면, commit을 할 때까지 영구적인 반영이 되는 것은 아니기 때문에, rollback 시 원래 상태로 돌이킬 수 있습니다.</li>
</ul>

<h3 id="일반적인-사용-패턴">일반적인 사용 패턴</h3>
<ol>
  <li>transaction을 시작(begin) 합니다. (autocommit을 off 상태로 변경)</li>
  <li>데이터를 읽거나 쓰는 등의 SQL 문들을 포함하여 로직을 수행합니다.</li>
  <li>일련의 과정들이 문제없이 동작했다면 transaction을 commit 합니다.</li>
  <li>문제가 발생했다면, transaction을 rollback 합니다.</li>
  <li>commit 및 rollback 후에 autocommit을 on 상태로 변경합니다.</li>
</ol>

<h2 id="concurrency-control">Concurrency Control</h2>
<ul>
  <li>Schedule: 여러 트랜잭션들이 동시에 실행될 때 각 트랜잭션에 속한 operation들의 실행 순서를 의미합니다. 이 때, 각각의 트랜잭션 내의 operation들의 순서는 바뀌지 않습니다.</li>
  <li>고민거리: 성능 때문에 여러 transaction들을 겹쳐서 실행(nonserial schedule)하면 좋겠지만, 의도치 않은 결과가 발생하는 상황이 생깁니다.</li>
  <li>해결방법: conflict serializable한 경우에 대해서는 nonserial schedule를 허용합니다.</li>
  <li>즉, 어떤 스케쥴이라도 serializable하도록 동작하게 만드는 제어기법을 의미합니다.</li>
</ul>

<h2 id="serializability">Serializability</h2>

<h4 id="serial-schedule">Serial schedule</h4>
<ul>
  <li>트랜잭션들이 겹치지 않고 한 번에 하나씩 실행되는 스케쥴을 의미합니다.</li>
  <li>저장공간에 대해 I/O 작업을 수행하는 동안에 CPU는 쉬고 있지만 serial은 다른 동작을 수행시키지 않으므로 동시성이 없고 좋은 성능을 내지 못합니다.</li>
</ul>

<h4 id="nonserial-schedule">Nonserial schedule</h4>
<ul>
  <li>트랜잭션들이 겹쳐서 실행되는 스케쥴을 의미합니다.</li>
  <li>I/O 작업 중 다른 트랜잭션을 수행하기 때문에 동시성이 높아져 같은 시간동안 더 많은 트랜잭션을 처리할 수 있습니다.</li>
  <li>단점: 트랜잭션들이 어떤 형태로 겹쳐서 실행되는지에 따라 결과값이 변경될 우려가 있습니다.</li>
</ul>

<h4 id="conflict">Conflict</h4>
<ul>
  <li>Conflict란, 아래의 세 조건을 만족하는 경우입니다.
    <ol>
      <li>두 오퍼레이션이 서로 다른 트랜잭션 소속인 경우</li>
      <li>두 오퍼레이션이 같은 데이터에 접근하는 경우</li>
      <li>두 오퍼레이션 중 최소한 하나는 쓰기 오퍼레이션인 경우</li>
    </ol>
  </li>
  <li>두 오퍼레이션 중 하나의 오퍼레이션은 읽는 경우, 다른 하나의 오퍼레이션은 쓰는 경우 발생하는 컨플릭트를 read-write conflict라고 합니다.</li>
  <li>두 오퍼레이션 모두 쓰는 오퍼레이션이라면 write-write conflict라고 합니다.</li>
  <li>conflict operation은 순서가 바뀌게 될 때 결과도 바뀝니다.</li>
  <li>Conflict equivalent란, 아래의 두 조건을 모두 만족하는 경우입니다.
    <ol>
      <li>두 스케쥴이 같은 트랜잭션들을 가지는 경우</li>
      <li>트랜잭션들의 모든 conflicting operation들의 순서가 양쪽 스케쥴 모두 동일한 경우<br />
(conflicting operation: read-write/write-wr ite conflict)</li>
    </ol>
  </li>
  <li>Serial schedule과 conflict equivalent일 때 Conflict serializable이라고 할 수 있습니다.</li>
</ul>

<h3 id="conflict-serializable-확인방법-구현">Conflict serializable 확인방법 구현</h3>
<ul>
  <li>여러개의 트랜잭션을 동시에 실행하더라도 스케쥴이 conflict serializable 하다는 것이 보장되는 스케줄만 실행되도록 하는 프로토콜을 적용합니다.</li>
</ul>

<h2 id="unrecoverability">Unrecoverability</h2>
<ul>
  <li>스케쥴 내에서 커밋된 트랜잭션(1번)이 “rollback된 트랜잭션(2번)이 수정했던 데이터”를 읽은 경우를 의미합니다. 즉, 1번 트랜잭션은 유효하지 않은 2번 트랜잭션의 데이터에 작업을 하게된 경우입니다. -&gt; unrecoverable schedule</li>
  <li>위의 상황에서, rollback을 하더라도 이전 상태로 회복 불가능하기 때문에, 이런 스케줄은 DBMS에서 허용하면 안됩니다.</li>
</ul>

<h4 id="recoverable한-스케쥴">Recoverable한 스케쥴</h4>
<ul>
  <li>스케쥴 내에서 그 어떤 트랜잭션도 자신이 읽은 데이터를 수정한 트랜잭션이 먼저 커밋/롤백 되기 전까지 커밋하지 않는 경우에 recoverable한 스케쥴이라 할 수 있습니다.</li>
  <li>트랜잭션 간에 의존성이 있는 경우, 의존하는 트랜잭션은</li>
</ul>

<h2 id="isolation-level-격리수준">Isolation Level (격리수준)</h2>
<p><strong>Read Uncommitted (Level 0)</strong></p>
<ul>
  <li>SELECT 문이 수행되는 동안 해당 데이터에 Shared Lock이 걸리지 않는 계층입니다.</li>
  <li>트랜잭션이 처리중이거나, 아직 commit되지 않은 데이터를 다른 트랜잭션이 읽는 것조차 허용합니다.</li>
  <li>데이터베이스의 일관성을 유지하는 것이 불가능합니다.</li>
</ul>

<p><strong>Read Committed (Level 1)</strong></p>
<ul>
  <li>대부분의 SQL 서버가 기본적으로 사용하는 격리수준입니다.</li>
  <li>커밋된 데이터만 조회할 수 있습니다. Phantom Read, Non-Retable Read 문제가 발생할 수 있습니다.</li>
  <li>트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어서 대기하게 됩니다.</li>
</ul>

<p><strong>Repeatable Read (Level 2)</strong></p>
<ul>
  <li>MySQL에서 기본으로 사용하는 격리수준입니다.</li>
  <li>일반적인 RDBMS는 변경 전의 레코드를 언두 공간에 백업해둡니다. 
(MVCC. 동일한 레코드에 대해 여러 버전의 데이터가 존재)</li>
  <li>트랜잭션이 롤백된 경우에 데이터를 복원할 수 있을 뿐 아니라,</li>
  <li>트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Loack이 걸리는 단계입니다.</li>
  <li>트랜잭션이 범위 내에서 조회한 데이터 내용이 항상 동일함을 보장합니다.</li>
  <li>다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정이 불가능합니다.</li>
</ul>

<p><strong>Serializable (Level 3)</strong></p>
<ul>
  <li>여러 트랜잭션이 동일한 레코드에 동시에 접근(읽기/쓰기/수정 모두)할 수 없습니다. 하지만, 트랜잭션이 순차적으로 처리되어야 하기 때문에 동시처리 성능이 매우 떨어집니다.</li>
  <li>순수한 SELECT 작업에 대해서도 대상 레코드에 넥스트 키 락을 읽기잠금(공유락, Shared Lock)으로 겁니다.</li>
  <li>완벽한 읽기 일관성 모드를 제공합니다.</li>
</ul>

<h3 id="격리수준이-낮을-때-발생할-수-있는-문제">격리수준이 낮을 때 발생할 수 있는 문제</h3>

<p><strong>Dirty Read</strong></p>
<ul>
  <li>발생 격리 수준: Read Uncommitted</li>
  <li>어떤 트랜잭션에서 아직 실행이 끝나지 않았을 때, <code class="language-plaintext highlighter-rouge">다른 트랜잭션에 의한 변경 사항</code>을 트랜잭션 수행 중 조회하게 되는 경우입니다.</li>
  <li>커밋되지 않은 수정중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할 때 발생합니다.</li>
</ul>

<p><strong>Non-Repeatable Read</strong></p>
<ul>
  <li>발생 격리 수준: Read Committed, Read Uncommitted</li>
  <li>한 트랜잭션에서 같은 쿼리를 두 번 수행할 때, 그 사이에 다른 트랜잭션 값을 수정/삭제 하면서 두 쿼리의 결과가 다르게 나타나며 일관성이 깨지는 현상입니다.</li>
</ul>

<p><strong>Phantom Read</strong></p>
<ul>
  <li>발생 격리 수준: Repeatable Read, Read Committed, Read Uncommitted</li>
  <li>트랜잭션 도중에 새로운 레코드 삽입을 허용하기 때문에 나타나는 현상입니다.</li>
  <li>한 트랜잭션 안에서 일정 범위의 레코드를 두 번 이상 읽을 때, 첫 번째 쿼리에서 없던 레코드가 두 번째 쿼리에서 나타나는 현상입니다.</li>
</ul>

<h3 id="dbms의-구조">DBMS의 구조</h3>
<ul>
  <li>크게 <code class="language-plaintext highlighter-rouge">Query Processor</code>와 <code class="language-plaintext highlighter-rouge">Storage System</code>이 있습니다.</li>
  <li>입출력은 고정 길이의 page 단위로 disk에 읽거나 씁니다.</li>
  <li>저장 공간은 비휘발성 저장 장치인 disk에 저장하며, 일부를 Main Memory에 저장합니다.</li>
</ul>

<h3 id="page-buffer-manageror-buffer-manager">Page Buffer Manager(or Buffer Manager)</h3>
<ul>
  <li>DBMS의 Storage System에 속하는 모듈 중 하나로, Main Memory에 유지하는 페이지를 관리합니다.</li>
  <li>Buffer 관리 정책에 따라서, UNDO 복구와 REDO 복구가 요구되거나 그렇지 않게 되므로, transaction 관리에 매우 중요한 결정을 합니다.</li>
</ul>

<h3 id="undo">UNDO</h3>
<ul>
  <li>트랜잭션은 시작 됐지만 아직 완료되지 않은 commit되지 않은 부분에 대해 연산을 취소합니다.</li>
  <li>수정된 Page들이 <strong>Buffer 교체 알고리즘에 따라 디스크에 출력</strong>될 수 있습니다.</li>
  <li>Buffer 관리 정책에 영향을 받습니다.</li>
</ul>

<h3 id="redo">REDO</h3>
<ul>
  <li>이미 commit된 transaction의 수정을 재반영하는 복구 작업입니다.</li>
  <li>Buffer 관리 정책에 영향을 받습니다.</li>
</ul>

<h3 id="참고자료">참고자료</h3>
<ul>
  <li><a href="https://youtu.be/mEeGf4ZWQKI?si=cTzyiw9E9bCI4DFS">쉬운코드님 trigger 강의</a></li>
</ul>]]></content><author><name>Yeham Kim</name></author><category term="Study" /><summary type="html"><![CDATA[SQL Trigger 데이터에 변경(INSERT, UPDATE, DELETE)이 생겼을 때 자동적으로 실행되는 프로시저를 의미합니다. INSERT, UPDATE, DELETE를 한 번에 감지하도록 설정 또한 가능합니다. (MySQL은 불가능) 애플리케이션이 알 수 없는 데이터베이스 서버의 로직이기 때문에, 문제사항 발생 시 대응하기 어렵다는 단점이 있습니다. 트리거를 지나치게 많이 발생시키면, 연쇄적인 트리거 발생이 생길 수 있고 이는 DB에 부담을 주어 응답을 느리게 할 수 있습니다.]]></summary></entry><entry><title type="html">[Study] Operating System - Sync, Async</title><link href="http://localhost:4000/study/study-cs-os-sync-async/" rel="alternate" type="text/html" title="[Study] Operating System - Sync, Async" /><published>2023-09-07T00:05:07+09:00</published><updated>2023-09-07T00:05:07+09:00</updated><id>http://localhost:4000/study/study-cs-os-sync-async</id><content type="html" xml:base="http://localhost:4000/study/study-cs-os-sync-async/"><![CDATA[<h3 id="race-condition">Race condition</h3>
<ul>
  <li>여러 프로세스/스레드가 동시에 같은 데이터에 접근할 때 타이밍이나 접근 순서에 따라 결과가 달라지는 상황을 말합니다.</li>
  <li>동기화: 여러 프로세스/스레드를 동시에 실행하더라도 공유 데이터의 일관성을 유지하도록 하는 것을 의미합니다.</li>
  <li>critical section: 공유 데이터의 일관성을 보장하기 위해 하나의 프로세스/스레드만 진입해서 실행 가능한 영역을 의미합니다.
    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">do</span> <span class="o">{</span>
  entry section <span class="c"># critical section에 진입하기 위한 조건을 갖추었는지 확인하는 구간</span>
    critical section
  <span class="nb">exit </span>section <span class="c"># 이 후에도 솔루션이 잘 동작할 수 있도록 조치를 취하는 구간</span>
    remainder section
<span class="o">}</span> <span class="k">while</span> <span class="o">(</span>True<span class="o">)</span>
</code></pre></div>    </div>
  </li>
  <li>하나의 메서드가 실행하고 마칠 때까지 한 스레드만 해당 메서드에 접근 가능하도록 한다면 (critical section), 싱글코어든 멀티코어든 해당 메서드의 처리 이후 접근하게 될 것이므로 동기화에 대해 문제가 없습니다.</li>
  <li>critical section problem의 해결책을 위한 조건은 다음과 같습니다.
    <ol>
      <li>mutual exclusion (상호 배제): 한 번에 하나의 프로세스/스레드만 critical section에 진입하여 작업 수행이 가능합니다.</li>
      <li>progress (진행): critical section이 비어있고, 이를 위해 대기하고 있는 프로세스/스레드가 있다면 그 중 하나는 진행이 될 수 있도록 처리해야합니다.</li>
      <li>bounded waiting (한정된 대기): 어떤 프로세스/스레드가 무한정 critical section에 들어가지 못하고 있는 경우는 없어야 합니다.</li>
    </ol>
  </li>
</ul>

<h3 id="lock">Lock</h3>
<ul>
  <li>mutual exclusion을 보장하도록 하는 방법입니다.
    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">do</span> <span class="o">{</span>
  acquire lock
    critical section
  release lock
    remainder section
<span class="o">}</span> <span class="k">while</span> <span class="o">(</span>TRUE<span class="o">)</span>
</code></pre></div>    </div>
  </li>
  <li>atomic 명령어: 실행 중간에 간섭받거나 중단되지 않으며, 같은 메모리 영역에 대해 동시에 실행되지 않습니다. 이는, CPU 내부에서 함수를 동작시키는 원리입니다.</li>
  <li>mutual exclusion만 사용한다면 뮤텍스를, 작업 간의 실행 순서에 대한 동기화가 필요하다면 세마포어 사용을 권장합니다.</li>
</ul>

<p><strong>Spin lock</strong></p>
<ul>
  <li>무한루프(while True)를 사용해서 lock을 획득할 떄까지 기다리는 방식입니다.</li>
  <li>기다리는 동안 CPU를 낭비하게 되는 단점이 있습니다. 다른 작업을 위해 사용해야하는 CPU를 락을 확인하는데 사용하고 있기 때문입니다.</li>
  <li>멀티코어 환경이고, critical section에서의 작업이 컨텍스트 스위칭보다 더 빨리 끝나면 스핀락이 뮤텍스보다 이점을 갖습니다.</li>
</ul>

<p><strong>Mutex</strong></p>
<ul>
  <li>뮤텍스의 기본 원리는 아래와 같습니다. 락을 가질 수 있을 때까지 휴식을 취하다가 락을 쥐면 그때 깨어나서 critical section에 진입합니다.
    <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mutex</span> <span class="o">-&gt;</span> <span class="n">lock</span><span class="p">();</span>
<span class="p">...</span> <span class="n">critical</span> <span class="n">section</span>
<span class="n">mutex</span> <span class="o">-&gt;</span> <span class="n">unlock</span><span class="p">();</span>

<span class="c1">//---</span>

<span class="k">class</span> <span class="nc">Mutex</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">guard</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Mutex</span><span class="o">::</span><span class="n">lock</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">test_and_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">guard</span><span class="p">));</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span> <span class="err">현재</span> <span class="err">스레드를</span> <span class="err">큐에</span> <span class="err">넣기</span><span class="p">;</span>
    <span class="n">guard</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">guard</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">Mutex</span><span class="o">::</span><span class="n">unlock</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">test_and_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">guard</span><span class="p">));</span>
  <span class="k">if</span> <span class="p">(</span><span class="err">큐에</span> <span class="err">대기중인</span> <span class="err">프로세스</span> <span class="err">존재</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span> <span class="n">lock</span><span class="err">을</span> <span class="err">해제</span><span class="p">;</span>
    <span class="n">guard</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">value</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="p">}</span>
  <span class="n">guard</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li>Point1. 스레드들은 lock을 갖기 위해 경합을 하며, <code class="language-plaintext highlighter-rouge">value</code>가 0인 경우, 무한루프를 돌리지 않고, 스레드를 큐에 넣는 작업을 합니다.</li>
      <li>Point2. CPU 레벨에서 지원하는 atomic 명령어인 <code class="language-plaintext highlighter-rouge">test_and_set</code>을 사용하여 작업합니다.</li>
    </ul>
  </li>
  <li>priority inheritance 속성을 가집니다. 따라서, 스케쥴러가 스케쥴링을 할 때 우선순위를 조정하여 critical section을 빠져나오도록 할 수 있습니다. (세마포어는 이런 동작 불가능)</li>
</ul>

<p><strong>Semaphore</strong></p>
<ul>
  <li>signal mechanism을 가진 하나 이상의 프로세스/스레드가 critical section에 접근 가능한 장치입니다.
    <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//---</span>

<span class="k">class</span> <span class="nc">Semaphore</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">guard</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Semaphore</span><span class="o">::</span><span class="n">wait</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">test_and_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">guard</span><span class="p">));</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span> <span class="err">현재</span> <span class="err">스레드를</span> <span class="err">큐에</span> <span class="err">넣기</span><span class="p">;</span>
    <span class="n">guard</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">value</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">guard</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">Semaphore</span><span class="o">::</span><span class="n">signal</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">test_and_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">guard</span><span class="p">));</span>
  <span class="k">if</span> <span class="p">(</span><span class="err">큐에</span> <span class="err">대기중인</span> <span class="err">프로세스</span> <span class="err">존재</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span> <span class="err">그</span> <span class="err">중</span> <span class="err">하나를</span> <span class="err">깨워서</span> <span class="err">작업을</span> <span class="err">위한</span> <span class="err">준비를</span> <span class="err">진행시키기</span><span class="p">;</span>
    <span class="n">guard</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">value</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="p">}</span>
  <span class="n">guard</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">value</code>를 0과 1만 가지는 경우에는 바이너리 세마포어, 1외에 값을 가질 수 있는 경우는 카운팅 세마포어라고 합니다.</li>
      <li><code class="language-plaintext highlighter-rouge">value</code>가 1 외에도 여러값을 가져서, critical section에 하나 이상의 프로세스/스레드가 접근하여 작업이 가능하도록 합니다.</li>
    </ul>
  </li>
  <li>세마포어는 순서를 정해줄 때 사용할 수 있습니다. 예를 들어 task의 진행 방식이 아래와 같다고 생각해봅시다. (signal mechanism을 가짐)
    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>task1 <span class="o">{</span>
  semaphore-&gt;signal<span class="o">()</span>
<span class="o">}</span>

task2
semaphore-&gt;wait<span class="o">()</span>
task3
</code></pre></div>    </div>
    <ul>
      <li>task3를 실행하기 위해, task2가 끝나고 task3을 수행하려면, task1을 먼저 수행하여 <code class="language-plaintext highlighter-rouge">signal</code>을 얻어 와야합니다.</li>
    </ul>
  </li>
  <li>위 예시와 같이 <code class="language-plaintext highlighter-rouge">wait()</code>와 <code class="language-plaintext highlighter-rouge">signal()</code>이 반드시 같은 프로세스나 스레드 안에서 실행될 필요가 없다는 특징이 있습니다.</li>
  <li>뮤텍스는 락을 가진 프로세스/스레드만 락을 해제할 수 있지만, 세마포어는 <code class="language-plaintext highlighter-rouge">wait</code>를 하는 프로세스와 <code class="language-plaintext highlighter-rouge">signal</code>을 날리는 프로세스가 달라도 됩니다.</li>
</ul>

<h2 id="참고">참고</h2>
<ul>
  <li><a href="https://youtu.be/vp0Gckz3z64?si=diBWEAzKVzTrjK9u">쉬운코드님 운영체제 - 동기화의 목적</a></li>
</ul>]]></content><author><name>Yeham Kim</name></author><category term="Study" /><summary type="html"><![CDATA[Race condition 여러 프로세스/스레드가 동시에 같은 데이터에 접근할 때 타이밍이나 접근 순서에 따라 결과가 달라지는 상황을 말합니다. 동기화: 여러 프로세스/스레드를 동시에 실행하더라도 공유 데이터의 일관성을 유지하도록 하는 것을 의미합니다. critical section: 공유 데이터의 일관성을 보장하기 위해 하나의 프로세스/스레드만 진입해서 실행 가능한 영역을 의미합니다. do { entry section # critical section에 진입하기 위한 조건을 갖추었는지 확인하는 구간 critical section exit section # 이 후에도 솔루션이 잘 동작할 수 있도록 조치를 취하는 구간 remainder section } while (True) 하나의 메서드가 실행하고 마칠 때까지 한 스레드만 해당 메서드에 접근 가능하도록 한다면 (critical section), 싱글코어든 멀티코어든 해당 메서드의 처리 이후 접근하게 될 것이므로 동기화에 대해 문제가 없습니다. critical section problem의 해결책을 위한 조건은 다음과 같습니다. mutual exclusion (상호 배제): 한 번에 하나의 프로세스/스레드만 critical section에 진입하여 작업 수행이 가능합니다. progress (진행): critical section이 비어있고, 이를 위해 대기하고 있는 프로세스/스레드가 있다면 그 중 하나는 진행이 될 수 있도록 처리해야합니다. bounded waiting (한정된 대기): 어떤 프로세스/스레드가 무한정 critical section에 들어가지 못하고 있는 경우는 없어야 합니다.]]></summary></entry><entry><title type="html">[Study] Operating System - Process, Thread, System call</title><link href="http://localhost:4000/study/study-cs-os-process-thread-new/" rel="alternate" type="text/html" title="[Study] Operating System - Process, Thread, System call" /><published>2023-09-07T00:05:07+09:00</published><updated>2023-09-07T00:05:07+09:00</updated><id>http://localhost:4000/study/study-cs-os-process-thread-new</id><content type="html" xml:base="http://localhost:4000/study/study-cs-os-process-thread-new/"><![CDATA[<h2 id="컴퓨터의-구조-코어와-스레드">컴퓨터의 구조 (코어와 스레드)</h2>
<ul>
  <li>OS kernel은 사용자 프로그램과 Memory, CPU, Device를 다루는 연결고리 역할을 합니다.</li>
</ul>

<h3 id="코어와-스레드">코어와 스레드</h3>
<ul>
  <li>코어는 코어 자체의 연산작업에 비해, 메모리에서 데이터를 기다리는 시간이 오래 걸립니다. 이는 결국 코어의 자원 낭비로 이어집니다.</li>
  <li>Q. OS 스레드 여덟 개를 하이퍼 스레딩이 적용된 인텔 듀얼코드 위에서 동작시키려면 OS 스레드들을 어떻게 코어에 균등하게 할 수 있을까요? 라는 질문의 답을 찾을 수 있습니다.</li>
</ul>

<h3 id="하드웨어-스레드">하드웨어 스레드</h3>
<ul>
  <li>메모리에서 데이터를 기다리는 중에도 계속해서 작업을 하고자 합니다. 따라서 병렬적인 작업을 실행하기 위한 처리, 즉 하드웨어 스레드 개념이 등장합니다.<br />
(인텔은 이를 Hyper-threading이라고 명명하였으며, 물리적인 코어마다 하드웨어 스레드가 두 개인 경우를 의미합니다.)</li>
  <li>Hardware thread는 OS 관점에서 볼 때는 가상의(logical) <code class="language-plaintext highlighter-rouge">코어</code>입니다. 따라서, 싱글 코어 CPU에서 하드웨어 스레드가 두 개라면 OS는 CPU를 듀얼코어로 인식합니다. 이에 맞춰 OS 레벨의 스레드들을 스케줄링합니다.</li>
</ul>

<h3 id="os-스레드">OS 스레드</h3>
<ul>
  <li>일반적으로 알고 있는 스레드 개념으로, OS 커널 레벨에서 생성되고 관리되는 스레드입니다.</li>
  <li>네이티브 스레드, 커널 스레드, 커널-레벨 스레드, OS-레벨 스레드로 불리기도 합니다.</li>
  <li>CPU에서 실제로 실행되는 단위이며 CPU 스케줄링의 단위가 OS 스레드입니다.</li>
  <li>OS 스레드의 컨텍스트 스위칭은 커널이 주도적으로 진행합니다. [유저모드 -&gt; 커널모드] -&gt; 커널코드 CPU에서 실행(CPU 리소스 사용) -&gt; [커널모드 -&gt; 유저모드]</li>
  <li>System call 유저모드는 System call을 통해 커널 모드로 진입하고, 커널코드를 실행시킬 수 있게 됩니다. 사용자 코드와 커널코드 모두 OS 스레드에서 실행됩니다. ㅎ</li>
  <li>A. OS는 가상의 코어를 4개라고 생각하기 때문에 각각의 코어의 OS 스레드를 2개씩 사용하여 8개의 스레드를 균등하게 배치할 수 있습니다.</li>
</ul>

<h3 id="user-thread">User Thread</h3>
<ul>
  <li>유저-레벨 스레드라고 불리며, 스레드 개념을 프로그래밍 레벨에서 추상화한 것을 의미합니다. OS와는 독립적으로 유저레벨에서 스케줄링되는 스레드입니다.</li>
  <li>유저 스레드가 CPU에서 실행되려면 OS 스레드와 반드시 연결돼야 합니다.</li>
  <li>Java에서 <code class="language-plaintext highlighter-rouge">Thread.start()</code>라는 코드를 통해 OS의 system call의 clone(리눅스의 경우)이라는 호출되고 OS level의 thread를 생성하여 연결됩니다.</li>
  <li>유저 스레드와 OS 스레드를 어떻게 연결시킬 것인가?</li>
</ul>

<p><strong>One-to-One Model</strong></p>
<ul>
  <li>시스템 콜을 통해 유저 스레드와 OS 레벨의 스레드를 1:1로 연결되는 모델로, 스케쥴링을 포함한 스레드 관리를 OS에 위임합니다.</li>
  <li>따라서, 커널 레벨에서 스레드가 아닌 코어를 할당하는 경우에도 같은 방식으로 작업이 진행됩니다.</li>
  <li>한 스레드가 블락되어도 다른 스레드는 잘 동작합니다.</li>
  <li>실행 방법에 따라 race condition이 발생할 확률이 높습니다.</li>
</ul>

<p><strong>Many-to-One Model</strong></p>
<ul>
  <li>여러 유저-레벨 스레드가 하나의 OS 스레드와 연결되는 경우입니다.</li>
  <li>커널이 개입하지 않기 때문에 유저 스레드 간 context switching 속도가 빠릅니다.</li>
  <li>배정되는 OS 스레드가 하나이기 때문에 멀티코어를 활용할 수 없습니다.</li>
  <li>한 스레드가 블락될 때 모든 스레드가 블락됩니다. (-&gt; non block I/O를 사용하기 됨)</li>
  <li>race condition이 발생할 확률이 낮습니다.</li>
</ul>

<p><strong>Many-toMany Model</strong></p>
<ul>
  <li>위의 두 모델의 장점을 합쳐 사용하는 경우입니다.</li>
  <li>유저 스레드 간에 스위칭이 빠르면서 멀티 코어를 활용하게 되고, 하나의 OS 스레드가 블락되더라도 다른 스레드를 사용할 수 있습니다.</li>
  <li>하지만 구현이 어렵다는 단점이 있습니다.</li>
</ul>

<h3 id="green-thread">Green Thread</h3>
<ul>
  <li>과거에는 자바의 초창기 스레딩 모델의 초창기 스레드 모델로, Many-to-One 모델의 스레드를 의미합니다.</li>
  <li>현재는 OS와는 독립적으로 유저 레벨에서 스케쥴링되는 스레드로, Many-to-One, Many-to-Many 모델을 사용하는 유저 스레드를 의미합니다.</li>
</ul>

<h3 id="kernel-thread">Kernel Thread</h3>
<ul>
  <li>OS 커널의 역할을 수행하는 스레드를 의미하기도 하지만, 커널 코드(시스템콜)를 실제로 실행하는 OS 커널의 역할을 담당하는 스레드로 해석할 수도 있습니다.</li>
</ul>

<h2 id="thread-pool">Thread Pool</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Thread per request model</code>: 하나의 쓰레드가 하나의 리퀘스트를 사용하는 방식입니다. 만약, 이 모델에서 요청마다 스레드를 새로 만들어서 처리하고 처리가 끝난 스레드는 버리는 식으로 동작한다면? 스레드 생성에 소요되는 시간 때문에 요청 처리가 오래 걸릴 것입니다.</li>
  <li>처리 속도보다 빠르게 요청이 늘어나는 경우, 스레드 수 증가에 따른 컨텍스트 스위칭 빈도 급증, CPU 오버헤드 증가와 같은 문제가 발생할 수 있습니다.</li>
  <li>위의 문제들을 해결하기 위해 스레드 풀이라는 개념이 등장합니다. 정해진 개수만큼의 스레드를 미리 생성하고, 들어오는 요청들을 서버 내부에서 관리하게 됩니다. (제한된 개수의 스레드를 운용하므로써 무제한으로 스레드가 생성되는 것을 방지합니다.)</li>
  <li>사용하는 경우
    <ul>
      <li>thread per request 모델의 task를 subtask로 나누어 동시에 처리하고 싶은 경우</li>
      <li>순서에 상관없이 동시 실행이 가능한 task를 처리하는 경우</li>
    </ul>
  </li>
</ul>

<h3 id="사용시-고려사항">사용시 고려사항</h3>
<p><strong>몇 개의 스레드를 만드는 것이 적절할까?</strong></p>
<ul>
  <li>CPU 코어 개수와 task의 성향(CPU-bound / I/O-bound)에 따라 다릅니다.
    <ul>
      <li>CPU-bound task의 경우: 코어 개수만큼 혹은 그보다 몇 개 더 많은 정도
코어개수보다 스레드를 아무리 만들어도 CPU 작업을 주로 하기 때문에 별로 의미가 없습니다. (CPU-bound: cpu를 많이 사용하는 태스크)</li>
      <li>I/O-bound task의 경우: 코어개수의 몇 배가 적당할지를 경험적으로 찾아야 합니다.</li>
    </ul>
  </li>
  <li>스레드 풀에서 실행될 task의 개수에 제한이 없다면, 스레드 풀 큐의 사이즈가 제한이 있는지 확인해야합니다.
    <ul>
      <li>만약, 제한이 없다면 큐에 계속해서 요청이 쌓일 것이고 이를 모두 해결할 수 없기 때문에 전체 시스템이 망가지는 경우가 발생할 수 있습니다.</li>
      <li>따라서, 제한을 두어 몇 개의 요청은 버리더라도 전체 시스템을 안전하게 하는 식으로 처리합니다.</li>
    </ul>
  </li>
</ul>

<h3 id="pool">Pool</h3>
<ul>
  <li>Thread Pool 외에도 Connection Pool, Process Pool이 있습니다.</li>
  <li>특히 파이썬에서는, Global Interpreter Lock이라는 개념 때문에, 동시에 여러 개의 쓰레드가 CPU에서는 실행될 수 없기 때문에 Process Pool을 사용해야 합니다.</li>
</ul>

<h2 id="유저모드-커널모드">유저모드, 커널모드</h2>
<ul>
  <li>우리가 개발하는 프로그램은 유저모드에서 실행됩니다.</li>
  <li>프로그램 실행 중, 인터럽트(interrupt)나 시스템 콜(system call)이 발생하면 커널모드에 진입합니다.</li>
  <li>커널모드로 진입 시, 다시 유저모드로 돌아와 작업할 수 있도록 하기 위해, 프로그램의 현재 CPU의 상태를 저장하는 작업도 함께 수행합니다.</li>
  <li>커널 모드에서는 커널이 인터럽트나 시스템 콜을 직접 처리합니다. 모든 처리가 완료되면 중단되었던 프로그램의 CPU 상태를 복원하고, 유저 모드에 실행권을 넘깁니다.</li>
</ul>

<h3 id="커널">커널</h3>
<ul>
  <li>운영체제의 핵심으로, 시스템의 전반을 관리/감독하는 역할을 합니다.</li>
  <li>하드웨어(device)와 관련된 작업을 직접 수행합니다.</li>
  <li>유저와 하드웨어 사이에서 안정적으로 시스템을 사용하도록 제어하기 위해 존재합니다.</li>
</ul>

<h3 id="인터럽트">인터럽트</h3>
<ul>
  <li>시스템에서 발생한 다양한 종류의 이벤트 혹은 이벤트를 알리는 메커니즘</li>
  <li>전원에 발생한 문제, I/O 작업 완료 시, timer가 측정하는 시간이 만료될 때 등의 종류가 있습니다.</li>
  <li>0으로 나누어질 때, 잘못된 메모리 공간에 접근을 시도할 때 -&gt; 프로그램 레벨에서 발생하는 인터럽트로, 보통 트랩이라고 불립니다.</li>
  <li>인터럽트 발생 시, CPU에서는 즉각적으로 커널코드를 커널 모드에서 실행합니다.</li>
</ul>

<h3 id="시스템콜">시스템콜</h3>
<ul>
  <li>프로그램이 OS 커널이 제공하는 서비스를 이용하고자 할 때 사용하는 기능입니다.</li>
  <li>프로세스/스레드 제어(생성/삭제) 관련, 파일 I/O 관련, 소켓 관련, 장치(device) 관련(키보드 인풋 등), 프로세스 통신 관련 등의 종류가 있습니다.</li>
</ul>

<h2 id="컨텍스트-스위칭">컨텍스트 스위칭</h2>
<ul>
  <li>CPU/코어에서 실행 중이던 프로세스가 다른 프로세스로, 스레드가 다른 스레드로 교체되는 것을 의미하며, 여러 프로그램을 동시에 실행시키기 위해 필요합니다.</li>
  <li>컨텍스트란 무엇인가? 프로세스 혹은 스레드의 상태로, CPU(레지스터들)나 메모리의 상태입니다.</li>
  <li>컨텍스트 스위칭은 언제 발생할까?
    <ul>
      <li>주어진 time slice(quantum)를 다 사용한 경우</li>
      <li>I/O 작업을 해야 하는 경우</li>
      <li>다른 리소스를 기다리는 경우</li>
    </ul>
  </li>
  <li>OS 커널(각종 리소스를 관리 및 감독하는 역할을 함)에 의해 컨텍스트 스위칭은 실행됩니다. (통제권을 커널이 가짐)</li>
  <li>프로세스 컨텍스트 스위칭과 스레드 컨텍스트 스위칭 두 종류가 있습니다. 둘 다 커널모드에서 실행되며, CPU의 레지스터 상태(프로그램이 어디까지 실행되었는지에 대한 정보를 저장)를 교체한다는 공통점이 있습니다.</li>
  <li>컨텍스트 스위칭이 미치는 간접적인 영향은 캐시가 오염된다는 것입니다. 일반적으로 프로그램이 실행되면, 메모리에 자주 접근하는 것을 피하기 위해 캐시를 사용하는데, 컨텍스트 스위칭 발생시 캐시에 있는 값이 오염될 수 있습니다.</li>
  <li>따라서, 몇몇 CPU 아키텍처는 프로세스 컨텍스트 스위칭이 발생할 때 캐시까지 비우기도 합니다.</li>
</ul>

<h3 id="프로세스-컨텍스트-스위칭">프로세스 컨텍스트 스위칭</h3>
<ul>
  <li>멀티 프로세스 작업의 경우, 서로 다른 프로그램이 서로 다른 메모리 주소를 가지므로, 가상 메모리 주소 체계가 다릅니다.</li>
  <li>따라서 가상 메모리 주소 관련 처리를 추가적으로 수행하기 때문에 쓰레드 컨텍스트 스위칭보다 느립니다. (참고: MMV, TLB를 비워줘야 함)</li>
</ul>

<h2 id="cpu-bound-io-bound">CPU bound, I/O bound</h2>
<ul>
  <li>CPU: 프로세스의 명령어를 해석하고 실행하는 장치입니다.</li>
  <li>IO: 파일을 읽고 쓰거나 네트워크의 어딘가에 있는 데이터를 주고받거나, 입출력 장치와 데이터를 주고받는 것을 의미합니다.</li>
  <li>버스트: 버스트란 어떤 현상이 짧은 시간 안에 집중적으로 일어나는 것입니다.</li>
  <li>CPU 버스트: 메모리에 올라가 있는 프로세스가 자신의 차례가 되어 CPU에서 실행되었을 때, 자신의 명령어가 CPU에서 한 번에 연속적으로 실행되는 시간을 의미합니다.</li>
  <li>I/O 버스트: 프로세스가 I/O 작업을 요청하고 그 결과를 기다리는 시간을 의미합니다.</li>
  <li>따라서, 프로세스는 CPU 버스트와 I/O 버스트의 연속적인 과정으로 볼 수 있습니다.</li>
</ul>

<h3 id="cpu-bound-프로세스">CPU bound 프로세스</h3>
<ul>
  <li>CPU 버스트가 많은 프로세스를 의미합니다.</li>
  <li>CPU 버스트가 많은 프로세스
    <ul>
      <li>동영상 편집 프로그램</li>
      <li>머신러닝 프로그램: 연산작업이 많기 때문에, CPU도 부족하여 GPU를 활용한 병렬처리 작업을 수행합니다.</li>
    </ul>
  </li>
</ul>

<h3 id="io-bound-프로세스">I/O bound 프로세스</h3>
<ul>
  <li>I/O 버스트가 많은 프로세스를 의미합니다.</li>
  <li>일반적인 백엔드 API 서버로, HTTP request를 받으면 DB 서버나 캐시 서버에 데이터를 요청하여 요청 데이터를 받은 후, 이를 가공하여 응답합니다.</li>
  <li>DB 서버 및 캐시 서버를 요청하는 작업이 I/O 작업입니다. 이는 CPU에서 명령을 수십 개 처리하는 것보다 시간이 오래 걸립니다.</li>
</ul>

<h3 id="적당한-코어-및-스레드-할당량">적당한 코어 및 스레드 할당량</h3>
<ul>
  <li>컨텍스트 스위칭과 연관이 있습니다. 스레드를 많이 만든다고 무조건 좋은 것이 아닙니다. 어떤 바운드이냐에 따라 전략을 다르게 가져가야 합니다.</li>
  <li>CPU bound 프로그램에서 적절한 스레드 수는 CPU의 수 + 1입니다. (Goetz)</li>
  <li>API 서버가 thread per request 방식이라면 스레드의 수를 미리 정해야 하는데, 이때 여러 상황을 고려하여 그 개수를 결정하는 것이 필요합니다.</li>
</ul>

<h2 id="참고">참고</h2>
<ul>
  <li><a href="https://youtu.be/vorIqiLM7jc?si=Dg18EAWVIsaatwHc">쉬운코드님 운영체제 - 스레드 종류</a></li>
  <li><a href="https://youtu.be/B4Of4UgLfWc?si=o8eit1DoM0_S-IRe">쉬운코드님 운영체제 - 스레드풀</a></li>
  <li><a href="https://youtu.be/Xh9Nt7y07FE?si=OtGfc4S82qOJ2U2d">쉬운코드님 운영체제 - 컨텍스트 스위칭</a></li>
</ul>]]></content><author><name>Yeham Kim</name></author><category term="Study" /><summary type="html"><![CDATA[컴퓨터의 구조 (코어와 스레드) OS kernel은 사용자 프로그램과 Memory, CPU, Device를 다루는 연결고리 역할을 합니다.]]></summary></entry><entry><title type="html">[Django] DRF에서 Viewset은 어떻게 사용할까?</title><link href="http://localhost:4000/strategy/django-strategy-view/" rel="alternate" type="text/html" title="[Django] DRF에서 Viewset은 어떻게 사용할까?" /><published>2023-08-29T00:05:07+09:00</published><updated>2023-08-29T00:05:07+09:00</updated><id>http://localhost:4000/strategy/django-strategy-view</id><content type="html" xml:base="http://localhost:4000/strategy/django-strategy-view/"><![CDATA[<h2 id="글을-작성하는-이유">글을 작성하는 이유</h2>
<ul>
  <li>Django의 ViewSet은 유저의 요청에 알맞은 반환값을 반환하도록 동작합니다.</li>
  <li>프레임워크 내부적으로 중복되는 부분을 최소화시키기 위해 웬만한 기능들이 구현되어 있기 때문에, 상황에 맞는 기능을 찾아서 적절히 사용하는 것이 중요합니다.</li>
  <li>따라서, ViewSet을 작성하는데 있어, 필수적인 기능과 유용한 기능들을 정리해 보고 상황에 맞게 참고하여 사용하기 위해 글을 작성합니다.</li>
</ul>

<h2 id="modelviewset-사용-전략">ModelViewSet 사용 전략</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">ModelViewSet</code>을 상속받아 ViewSet을 구현하게 되면, 클래스 변수로 아래와 같은 값들을 지정하며 좀 더 장고스럽게 구현할 수 있습니다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ProductViewSet</span><span class="p">(</span><span class="n">viewsets</span><span class="p">.</span><span class="n">ModelViewSet</span><span class="p">):</span>
    <span class="n">queryset</span> <span class="o">=</span> <span class="n">Product</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="n">is_deleted</span><span class="o">=</span><span class="sh">"</span><span class="s">N</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">serializer_class</span> <span class="o">=</span> <span class="n">ProductSerializer</span>
    <span class="n">permission_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">IsOwner</span><span class="p">,</span> <span class="p">]</span>
    <span class="n">lookup_field</span> <span class="o">=</span> <span class="sh">"</span><span class="s">id</span><span class="sh">"</span>
    <span class="n">filter_backends</span> <span class="o">=</span> <span class="p">[</span><span class="n">filters</span><span class="p">.</span><span class="n">SearchFilter</span><span class="p">,</span> <span class="p">]</span>
    <span class="n">search_fields</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">name</span><span class="sh">'</span><span class="p">,</span> <span class="p">]</span>
    <span class="n">pagination_class</span> <span class="o">=</span> <span class="n">ProductPagination</span>

    <span class="n">serializer_action_classes</span> <span class="o">=</span> <span class="p">{</span>
        <span class="sh">'</span><span class="s">list</span><span class="sh">'</span><span class="p">:</span> <span class="n">ProductSerializer</span><span class="p">,</span>
        <span class="sh">'</span><span class="s">create</span><span class="sh">'</span><span class="p">:</span> <span class="n">ProductCreateSerializer</span><span class="p">,</span>
        <span class="sh">'</span><span class="s">update</span><span class="sh">'</span><span class="p">:</span> <span class="n">ProductUpdateSerializer</span><span class="p">,</span>
        <span class="sh">'</span><span class="s">destroy</span><span class="sh">'</span><span class="p">:</span> <span class="n">ProductDeleteSerializer</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">def</span> <span class="nf">get_queryset</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">queryset</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="n">user_id</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">user</span><span class="p">.</span><span class="nb">id</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_serializer_class</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">serializer_action_classes</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">action</span><span class="p">]</span>
        <span class="nf">except </span><span class="p">(</span><span class="nb">KeyError</span><span class="p">,</span> <span class="nb">AttributeError</span><span class="p">):</span>
            <span class="k">return</span> <span class="nf">super</span><span class="p">().</span><span class="n">get_serializer_class</span>

    <span class="nd">@extend_schema</span><span class="p">(</span>
        <span class="n">request</span><span class="o">=</span><span class="n">ProductSerializer</span><span class="p">,</span>
        <span class="n">summary</span><span class="o">=</span><span class="sh">"</span><span class="s">상품 목록을 조회합니다.</span><span class="sh">"</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="sh">"""</span><span class="s">상품 목록을 페이지번호/페이지크기/검색결과에 따라 조회합니다.</span><span class="sh">"""</span><span class="p">,</span>
        <span class="n">tags</span><span class="o">=</span><span class="p">[</span><span class="sh">'</span><span class="s">상품</span><span class="sh">'</span><span class="p">],</span>
        <span class="n">parameters</span><span class="o">=</span><span class="n">PRODUCT_LIST_EXAMPLES</span><span class="p">,</span>
        <span class="n">responses</span><span class="o">=</span><span class="p">{</span>
            <span class="n">status</span><span class="p">.</span><span class="n">HTTP_200_OK</span><span class="p">:</span> <span class="n">ProductSerializer</span><span class="p">,</span>
            <span class="n">status</span><span class="p">.</span><span class="n">HTTP_403_FORBIDDEN</span><span class="p">:</span> <span class="bp">None</span>
        <span class="p">}</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">list</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">queryset</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">filter_queryset</span><span class="p">(</span><span class="n">queryset</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="nf">get_queryset</span><span class="p">())</span>
        <span class="n">page</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">paginate_queryset</span><span class="p">(</span><span class="n">queryset</span><span class="p">)</span>
        <span class="n">serializer</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">get_serializer</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">many</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="nc">Response</span><span class="p">(</span><span class="n">serializer</span><span class="p">.</span><span class="n">data</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="permissions">Permissions</h3>
<ul>
  <li>위 예시에서, <code class="language-plaintext highlighter-rouge">permission_dlasses</code>에 해당 ViewSet의 메서드를 사용하기 위한 권한을 나열합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">IsOwner</code>의 경우, custom permission으로 <code class="language-plaintext highlighter-rouge">rest_framwework.permissions</code>의 <code class="language-plaintext highlighter-rouge">BasicPermission</code>을 상속받아 구성합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">IsOwner</code>는 상품을 상세 수정(update 메서드)하거나 상세 조회(retrieve 메서드)하는 경우, 유저가 가지고 있는 상품이 맞는지 확인하는 권한입니다.</li>
  <li><code class="language-plaintext highlighter-rouge">get_permissions(self)</code> 메서드를 오버라이드 하면, 메서드에 따라 권한을 수정하여 사용할 수 있습니다.</li>
</ul>

<h3 id="queryset">Queryset</h3>
<ul>
  <li>일반적으로 api 메서드(<code class="language-plaintext highlighter-rouge">list</code>, <code class="language-plaintext highlighter-rouge">create</code>, <code class="language-plaintext highlighter-rouge">retrieve</code>, <code class="language-plaintext highlighter-rouge">update</code>, <code class="language-plaintext highlighter-rouge">delete</code>)들을 사용할 때는 해당 모델의 전체 값을 필요로 하는 경우가 거의 없습니다.</li>
  <li>Soft delete가 있어서 논리적 삭제되지 않는 경우를 불러온다든지, 활성화된 데이터만 가져온다던지 공통적으로 처리해야 하는 조건에 대한 처리를 <code class="language-plaintext highlighter-rouge">get_query_set(self)</code>에서 미리 해둘 수 있습니다.</li>
  <li><code class="language-plaintext highlighter-rouge">get_query_set</code>은 각각의 api 메서드 내부에서 사용되는 방식으로 <code class="language-plaintext highlighter-rouge">ModelViewSet</code>이 구현되어있기도 하고, 필요하면 <code class="language-plaintext highlighter-rouge">self</code>로 호출하여 사용할 수 있습니다.</li>
</ul>

<h3 id="parameters">Parameters</h3>
<ul>
  <li>Path parameter, Query parameter 등을 사용하게 되는 경우에 대한 처리도 미리 수행할 수 있습니다.</li>
</ul>

<p><strong>path parameter</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">lookup_field</code>는 <code class="language-plaintext highlighter-rouge">urlpatterns</code>에 입력된 <code class="language-plaintext highlighter-rouge">path("&lt;int:id&gt;/",...</code>의 값을 찾아 db의 field 값과 매칭시킵니다.</li>
</ul>

<p><strong>search: query parameter</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">filter_backends</code>의 <code class="language-plaintext highlighter-rouge">SearchFilter</code>와 <code class="language-plaintext highlighter-rouge">search_fields</code>를 위와 같이 설정하면, url query parameter로 입력되는 <code class="language-plaintext highlighter-rouge">?search=값</code> search에 해당하는 값을 해당 모델의 <code class="language-plaintext highlighter-rouge">name</code> 필드에서 <code class="language-plaintext highlighter-rouge">SearchFilter</code>의 방식으로 검색합니다.</li>
  <li>검색된 쿼리를 사용하려면 <code class="language-plaintext highlighter-rouge">list</code> 메서드 내부 구현된 바와 같이 <code class="language-plaintext highlighter-rouge">self.filter_queryset</code> 메서드를 호출하여 사용합니다.</li>
</ul>

<p><strong>page, page_size: query parameter</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">pagenation_class</code>를 통해 <code class="language-plaintext highlighter-rouge">page</code>, <code class="language-plaintext highlighter-rouge">page_size</code> 각 값에 따라 어떤 방식으로 조회할지 결정할 수 있습니다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">DEFAULT_PAGE</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">DEFAULT_PAGE_SIZE</span> <span class="o">=</span> <span class="mi">4</span>

<span class="k">class</span> <span class="nc">ProductPagination</span><span class="p">(</span><span class="n">PageNumberPagination</span><span class="p">):</span>
    <span class="n">page</span> <span class="o">=</span> <span class="n">DEFAULT_PAGE</span>
    <span class="n">page_size</span> <span class="o">=</span> <span class="n">DEFAULT_PAGE_SIZE</span>
    <span class="n">page_size_query_param</span> <span class="o">=</span> <span class="sh">'</span><span class="s">page_size</span><span class="sh">'</span>

    <span class="k">def</span> <span class="nf">paginate_queryset</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">queryset</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">view</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="nf">super</span><span class="p">().</span><span class="nf">paginate_queryset</span><span class="p">(</span><span class="n">queryset</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">view</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_paginated_response</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="sh">'</span><span class="s">links</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span>
                <span class="sh">'</span><span class="s">next</span><span class="sh">'</span><span class="p">:</span> <span class="n">self</span><span class="p">.</span><span class="nf">get_next_link</span><span class="p">(),</span>
                <span class="sh">'</span><span class="s">previous</span><span class="sh">'</span><span class="p">:</span> <span class="n">self</span><span class="p">.</span><span class="nf">get_previous_link</span><span class="p">()</span>
            <span class="p">},</span>
            <span class="sh">'</span><span class="s">num_pages</span><span class="sh">'</span><span class="p">:</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">page</span><span class="p">.</span><span class="n">paginator</span><span class="p">.</span><span class="n">num_pages</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)],</span>
            <span class="sh">'</span><span class="s">num</span><span class="sh">'</span><span class="p">:</span> <span class="n">self</span><span class="p">.</span><span class="n">page</span><span class="p">.</span><span class="n">number</span><span class="p">,</span>
            <span class="sh">'</span><span class="s">results</span><span class="sh">'</span><span class="p">:</span> <span class="n">data</span>
        <span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>위의 예시는, <code class="language-plaintext highlighter-rouge">ModelViewSet</code>의 <code class="language-plaintext highlighter-rouge">pagenation_class</code>에서 지정해준 커스텀 페이지네이션 클래스입니다.</li>
  <li>위와 같은 방식으로 페이지네이션된 queryset을 사용할 수도 있고, <code class="language-plaintext highlighter-rouge">self.page.paginator</code> 클래스가 가지고 있는 값을 제어할 수도 있습니다.</li>
</ul>

<h3 id="serializer">Serializer</h3>
<ul>
  <li>action마다 다른 serializer를 사용하기 때문에, <code class="language-plaintext highlighter-rouge">get_serializer_class</code> 메서드를 통해 그에 해당하는 serializer를 불러옵니다.</li>
  <li>내부적으로 보면, <code class="language-plaintext highlighter-rouge">ModelViewSet</code>은 <code class="language-plaintext highlighter-rouge">GenericViewSet</code>을 상속받고, <code class="language-plaintext highlighter-rouge">GenericViewSet</code> 내부에 <code class="language-plaintext highlighter-rouge">get_serializer</code>는 위에서 클래스 메서드로 지정해준 <code class="language-plaintext highlighter-rouge">get_serializer_class</code>의 클래스를 읽어옵니다.</li>
  <li><code class="language-plaintext highlighter-rouge">get_serializer</code>는 <code class="language-plaintext highlighter-rouge">DestroyModelMixin</code>을 제외한 모든 믹스인에서 사용되기 때문에 필수적으로 <code class="language-plaintext highlighter-rouge">serializer</code>를 지정해야합니다.</li>
</ul>

<hr />

<h2 id="generic-view의-동작방식">Generic view의 동작방식</h2>
<ul>
  <li>DRF 기본 클래스인 <code class="language-plaintext highlighter-rouge">APIView</code>에서는 사용자가 요청부터 응답까지의 구현을 처리할 수 있습니다.</li>
  <li>Generic view에서는 CRUD 패턴에 대한 구현을 미리 정해놓습니다.</li>
  <li>
    <p>generic view는 네 가지 속성을 통해 API 동작을 결정합니다.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  - authentication_classes: 요청자의 가입 및 로그인 여부를 식별합니다.
      - .get_authenticators(self)
  - permission_classes: API 요청에 대한 요청자의 권한을 검증합니다.
      - .get_permissions(self) 
  - queryset: 클래스 내부에서 사용하기 위한 기준이 되는 queryset을 설정합니다.
      - .get_queryset(self): 데이터를 정적으로(미리 데이터의 바운더리를 정해두고) 불러올 때 사용합니다.
      - .filter_queryset(self, queryset): 데이터를 동적으로(클라이언트의 요청에 따라 다른 값을 가져오도록) 불러올 때 사용합니다.
  - serializer_class: request와 response 스펙을 정의하는 serializer를 설정합니다.
      - .get_serializer_class(self)
      - .get_serializer_context(self)
      - .get_serializer(self, ...)
</code></pre></div>    </div>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">queryset</code>에서, soft-deleted 요소를 조회하면, <code class="language-plaintext highlighter-rouge">queryset = Item.objects.filter(is_deleted='N')</code>과 같이 처리합니다. (정적 필터 적용)</li>
      <li><code class="language-plaintext highlighter-rouge">filter_queryset</code>에서는 url의 query를 parsing 하여 object manager의 filter를 추가할 수 있습니다.</li>
    </ul>
  </li>
  <li>
    <p>Gneric API View에서, 기본적으로 설정한 예시는 다음과 같습니다.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1"># items/views/ItemView.py
</span>  <span class="kn">from</span> <span class="n">rest_framework.settings</span> <span class="kn">import</span> <span class="n">api_settings</span>
  <span class="kn">from</span> <span class="n">rest_framework.generics</span> <span class="kn">import</span> <span class="n">ListCreateAPIView</span>
  <span class="kn">from</span> <span class="n">items.serializers</span> <span class="kn">import</span> <span class="n">ItemSerializer</span><span class="p">,</span> <span class="n">ItemCreateSerializer</span>

  <span class="kn">from</span> <span class="n">rest_framework.settings</span> <span class="kn">import</span> <span class="n">api_settings</span>

  <span class="k">class</span> <span class="nc">ItemListCreateAPIView</span><span class="p">(</span><span class="n">ListCreateAPIView</span><span class="p">):</span>
      <span class="n">authentication_classes</span> <span class="o">=</span> <span class="n">api_settings</span><span class="p">.</span><span class="n">DEFAULT_AUTHENTICATION_CLASSES</span>
      <span class="n">permission_classes</span> <span class="o">=</span> <span class="n">api_settings</span><span class="p">.</span><span class="n">DEFAULT_PERMISSION_CLASSES</span>
      <span class="n">queryset</span><span class="o">=</span><span class="n">Item</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="n">is_deleted</span><span class="o">=</span><span class="sh">"</span><span class="s">N</span><span class="sh">"</span><span class="p">)</span>

      <span class="bp">...</span>
</code></pre></div>    </div>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1"># settings.py
</span>  <span class="bp">...</span>

  <span class="n">REST_FRAMEWORK</span> <span class="o">=</span> <span class="p">{</span>
      <span class="sh">"</span><span class="s">DEFAULT_AUTHENTICATION_CLASSES</span><span class="sh">"</span><span class="p">:</span> <span class="p">(</span>
          <span class="sh">"</span><span class="s">rest_framework_simplejwt.authentication.JWTAuthentication</span><span class="sh">"</span><span class="p">,</span>
      <span class="p">),</span>
      <span class="sh">"</span><span class="s">DEFAULT_PERMISSION_CLASSES</span><span class="sh">"</span><span class="p">:</span> <span class="p">[</span>
          <span class="sh">"</span><span class="s">rest_framework.permissions.IsAuthenticated</span><span class="sh">"</span><span class="p">,</span>
      <span class="p">],</span>
      <span class="sh">"</span><span class="s">DEFAULT_FILTER_BACKENDS</span><span class="sh">"</span><span class="p">:</span> <span class="p">(</span>
          <span class="sh">'</span><span class="s">django_filters.rest_framework.DjangoFilterBackend</span><span class="sh">'</span><span class="p">,</span>
      <span class="p">),</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>인증이나 권한의 경우, settings.py에 REST_FRAMEWORK에 값을 정의해 두고, 전역적으로 이를 사용할 수 있습니다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># views.py
</span>
<span class="kn">from</span> <span class="n">django.shortcuts</span> <span class="kn">import</span> <span class="n">get_object_or_404</span>
<span class="kn">from</span> <span class="n">rest_framework.generics</span> <span class="kn">import</span> <span class="n">ListCreateAPIView</span>
<span class="kn">from</span> <span class="n">items.serializers</span> <span class="kn">import</span> <span class="n">ItemSerializer</span><span class="p">,</span> <span class="n">ItemCreateSerializer</span>
<span class="kn">from</span> <span class="n">items.models</span> <span class="kn">import</span> <span class="n">Item</span><span class="p">,</span> <span class="n">Category</span>
<span class="kn">from</span> <span class="n">rest_framework.settings</span> <span class="kn">import</span> <span class="n">api_settings</span>

<span class="sh">'''</span><span class="s">
# 요구사항
아이템 생성
- 아이템 이름, 가격, 브랜드가 모두 같은 경우 생성을 막습니다.
- 상품의 금액이 10000원 이하인 경우 생성을 막습니다. 

아이템 조회
- soft deleted 되지 않은 상품들을 가져옵니다.
</span><span class="sh">'''</span>

<span class="k">class</span> <span class="nc">ItemListCreateAPIView</span><span class="p">(</span><span class="n">ListCreateAPIView</span><span class="p">):</span>
    <span class="n">allowed_method</span> <span class="o">=</span> <span class="p">[</span><span class="sh">"</span><span class="s">get</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">post</span><span class="sh">"</span><span class="p">]</span>
    <span class="n">authentication_classes</span> <span class="o">=</span> <span class="n">api_settings</span><span class="p">.</span><span class="n">DEFAULT_AUTHENTICATION_CLASSES</span>
    <span class="n">permission_classes</span> <span class="o">=</span> <span class="n">api_settings</span><span class="p">.</span><span class="n">DEFAULT_PERMISSION_CLASSES</span>
    <span class="n">queryset</span><span class="o">=</span><span class="n">Item</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="n">is_deleted</span><span class="o">=</span><span class="sh">"</span><span class="s">N</span><span class="sh">"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_queryset</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nf">super</span><span class="p">().</span><span class="nf">get_queryset</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_serializer_class</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">method</span> <span class="o">==</span> <span class="sh">'</span><span class="s">GET</span><span class="sh">'</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ItemSerializer</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">method</span> <span class="o">==</span> <span class="sh">'</span><span class="s">POST</span><span class="sh">'</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ItemCreateSerializer</span>
    
    <span class="k">def</span> <span class="nf">filter_queryset</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">queryset</span><span class="p">):</span>
        <span class="k">if</span> <span class="sh">'</span><span class="s">name</span><span class="sh">'</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">query_params</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">query_params</span><span class="p">[</span><span class="sh">'</span><span class="s">name</span><span class="sh">'</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">queryset</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="nc">Q</span><span class="p">(</span><span class="n">name__icontains</span><span class="o">=</span><span class="n">name</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">queryset</span>
    
    <span class="k">def</span> <span class="nf">get_serializer_context</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">method</span> <span class="o">==</span> <span class="sh">'</span><span class="s">POST</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">context</span> <span class="o">=</span> <span class="nf">super</span><span class="p">().</span><span class="nf">get_serializer_context</span><span class="p">()</span>
            <span class="n">context</span><span class="p">[</span><span class="sh">"</span><span class="s">cate_id</span><span class="sh">"</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">category</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">context</span>

    <span class="k">def</span> <span class="nf">category</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">reqData</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">data</span>
        <span class="k">if</span> <span class="sh">"</span><span class="s">cate_id</span><span class="sh">"</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">reqData</span><span class="p">:</span>
            <span class="k">return</span> 
        <span class="n">categoryObject</span> <span class="o">=</span> <span class="nf">get_object_or_404</span><span class="p">(</span><span class="n">Category</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="n">reqData</span><span class="p">[</span><span class="sh">"</span><span class="s">cate_id</span><span class="sh">"</span><span class="p">])</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">check_object_permissions</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">request</span><span class="p">,</span> <span class="n">categoryObject</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">categoryObject</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">queryset</code>: <code class="language-plaintext highlighter-rouge">get_queryset()</code> 메서드에서 불러올 쿼리셋을 정적으로 지정합니다.(외부에 의해 수정되지 않습니다.)</li>
  <li><code class="language-plaintext highlighter-rouge">filter_queryset</code>: url query parameter을 parsing 하여 <code class="language-plaintext highlighter-rouge">queryset</code>에 필터링을 추가합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">get_serializer_context</code>: POST 요청시, <code class="language-plaintext highlighter-rouge">create</code> serializer 동작 수행시 category instance가 필요하기 때문에, 해당 작업을 미리 해줄 수 있습니다.</li>
</ul>

<h3 id="참고">참고</h3>
<ul>
  <li><a href="https://velog.io/@mynghn/%EC%A0%9C%EB%84%A4%EB%A6%AD-%EB%B7%B0%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%B4-API-%EA%B5%AC%EC%B6%95%ED%95%98%EA%B8%B0">mynghn님 블로그</a></li>
</ul>]]></content><author><name>Yeham Kim</name></author><category term="Strategy" /><summary type="html"><![CDATA[글을 작성하는 이유 Django의 ViewSet은 유저의 요청에 알맞은 반환값을 반환하도록 동작합니다. 프레임워크 내부적으로 중복되는 부분을 최소화시키기 위해 웬만한 기능들이 구현되어 있기 때문에, 상황에 맞는 기능을 찾아서 적절히 사용하는 것이 중요합니다. 따라서, ViewSet을 작성하는데 있어, 필수적인 기능과 유용한 기능들을 정리해 보고 상황에 맞게 참고하여 사용하기 위해 글을 작성합니다.]]></summary></entry><entry><title type="html">[Django] permissions</title><link href="http://localhost:4000/strategy/study-django-strategy-permissions/" rel="alternate" type="text/html" title="[Django] permissions" /><published>2023-08-21T00:05:07+09:00</published><updated>2023-08-21T00:05:07+09:00</updated><id>http://localhost:4000/strategy/study-django-strategy-permissions</id><content type="html" xml:base="http://localhost:4000/strategy/study-django-strategy-permissions/"><![CDATA[<h3 id="글을-작성한-계기">글을 작성한 계기</h3>
<ul>
  <li>최근 과제전형을 보며, 백오피스로 주로 사용하는 Django에서 권한 관리에 대한 중요성을 많이 느끼게 되었습니다.</li>
  <li>ViewSet의 메서드를 사용할 때 Global Permission을 적용시켜야 하는지, Object-level Permission을 적용시켜야하는지 등 기본에 충실해서 학습해야함을 느꼈습니다.</li>
  <li>아래 내용들은 단순히 DRF 문서의 번역이 아닌, 실제 사용하며 분석한 내용과 사용 전략이 포함되어있습니다.</li>
</ul>

<h2 id="django-permissions">Django Permissions</h2>
<ul>
  <li>ModelViewSet등 APIView 기반의 뷰를 사용하기 위해 권한이 있는 사용자만 사용할 수 있도록 제한해야하는 경우가 있습니다.</li>
</ul>

<h3 id="기본적인-형태">기본적인 형태</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">UserViewSet</span><span class="p">(</span><span class="n">viewsets</span><span class="p">.</span><span class="n">ModelViewSet</span><span class="p">):</span>
    <span class="n">serializer_class</span> <span class="o">=</span> <span class="n">UserSerializer</span>
    <span class="n">queryset</span> <span class="o">=</span> <span class="n">User</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nf">all</span><span class="p">()</span>
    <span class="c1"># permission_classes = [IsAccountAdminOrReadOnly]
</span>
    <span class="k">def</span> <span class="nf">get_permissions</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">action</span> <span class="o">==</span> <span class="sh">'</span><span class="s">list</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">permission_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">IsAuthenticated</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">permission_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">IsAdminUser</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="nf">permission</span><span class="p">()</span> <span class="k">for</span> <span class="n">permission</span> <span class="ow">in</span> <span class="n">permission_classes</span><span class="p">]</span>
</code></pre></div></div>
<ul>
  <li>ViewSet 내의 모든 메서드에 공통적인 Permission Class를 적용하기 위해서는 ViewSet의 클래스 변수로 처리합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">permission_classes</code>에 custom permission 클래스들을 추가하여 원하는 권한에 해당하는 사용자만 메서드를 이용할 수 있도록 전처리할 수 있습니다.</li>
  <li>이 때, ViewSet의 클래스 메서드인 <code class="language-plaintext highlighter-rouge">get_queryset</code>는 필수적입니다.</li>
  <li>method에 따라 적용하는 권한이 변경된다면, <code class="language-plaintext highlighter-rouge">get_permissions</code> 메서드를 이용합니다.</li>
</ul>

<h3 id="custom-permission-class">Custom Permission Class</h3>
<ul>
  <li>DRF에서 제공하는 <code class="language-plaintext highlighter-rouge">BasePermission</code>를 상속받는 커스텀 Permission은 아래와 같은 형태를 가지며, <code class="language-plaintext highlighter-rouge">has_permission</code> 또는 <code class="language-plaintext highlighter-rouge">has_object_permission</code>를 override하여 사용합니다.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">BasePermission</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">BasePermissionMetaclass</span><span class="p">):</span>
      <span class="k">def</span> <span class="nf">has_permission</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">view</span><span class="p">):</span>
          <span class="k">return</span> <span class="bp">True</span>

      <span class="k">def</span> <span class="nf">has_object_permission</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
          <span class="k">return</span> <span class="bp">True</span>

  <span class="n">SAFE_METHODS</span> <span class="o">=</span> <span class="p">(</span><span class="sh">'</span><span class="s">GET</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">HEAD</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">OPTIONS</span><span class="sh">'</span><span class="p">)</span>
  <span class="k">class</span> <span class="nc">ReadOnly</span><span class="p">(</span><span class="n">BasePermission</span><span class="p">):</span>
      <span class="k">def</span> <span class="nf">has_permission</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">view</span><span class="p">):</span>
          <span class="k">return</span> <span class="n">request</span><span class="p">.</span><span class="n">method</span> <span class="ow">in</span> <span class="n">SAFE_METHODS</span>

  <span class="k">class</span> <span class="nc">IsOwner</span><span class="p">(</span><span class="n">BasePermission</span><span class="p">):</span>
      <span class="k">def</span> <span class="nf">has_permission</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">view</span><span class="p">):</span>
          <span class="k">return</span> <span class="n">request</span><span class="p">.</span><span class="n">method</span> <span class="ow">in</span> <span class="n">SAFE_METHODS</span>

      <span class="k">def</span> <span class="nf">has_object_permission</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
          <span class="k">return</span> <span class="n">obj</span><span class="p">.</span><span class="n">owner</span> <span class="o">==</span> <span class="n">request</span><span class="p">.</span><span class="n">user</span>
</code></pre></div>    </div>
  </li>
  <li>권한이 있으면 True를, 아니면 False를 반환하도록 설계합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">has_object_permission</code>는 <code class="language-plaintext highlighter-rouge">has_permission</code> 검사를 통과한 이 후에 실행됩니다.</li>
  <li><code class="language-plaintext highlighter-rouge">ModelViewSet</code>이 상속받는 <code class="language-plaintext highlighter-rouge">GenericAPIView</code>에 <code class="language-plaintext highlighter-rouge">get_object</code> 메서드 내부에 <code class="language-plaintext highlighter-rouge">self.check_object_permissions</code>는 해당 object가 지정해둔 permission에 따라 권한을 갖는지를 판단합니다.</li>
  <li>Django의 mixins 모듈을 살펴보면, <code class="language-plaintext highlighter-rouge">get_object</code> 메서드를 사용하는 믹스인은 detail 관련 <code class="language-plaintext highlighter-rouge">Retrieve</code>(조회), <code class="language-plaintext highlighter-rouge">Update</code>(수정), <code class="language-plaintext highlighter-rouge">Destroy</code>(삭제) 모듈에서 사용하게 되며, 이 때 object-level Permission을 확인합니다.</li>
</ul>]]></content><author><name>Yeham Kim</name></author><category term="Strategy" /><summary type="html"><![CDATA[글을 작성한 계기 최근 과제전형을 보며, 백오피스로 주로 사용하는 Django에서 권한 관리에 대한 중요성을 많이 느끼게 되었습니다. ViewSet의 메서드를 사용할 때 Global Permission을 적용시켜야 하는지, Object-level Permission을 적용시켜야하는지 등 기본에 충실해서 학습해야함을 느꼈습니다. 아래 내용들은 단순히 DRF 문서의 번역이 아닌, 실제 사용하며 분석한 내용과 사용 전략이 포함되어있습니다.]]></summary></entry></feed>