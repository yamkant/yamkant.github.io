<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-08-30T15:45:04+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Yam’s Dev Logs</title><subtitle>An amazing website.</subtitle><author><name>Yeham Kim</name></author><entry><title type="html">[Django] DRF에서 Viewset은 어떻게 사용할까?</title><link href="http://localhost:4000/strategy/django-strategy-view/" rel="alternate" type="text/html" title="[Django] DRF에서 Viewset은 어떻게 사용할까?" /><published>2023-08-29T00:05:07+09:00</published><updated>2023-08-29T00:05:07+09:00</updated><id>http://localhost:4000/strategy/django-strategy-view</id><content type="html" xml:base="http://localhost:4000/strategy/django-strategy-view/"><![CDATA[<h2 id="글을-작성하는-이유">글을 작성하는 이유</h2>
<ul>
  <li>Django의 ViewSet은 유저의 요청에 알맞은 반환값을 반환하도록 동작합니다.</li>
  <li>프레임워크 내부적으로 중복되는 부분을 최소화시키기 위해 웬만한 기능들이 구현되어 있기 때문에, 상황에 맞는 기능을 찾아서 적절히 사용하는 것이 중요합니다.</li>
  <li>따라서, ViewSet을 작성하는데 있어, 필수적인 기능과 유용한 기능들을 정리해 보고 상황에 맞게 참고하여 사용하기 위해 글을 작성합니다.</li>
</ul>

<h2 id="modelviewset-사용-전략">ModelViewSet 사용 전략</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">ModelViewSet</code>을 상속받아 ViewSet을 구현하게 되면, 클래스 변수로 아래와 같은 값들을 지정하며 좀 더 장고스럽게 구현할 수 있습니다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ProductViewSet</span><span class="p">(</span><span class="n">viewsets</span><span class="p">.</span><span class="n">ModelViewSet</span><span class="p">):</span>
    <span class="n">queryset</span> <span class="o">=</span> <span class="n">Product</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="n">is_deleted</span><span class="o">=</span><span class="sh">"</span><span class="s">N</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">serializer_class</span> <span class="o">=</span> <span class="n">ProductSerializer</span>
    <span class="n">permission_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">IsOwner</span><span class="p">,</span> <span class="p">]</span>
    <span class="n">lookup_field</span> <span class="o">=</span> <span class="sh">"</span><span class="s">id</span><span class="sh">"</span>
    <span class="n">filter_backends</span> <span class="o">=</span> <span class="p">[</span><span class="n">filters</span><span class="p">.</span><span class="n">SearchFilter</span><span class="p">,</span> <span class="p">]</span>
    <span class="n">search_fields</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">name</span><span class="sh">'</span><span class="p">,</span> <span class="p">]</span>
    <span class="n">pagination_class</span> <span class="o">=</span> <span class="n">ProductPagination</span>

    <span class="n">serializer_action_classes</span> <span class="o">=</span> <span class="p">{</span>
        <span class="sh">'</span><span class="s">list</span><span class="sh">'</span><span class="p">:</span> <span class="n">ProductSerializer</span><span class="p">,</span>
        <span class="sh">'</span><span class="s">create</span><span class="sh">'</span><span class="p">:</span> <span class="n">ProductCreateSerializer</span><span class="p">,</span>
        <span class="sh">'</span><span class="s">update</span><span class="sh">'</span><span class="p">:</span> <span class="n">ProductUpdateSerializer</span><span class="p">,</span>
        <span class="sh">'</span><span class="s">destroy</span><span class="sh">'</span><span class="p">:</span> <span class="n">ProductDeleteSerializer</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">def</span> <span class="nf">get_queryset</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">queryset</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="n">user_id</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">user</span><span class="p">.</span><span class="nb">id</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_serializer_class</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">serializer_action_classes</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">action</span><span class="p">]</span>
        <span class="nf">except </span><span class="p">(</span><span class="nb">KeyError</span><span class="p">,</span> <span class="nb">AttributeError</span><span class="p">):</span>
            <span class="k">return</span> <span class="nf">super</span><span class="p">().</span><span class="n">get_serializer_class</span>

    <span class="nd">@extend_schema</span><span class="p">(</span>
        <span class="n">request</span><span class="o">=</span><span class="n">ProductSerializer</span><span class="p">,</span>
        <span class="n">summary</span><span class="o">=</span><span class="sh">"</span><span class="s">상품 목록을 조회합니다.</span><span class="sh">"</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="sh">"""</span><span class="s">상품 목록을 페이지번호/페이지크기/검색결과에 따라 조회합니다.</span><span class="sh">"""</span><span class="p">,</span>
        <span class="n">tags</span><span class="o">=</span><span class="p">[</span><span class="sh">'</span><span class="s">상품</span><span class="sh">'</span><span class="p">],</span>
        <span class="n">parameters</span><span class="o">=</span><span class="n">PRODUCT_LIST_EXAMPLES</span><span class="p">,</span>
        <span class="n">responses</span><span class="o">=</span><span class="p">{</span>
            <span class="n">status</span><span class="p">.</span><span class="n">HTTP_200_OK</span><span class="p">:</span> <span class="n">ProductSerializer</span><span class="p">,</span>
            <span class="n">status</span><span class="p">.</span><span class="n">HTTP_403_FORBIDDEN</span><span class="p">:</span> <span class="bp">None</span>
        <span class="p">}</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">list</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">queryset</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">filter_queryset</span><span class="p">(</span><span class="n">queryset</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="nf">get_queryset</span><span class="p">())</span>
        <span class="n">page</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">paginate_queryset</span><span class="p">(</span><span class="n">queryset</span><span class="p">)</span>
        <span class="n">serializer</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">get_serializer</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">many</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="nc">Response</span><span class="p">(</span><span class="n">serializer</span><span class="p">.</span><span class="n">data</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="permissions">Permissions</h3>
<ul>
  <li>위 예시에서, <code class="language-plaintext highlighter-rouge">permission_dlasses</code>에 해당 ViewSet의 메서드를 사용하기 위한 권한을 나열합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">IsOwner</code>의 경우, custom permission으로 <code class="language-plaintext highlighter-rouge">rest_framwework.permissions</code>의 <code class="language-plaintext highlighter-rouge">BasicPermission</code>을 상속받아 구성합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">IsOwner</code>는 상품을 상세 수정(update 메서드)하거나 상세 조회(retrieve 메서드)하는 경우, 유저가 가지고 있는 상품이 맞는지 확인하는 권한입니다.</li>
  <li><code class="language-plaintext highlighter-rouge">get_permissions(self)</code> 메서드를 오버라이드 하면, 메서드에 따라 권한을 수정하여 사용할 수 있습니다.</li>
</ul>

<h3 id="queryset">Queryset</h3>
<ul>
  <li>일반적으로 api 메서드(<code class="language-plaintext highlighter-rouge">list</code>, <code class="language-plaintext highlighter-rouge">create</code>, <code class="language-plaintext highlighter-rouge">retrieve</code>, <code class="language-plaintext highlighter-rouge">update</code>, <code class="language-plaintext highlighter-rouge">delete</code>)들을 사용할 때는 해당 모델의 전체 값을 필요로 하는 경우가 거의 없습니다.</li>
  <li>Soft delete가 있어서 논리적 삭제되지 않는 경우를 불러온다든지, 활성화된 데이터만 가져온다던지 공통적으로 처리해야 하는 조건에 대한 처리를 <code class="language-plaintext highlighter-rouge">get_query_set(self)</code>에서 미리 해둘 수 있습니다.</li>
  <li><code class="language-plaintext highlighter-rouge">get_query_set</code>은 각각의 api 메서드 내부에서 사용되는 방식으로 <code class="language-plaintext highlighter-rouge">ModelViewSet</code>이 구현되어있기도 하고, 필요하면 <code class="language-plaintext highlighter-rouge">self</code>로 호출하여 사용할 수 있습니다.</li>
</ul>

<h3 id="parameters">Parameters</h3>
<ul>
  <li>Path parameter, Query parameter 등을 사용하게 되는 경우에 대한 처리도 미리 수행할 수 있습니다.</li>
</ul>

<p><strong>path parameter</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">lookup_field</code>는 <code class="language-plaintext highlighter-rouge">urlpatterns</code>에 입력된 <code class="language-plaintext highlighter-rouge">path("&lt;int:id&gt;/",...</code>의 값을 찾아 db의 field 값과 매칭시킵니다.</li>
</ul>

<p><strong>search: query parameter</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">filter_backends</code>의 <code class="language-plaintext highlighter-rouge">SearchFilter</code>와 <code class="language-plaintext highlighter-rouge">search_fields</code>를 위와 같이 설정하면, url query parameter로 입력되는 <code class="language-plaintext highlighter-rouge">?search=값</code> search에 해당하는 값을 해당 모델의 <code class="language-plaintext highlighter-rouge">name</code> 필드에서 <code class="language-plaintext highlighter-rouge">SearchFilter</code>의 방식으로 검색합니다.</li>
  <li>검색된 쿼리를 사용하려면 <code class="language-plaintext highlighter-rouge">list</code> 메서드 내부 구현된 바와 같이 <code class="language-plaintext highlighter-rouge">self.filter_queryset</code> 메서드를 호출하여 사용합니다.</li>
</ul>

<p><strong>page, page_size: query parameter</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">pagenation_class</code>를 통해 <code class="language-plaintext highlighter-rouge">page</code>, <code class="language-plaintext highlighter-rouge">page_size</code> 각 값에 따라 어떤 방식으로 조회할지 결정할 수 있습니다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">DEFAULT_PAGE</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">DEFAULT_PAGE_SIZE</span> <span class="o">=</span> <span class="mi">4</span>

<span class="k">class</span> <span class="nc">ProductPagination</span><span class="p">(</span><span class="n">PageNumberPagination</span><span class="p">):</span>
    <span class="n">page</span> <span class="o">=</span> <span class="n">DEFAULT_PAGE</span>
    <span class="n">page_size</span> <span class="o">=</span> <span class="n">DEFAULT_PAGE_SIZE</span>
    <span class="n">page_size_query_param</span> <span class="o">=</span> <span class="sh">'</span><span class="s">page_size</span><span class="sh">'</span>

    <span class="k">def</span> <span class="nf">paginate_queryset</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">queryset</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">view</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="nf">super</span><span class="p">().</span><span class="nf">paginate_queryset</span><span class="p">(</span><span class="n">queryset</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">view</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_paginated_response</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="sh">'</span><span class="s">links</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span>
                <span class="sh">'</span><span class="s">next</span><span class="sh">'</span><span class="p">:</span> <span class="n">self</span><span class="p">.</span><span class="nf">get_next_link</span><span class="p">(),</span>
                <span class="sh">'</span><span class="s">previous</span><span class="sh">'</span><span class="p">:</span> <span class="n">self</span><span class="p">.</span><span class="nf">get_previous_link</span><span class="p">()</span>
            <span class="p">},</span>
            <span class="sh">'</span><span class="s">num_pages</span><span class="sh">'</span><span class="p">:</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">page</span><span class="p">.</span><span class="n">paginator</span><span class="p">.</span><span class="n">num_pages</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)],</span>
            <span class="sh">'</span><span class="s">num</span><span class="sh">'</span><span class="p">:</span> <span class="n">self</span><span class="p">.</span><span class="n">page</span><span class="p">.</span><span class="n">number</span><span class="p">,</span>
            <span class="sh">'</span><span class="s">results</span><span class="sh">'</span><span class="p">:</span> <span class="n">data</span>
        <span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>위의 예시는, <code class="language-plaintext highlighter-rouge">ModelViewSet</code>의 <code class="language-plaintext highlighter-rouge">pagenation_class</code>에서 지정해준 커스텀 페이지네이션 클래스입니다.</li>
  <li>위와 같은 방식으로 페이지네이션된 queryset을 사용할 수도 있고, <code class="language-plaintext highlighter-rouge">self.page.paginator</code> 클래스가 가지고 있는 값을 제어할 수도 있습니다.</li>
</ul>

<h3 id="serializer">Serializer</h3>
<ul>
  <li>action마다 다른 serializer를 사용하기 때문에, <code class="language-plaintext highlighter-rouge">get_serializer_class</code> 메서드를 통해 그에 해당하는 serializer를 불러옵니다.</li>
  <li>내부적으로 보면, <code class="language-plaintext highlighter-rouge">ModelViewSet</code>은 <code class="language-plaintext highlighter-rouge">GenericViewSet</code>을 상속받고, <code class="language-plaintext highlighter-rouge">GenericViewSet</code> 내부에 <code class="language-plaintext highlighter-rouge">get_serializer</code>는 위에서 클래스 메서드로 지정해준 <code class="language-plaintext highlighter-rouge">get_serializer_class</code>의 클래스를 읽어옵니다.</li>
  <li><code class="language-plaintext highlighter-rouge">get_serializer</code>는 <code class="language-plaintext highlighter-rouge">DestroyModelMixin</code>을 제외한 모든 믹스인에서 사용되기 때문에 필수적으로 <code class="language-plaintext highlighter-rouge">serializer</code>를 지정해야합니다.</li>
</ul>

<hr />

<h2 id="generic-view의-동작방식">Generic view의 동작방식</h2>
<ul>
  <li>DRF 기본 클래스인 <code class="language-plaintext highlighter-rouge">APIView</code>에서는 사용자가 요청부터 응답까지의 구현을 처리할 수 있습니다.</li>
  <li>Generic view에서는 CRUD 패턴에 대한 구현을 미리 정해놓습니다.</li>
  <li>
    <p>generic view는 네 가지 속성을 통해 API 동작을 결정합니다.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  - authentication_classes: 요청자의 가입 및 로그인 여부를 식별합니다.
      - .get_authenticators(self)
  - permission_classes: API 요청에 대한 요청자의 권한을 검증합니다.
      - .get_permissions(self) 
  - queryset: 클래스 내부에서 사용하기 위한 기준이 되는 queryset을 설정합니다.
      - .get_queryset(self): 데이터를 정적으로(미리 데이터의 바운더리를 정해두고) 불러올 때 사용합니다.
      - .filter_queryset(self, queryset): 데이터를 동적으로(클라이언트의 요청에 따라 다른 값을 가져오도록) 불러올 때 사용합니다.
  - serializer_class: request와 response 스펙을 정의하는 serializer를 설정합니다.
      - .get_serializer_class(self)
      - .get_serializer_context(self)
      - .get_serializer(self, ...)
</code></pre></div>    </div>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">queryset</code>에서, soft-deleted 요소를 조회하면, <code class="language-plaintext highlighter-rouge">queryset = Item.objects.filter(is_deleted='N')</code>과 같이 처리합니다. (정적 필터 적용)</li>
      <li><code class="language-plaintext highlighter-rouge">filter_queryset</code>에서는 url의 query를 parsing 하여 object manager의 filter를 추가할 수 있습니다.</li>
    </ul>
  </li>
  <li>
    <p>Gneric API View에서, 기본적으로 설정한 예시는 다음과 같습니다.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1"># items/views/ItemView.py
</span>  <span class="kn">from</span> <span class="n">rest_framework.settings</span> <span class="kn">import</span> <span class="n">api_settings</span>
  <span class="kn">from</span> <span class="n">rest_framework.generics</span> <span class="kn">import</span> <span class="n">ListCreateAPIView</span>
  <span class="kn">from</span> <span class="n">items.serializers</span> <span class="kn">import</span> <span class="n">ItemSerializer</span><span class="p">,</span> <span class="n">ItemCreateSerializer</span>

  <span class="kn">from</span> <span class="n">rest_framework.settings</span> <span class="kn">import</span> <span class="n">api_settings</span>

  <span class="k">class</span> <span class="nc">ItemListCreateAPIView</span><span class="p">(</span><span class="n">ListCreateAPIView</span><span class="p">):</span>
      <span class="n">authentication_classes</span> <span class="o">=</span> <span class="n">api_settings</span><span class="p">.</span><span class="n">DEFAULT_AUTHENTICATION_CLASSES</span>
      <span class="n">permission_classes</span> <span class="o">=</span> <span class="n">api_settings</span><span class="p">.</span><span class="n">DEFAULT_PERMISSION_CLASSES</span>
      <span class="n">queryset</span><span class="o">=</span><span class="n">Item</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="n">is_deleted</span><span class="o">=</span><span class="sh">"</span><span class="s">N</span><span class="sh">"</span><span class="p">)</span>

      <span class="bp">...</span>
</code></pre></div>    </div>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1"># settings.py
</span>  <span class="bp">...</span>

  <span class="n">REST_FRAMEWORK</span> <span class="o">=</span> <span class="p">{</span>
      <span class="sh">"</span><span class="s">DEFAULT_AUTHENTICATION_CLASSES</span><span class="sh">"</span><span class="p">:</span> <span class="p">(</span>
          <span class="sh">"</span><span class="s">rest_framework_simplejwt.authentication.JWTAuthentication</span><span class="sh">"</span><span class="p">,</span>
      <span class="p">),</span>
      <span class="sh">"</span><span class="s">DEFAULT_PERMISSION_CLASSES</span><span class="sh">"</span><span class="p">:</span> <span class="p">[</span>
          <span class="sh">"</span><span class="s">rest_framework.permissions.IsAuthenticated</span><span class="sh">"</span><span class="p">,</span>
      <span class="p">],</span>
      <span class="sh">"</span><span class="s">DEFAULT_FILTER_BACKENDS</span><span class="sh">"</span><span class="p">:</span> <span class="p">(</span>
          <span class="sh">'</span><span class="s">django_filters.rest_framework.DjangoFilterBackend</span><span class="sh">'</span><span class="p">,</span>
      <span class="p">),</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>인증이나 권한의 경우, settings.py에 REST_FRAMEWORK에 값을 정의해 두고, 전역적으로 이를 사용할 수 있습니다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># views.py
</span>
<span class="kn">from</span> <span class="n">django.shortcuts</span> <span class="kn">import</span> <span class="n">get_object_or_404</span>
<span class="kn">from</span> <span class="n">rest_framework.generics</span> <span class="kn">import</span> <span class="n">ListCreateAPIView</span>
<span class="kn">from</span> <span class="n">items.serializers</span> <span class="kn">import</span> <span class="n">ItemSerializer</span><span class="p">,</span> <span class="n">ItemCreateSerializer</span>
<span class="kn">from</span> <span class="n">items.models</span> <span class="kn">import</span> <span class="n">Item</span><span class="p">,</span> <span class="n">Category</span>
<span class="kn">from</span> <span class="n">rest_framework.settings</span> <span class="kn">import</span> <span class="n">api_settings</span>

<span class="sh">'''</span><span class="s">
# 요구사항
아이템 생성
- 아이템 이름, 가격, 브랜드가 모두 같은 경우 생성을 막습니다.
- 상품의 금액이 10000원 이하인 경우 생성을 막습니다. 

아이템 조회
- soft deleted 되지 않은 상품들을 가져옵니다.
</span><span class="sh">'''</span>

<span class="k">class</span> <span class="nc">ItemListCreateAPIView</span><span class="p">(</span><span class="n">ListCreateAPIView</span><span class="p">):</span>
    <span class="n">allowed_method</span> <span class="o">=</span> <span class="p">[</span><span class="sh">"</span><span class="s">get</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">post</span><span class="sh">"</span><span class="p">]</span>
    <span class="n">authentication_classes</span> <span class="o">=</span> <span class="n">api_settings</span><span class="p">.</span><span class="n">DEFAULT_AUTHENTICATION_CLASSES</span>
    <span class="n">permission_classes</span> <span class="o">=</span> <span class="n">api_settings</span><span class="p">.</span><span class="n">DEFAULT_PERMISSION_CLASSES</span>
    <span class="n">queryset</span><span class="o">=</span><span class="n">Item</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="n">is_deleted</span><span class="o">=</span><span class="sh">"</span><span class="s">N</span><span class="sh">"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_queryset</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nf">super</span><span class="p">().</span><span class="nf">get_queryset</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_serializer_class</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">method</span> <span class="o">==</span> <span class="sh">'</span><span class="s">GET</span><span class="sh">'</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ItemSerializer</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">method</span> <span class="o">==</span> <span class="sh">'</span><span class="s">POST</span><span class="sh">'</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ItemCreateSerializer</span>
    
    <span class="k">def</span> <span class="nf">filter_queryset</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">queryset</span><span class="p">):</span>
        <span class="k">if</span> <span class="sh">'</span><span class="s">name</span><span class="sh">'</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">query_params</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">query_params</span><span class="p">[</span><span class="sh">'</span><span class="s">name</span><span class="sh">'</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">queryset</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="nc">Q</span><span class="p">(</span><span class="n">name__icontains</span><span class="o">=</span><span class="n">name</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">queryset</span>
    
    <span class="k">def</span> <span class="nf">get_serializer_context</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">method</span> <span class="o">==</span> <span class="sh">'</span><span class="s">POST</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">context</span> <span class="o">=</span> <span class="nf">super</span><span class="p">().</span><span class="nf">get_serializer_context</span><span class="p">()</span>
            <span class="n">context</span><span class="p">[</span><span class="sh">"</span><span class="s">cate_id</span><span class="sh">"</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">category</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">context</span>

    <span class="k">def</span> <span class="nf">category</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">reqData</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">data</span>
        <span class="k">if</span> <span class="sh">"</span><span class="s">cate_id</span><span class="sh">"</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">reqData</span><span class="p">:</span>
            <span class="k">return</span> 
        <span class="n">categoryObject</span> <span class="o">=</span> <span class="nf">get_object_or_404</span><span class="p">(</span><span class="n">Category</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="n">reqData</span><span class="p">[</span><span class="sh">"</span><span class="s">cate_id</span><span class="sh">"</span><span class="p">])</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">check_object_permissions</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">request</span><span class="p">,</span> <span class="n">categoryObject</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">categoryObject</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">queryset</code>: <code class="language-plaintext highlighter-rouge">get_queryset()</code> 메서드에서 불러올 쿼리셋을 정적으로 지정합니다.(외부에 의해 수정되지 않습니다.)</li>
  <li><code class="language-plaintext highlighter-rouge">filter_queryset</code>: url query parameter을 parsing 하여 <code class="language-plaintext highlighter-rouge">queryset</code>에 필터링을 추가합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">get_serializer_context</code>: POST 요청시, <code class="language-plaintext highlighter-rouge">create</code> serializer 동작 수행시 category instance가 필요하기 때문에, 해당 작업을 미리 해줄 수 있습니다.</li>
</ul>

<h3 id="참고">참고</h3>
<ul>
  <li><a href="https://velog.io/@mynghn/%EC%A0%9C%EB%84%A4%EB%A6%AD-%EB%B7%B0%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%B4-API-%EA%B5%AC%EC%B6%95%ED%95%98%EA%B8%B0">mynghn님 블로그</a></li>
</ul>]]></content><author><name>Yeham Kim</name></author><category term="Strategy" /><summary type="html"><![CDATA[글을 작성하는 이유 Django의 ViewSet은 유저의 요청에 알맞은 반환값을 반환하도록 동작합니다. 프레임워크 내부적으로 중복되는 부분을 최소화시키기 위해 웬만한 기능들이 구현되어 있기 때문에, 상황에 맞는 기능을 찾아서 적절히 사용하는 것이 중요합니다. 따라서, ViewSet을 작성하는데 있어, 필수적인 기능과 유용한 기능들을 정리해 보고 상황에 맞게 참고하여 사용하기 위해 글을 작성합니다.]]></summary></entry><entry><title type="html">[Django] 테스트는 어떻게 수행할까? (query count 포함)</title><link href="http://localhost:4000/strategy/django-strategy-test/" rel="alternate" type="text/html" title="[Django] 테스트는 어떻게 수행할까? (query count 포함)" /><published>2023-08-21T00:05:07+09:00</published><updated>2023-08-21T00:05:07+09:00</updated><id>http://localhost:4000/strategy/django-strategy-test</id><content type="html" xml:base="http://localhost:4000/strategy/django-strategy-test/"><![CDATA[<h2 id="글을-작성하게-된-계기">글을 작성하게 된 계기</h2>
<ul>
  <li>테스트 환경을 구축하는 것이 초반에는 번거로울지 모르지만, 기능 구현에 대한 발전 과정 / 리팩토링 과정을 공유하고 특정 기능에 대해 구체적인 예시로 살펴볼 수 있다는 점에 있어서 편리하다고 생각되었습니다.</li>
  <li>서비스를 실행시키고 postman 혹은 화면작업을 통한 이벤트로 구현한 작업을 실행하는 번거로운 작업보다 간단한 <code class="language-plaintext highlighter-rouge">python3 manage.py test ~</code> 명령어를 통해 구현 기능을 미리 검토해볼 수 있다는 장점이 있습니다.</li>
  <li>구현 기능을 적용시키기 이전, 테스트를 습관화 하기 위해 사용하던 전략을 정리하기 위해 포스팅합니다.</li>
</ul>

<h3 id="serializer-test를-위한-testcase-작성">serializer test를 위한 TestCase 작성</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># core.test.py
</span>
<span class="kn">import</span> <span class="n">logging</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="p">.</span><span class="nf">getLogger</span><span class="p">(</span><span class="sh">"</span><span class="s">skeleton</span><span class="sh">"</span><span class="p">)</span>
<span class="n">logger</span><span class="p">.</span><span class="nf">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="p">.</span><span class="n">INFO</span><span class="p">)</span>
<span class="n">logger</span><span class="p">.</span><span class="nf">addHandler</span><span class="p">(</span><span class="n">logging</span><span class="p">.</span><span class="nc">StreamHandler</span><span class="p">())</span>

<span class="kn">from</span> <span class="n">django.db</span> <span class="kn">import</span> <span class="n">connection</span><span class="p">,</span> <span class="n">reset_queries</span>
<span class="k">def</span> <span class="nf">assert_query_count</span><span class="p">(</span><span class="n">count</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="nd">@override_settings</span><span class="p">(</span><span class="n">DEBUG</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="nf">reset_queries</span><span class="p">()</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="nf">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">queries</span> <span class="o">=</span> <span class="n">connection</span><span class="p">.</span><span class="n">queries</span>
            <span class="k">for</span> <span class="n">query</span> <span class="ow">in</span> <span class="n">queries</span><span class="p">:</span>
                <span class="n">logger</span><span class="p">.</span><span class="nf">debug</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">QUERY: </span><span class="si">{</span><span class="n">query</span><span class="p">[</span><span class="sh">'</span><span class="s">sql</span><span class="sh">'</span><span class="p">]</span><span class="si">}</span><span class="s">, TIME: </span><span class="si">{</span><span class="n">query</span><span class="p">[</span><span class="sh">'</span><span class="s">time</span><span class="sh">'</span><span class="p">]</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nf">len</span><span class="p">(</span><span class="n">queries</span><span class="p">)</span> <span class="o">==</span> <span class="n">count</span><span class="p">,</span> <span class="sh">"</span><span class="s">QUERY COUNT:%d != %d</span><span class="sh">"</span> <span class="o">%</span> <span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">queries</span><span class="p">),</span> <span class="n">count</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ret</span>
        <span class="k">return</span> <span class="n">wrapper</span>
    <span class="k">return</span> <span class="n">decorator</span>

<span class="k">class</span> <span class="nc">IntegrationSerializerTestCase</span><span class="p">(</span><span class="n">TestCase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">serializer_test</span><span class="p">(</span>
        <span class="n">self</span><span class="p">,</span>
        <span class="n">expected_query_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
        <span class="n">instance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ModelSerializer</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">data</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">run_test</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">run_test</span>
        <span class="k">if</span> <span class="n">expected_query_count</span><span class="p">:</span>
            <span class="n">run_test</span> <span class="o">=</span> <span class="nf">assert_query_count</span><span class="p">(</span><span class="n">expected_query_count</span><span class="p">)(</span><span class="n">run_test</span><span class="p">)</span>
        <span class="k">return</span> <span class="nf">run_test</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">run_test</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">if</span> <span class="nf">isinstance</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="nf">serializer</span><span class="p">(),</span> <span class="n">CreateSerializer</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nf">isinstance</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="nf">serializer</span><span class="p">(),</span> <span class="n">UpdateSerializer</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">instance</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sh">"</span><span class="s">instance must be a ModelSerializer</span><span class="sh">"</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">serializer</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">serializer</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">serializer</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">serializer</span><span class="p">.</span><span class="nf">is_valid</span><span class="p">(</span><span class="n">raise_exception</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
            <span class="n">instance</span> <span class="o">=</span> <span class="n">serializer</span><span class="p">.</span><span class="nf">save</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">serializer</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">serializer</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">serializer</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">partial</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">serializer</span><span class="p">.</span><span class="nf">is_valid</span><span class="p">(</span><span class="n">raise_exception</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
            <span class="n">updated_instance</span> <span class="o">=</span> <span class="n">serializer</span><span class="p">.</span><span class="nf">save</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">serializer</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">core</code> 앱의 test 파일에 위와 같이 다른 테스트에서 상속받을 TestCase 클래스를 작성합니다. import 모듈은 생략합니다.</li>
  <li>저는 테스트 작성시 <code class="language-plaintext highlighter-rouge">TestCase</code>를 상속받은 <code class="language-plaintext highlighter-rouge">IntegrationSerializerTestCase</code>를 상속받는 방식으로 테스트를 수행합니다.</li>
  <li>클래스 변수로 지정한 <code class="language-plaintext highlighter-rouge">serializer</code>에 따라서, 검증하는 방식이 다릅니다. 테스트를 위해 더욱 구체적인 정보를 추가해야할 필요가 있다면 <code class="language-plaintext highlighter-rouge">IntegrationSerializerTestCase</code>의 메서드에서 이를 관리하는 방식으로 사용합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">serializer.save()</code> 이 후 반환되는 값은 serializer.data입니다.</li>
  <li>얼마나 많은 sql query를 호출했는지 평가하기 위해 DB 호출 부분을 <code class="language-plaintext highlighter-rouge">assert_query_count</code> 데코레이터를 사용합니다. <code class="language-plaintext highlighter-rouge">expected_query_count</code>를 인자로 추가한다면, 이에 대한 부분도 평가합니다.</li>
  <li>테스트 함수에서 <code class="language-plaintext highlighter-rouge">isinstance</code>로 serializer를 구분하는데, 이들은 미리 <code class="language-plaintext highlighter-rouge">core.serializers.py</code>에 작성하여둔 시리얼라이저를 상속하는 방식입니다.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1"># core.serializers.py
</span>  <span class="kn">from</span> <span class="n">rest_framework</span> <span class="kn">import</span> <span class="n">serializers</span>

  <span class="k">class</span> <span class="nc">CreateSerializer</span><span class="p">(</span><span class="n">serializers</span><span class="p">.</span><span class="n">ModelSerializer</span><span class="p">):</span>
      <span class="n">representation_serializer_class</span> <span class="o">=</span> <span class="bp">None</span>

      <span class="k">def</span> <span class="nf">to_representation</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
          <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">representation_serializer_class</span><span class="p">(</span><span class="n">instance</span><span class="o">=</span><span class="n">instance</span><span class="p">).</span><span class="n">data</span>

  <span class="k">class</span> <span class="nc">UpdateSerializer</span><span class="p">(</span><span class="n">serializers</span><span class="p">.</span><span class="n">ModelSerializer</span><span class="p">):</span>
      <span class="n">representation_serializer_class</span> <span class="o">=</span> <span class="bp">None</span>

      <span class="k">def</span> <span class="nf">to_representation</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
          <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">representation_serializer_class</span><span class="p">(</span><span class="n">instance</span><span class="o">=</span><span class="n">instance</span><span class="p">).</span><span class="n">data</span>
</code></pre></div>    </div>
    <ul>
      <li>해당 클래스들을 상속받아 생성/수정 시리얼라이저를 사용하게 될 것이므로, 공통되는 추가적인 정보 기입 혹은 로깅등이 있다면 이곳에 추가합니다.</li>
    </ul>
  </li>
</ul>

<h3 id="구체적인-사용-예시">구체적인 사용 예시</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># products.test_serializer.py
</span>
<span class="k">class</span> <span class="nc">ProductUpdateSerializerTestCase</span><span class="p">(</span><span class="n">IntegrationSerializerTestCase</span><span class="p">):</span>
    <span class="n">serializer</span> <span class="o">=</span> <span class="n">ProductUpdateSerializer</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">setUpTestData</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="bp">...</span>

    <span class="k">def</span> <span class="nf">test_success</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">prod</span> <span class="o">=</span> <span class="nf">get_object_or_404</span><span class="p">(</span><span class="n">Product</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="n">prod_data</span><span class="p">[</span><span class="sh">'</span><span class="s">id</span><span class="sh">'</span><span class="p">])</span>

        <span class="n">serializer</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">serializer_test</span><span class="p">(</span>
            <span class="n">expected_query_count</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">instance</span><span class="o">=</span><span class="n">prod</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="n">update_data</span><span class="p">[</span><span class="sh">'</span><span class="s">name</span><span class="sh">'</span><span class="p">],</span>
            <span class="n">category</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="n">update_data</span><span class="p">[</span><span class="sh">'</span><span class="s">category</span><span class="sh">'</span><span class="p">],</span>
            <span class="n">is_active</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="n">update_data</span><span class="p">[</span><span class="sh">'</span><span class="s">is_active</span><span class="sh">'</span><span class="p">],</span>
            <span class="n">is_deleted</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="n">update_data</span><span class="p">[</span><span class="sh">'</span><span class="s">is_deleted</span><span class="sh">'</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="n">test_field_list</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">name</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">category</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">is_active</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">is_deleted</span><span class="sh">'</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">test_field_list</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">self</span><span class="p">.</span><span class="nf">subTest</span><span class="p">(</span><span class="n">field</span><span class="o">=</span><span class="n">field</span><span class="p">):</span>
                <span class="n">self</span><span class="p">.</span><span class="nf">assertEqual</span><span class="p">(</span><span class="n">serializer</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">field</span><span class="p">],</span> <span class="n">self</span><span class="p">.</span><span class="n">update_data</span><span class="p">[</span><span class="n">field</span><span class="p">])</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">core</code> 앱으로부터 <code class="language-plaintext highlighter-rouge">IntegrationSerializerTestCase</code>를 상속받아, 원하는 시리얼라이저를 테스트합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">ProductUpdateSerializer</code>는 아래와 같이 구성되어, <code class="language-plaintext highlighter-rouge">core.serializer.UpdateSerializer</code>를 상속받습니다.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">ProductUpdateSerializer</span><span class="p">(</span><span class="n">UpdateSerializer</span><span class="p">):</span>
      <span class="n">representation_serializer_class</span> <span class="o">=</span> <span class="n">ProductSerializer</span>

      <span class="k">class</span> <span class="nc">Meta</span><span class="p">:</span>
          <span class="n">model</span> <span class="o">=</span> <span class="n">Product</span>
          <span class="n">fields</span> <span class="o">=</span> <span class="p">(</span>
              <span class="sh">"</span><span class="s">name</span><span class="sh">"</span><span class="p">,</span>
              <span class="sh">"</span><span class="s">category</span><span class="sh">"</span><span class="p">,</span>
              <span class="sh">"</span><span class="s">is_active</span><span class="sh">"</span><span class="p">,</span>
              <span class="sh">"</span><span class="s">is_deleted</span><span class="sh">"</span><span class="p">,</span>
          <span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li><code class="language-plaintext highlighter-rouge">self.serializer_test</code>의 결과로 반환되는 serializer의 내용들을 활용하여 테스트합니다.</li>
</ul>]]></content><author><name>Yeham Kim</name></author><category term="Strategy" /><summary type="html"><![CDATA[글을 작성하게 된 계기 테스트 환경을 구축하는 것이 초반에는 번거로울지 모르지만, 기능 구현에 대한 발전 과정 / 리팩토링 과정을 공유하고 특정 기능에 대해 구체적인 예시로 살펴볼 수 있다는 점에 있어서 편리하다고 생각되었습니다. 서비스를 실행시키고 postman 혹은 화면작업을 통한 이벤트로 구현한 작업을 실행하는 번거로운 작업보다 간단한 python3 manage.py test ~ 명령어를 통해 구현 기능을 미리 검토해볼 수 있다는 장점이 있습니다. 구현 기능을 적용시키기 이전, 테스트를 습관화 하기 위해 사용하던 전략을 정리하기 위해 포스팅합니다.]]></summary></entry><entry><title type="html">[Django] permissions</title><link href="http://localhost:4000/strategy/study-django-strategy-permissions/" rel="alternate" type="text/html" title="[Django] permissions" /><published>2023-08-21T00:05:07+09:00</published><updated>2023-08-21T00:05:07+09:00</updated><id>http://localhost:4000/strategy/study-django-strategy-permissions</id><content type="html" xml:base="http://localhost:4000/strategy/study-django-strategy-permissions/"><![CDATA[<h3 id="글을-작성한-계기">글을 작성한 계기</h3>
<ul>
  <li>최근 과제전형을 보며, 백오피스로 주로 사용하는 Django에서 권한 관리에 대한 중요성을 많이 느끼게 되었습니다.</li>
  <li>ViewSet의 메서드를 사용할 때 Global Permission을 적용시켜야 하는지, Object-level Permission을 적용시켜야하는지 등 기본에 충실해서 학습해야함을 느꼈습니다.</li>
  <li>아래 내용들은 단순히 DRF 문서의 번역이 아닌, 실제 사용하며 분석한 내용과 사용 전략이 포함되어있습니다.</li>
</ul>

<h2 id="django-permissions">Django Permissions</h2>
<ul>
  <li>ModelViewSet등 APIView 기반의 뷰를 사용하기 위해 권한이 있는 사용자만 사용할 수 있도록 제한해야하는 경우가 있습니다.</li>
</ul>

<h3 id="기본적인-형태">기본적인 형태</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">UserViewSet</span><span class="p">(</span><span class="n">viewsets</span><span class="p">.</span><span class="n">ModelViewSet</span><span class="p">):</span>
    <span class="n">serializer_class</span> <span class="o">=</span> <span class="n">UserSerializer</span>
    <span class="n">queryset</span> <span class="o">=</span> <span class="n">User</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nf">all</span><span class="p">()</span>
    <span class="c1"># permission_classes = [IsAccountAdminOrReadOnly]
</span>
    <span class="k">def</span> <span class="nf">get_permissions</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">action</span> <span class="o">==</span> <span class="sh">'</span><span class="s">list</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">permission_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">IsAuthenticated</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">permission_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">IsAdminUser</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="nf">permission</span><span class="p">()</span> <span class="k">for</span> <span class="n">permission</span> <span class="ow">in</span> <span class="n">permission_classes</span><span class="p">]</span>
</code></pre></div></div>
<ul>
  <li>ViewSet 내의 모든 메서드에 공통적인 Permission Class를 적용하기 위해서는 ViewSet의 클래스 변수로 처리합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">permission_classes</code>에 custom permission 클래스들을 추가하여 원하는 권한에 해당하는 사용자만 메서드를 이용할 수 있도록 전처리할 수 있습니다.</li>
  <li>이 때, ViewSet의 클래스 메서드인 <code class="language-plaintext highlighter-rouge">get_queryset</code>는 필수적입니다.</li>
  <li>method에 따라 적용하는 권한이 변경된다면, <code class="language-plaintext highlighter-rouge">get_permissions</code> 메서드를 이용합니다.</li>
</ul>

<h3 id="custom-permission-class">Custom Permission Class</h3>
<ul>
  <li>DRF에서 제공하는 <code class="language-plaintext highlighter-rouge">BasePermission</code>를 상속받는 커스텀 Permission은 아래와 같은 형태를 가지며, <code class="language-plaintext highlighter-rouge">has_permission</code> 또는 <code class="language-plaintext highlighter-rouge">has_object_permission</code>를 override하여 사용합니다.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">BasePermission</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">BasePermissionMetaclass</span><span class="p">):</span>
      <span class="k">def</span> <span class="nf">has_permission</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">view</span><span class="p">):</span>
          <span class="k">return</span> <span class="bp">True</span>

      <span class="k">def</span> <span class="nf">has_object_permission</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
          <span class="k">return</span> <span class="bp">True</span>

  <span class="n">SAFE_METHODS</span> <span class="o">=</span> <span class="p">(</span><span class="sh">'</span><span class="s">GET</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">HEAD</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">OPTIONS</span><span class="sh">'</span><span class="p">)</span>
  <span class="k">class</span> <span class="nc">ReadOnly</span><span class="p">(</span><span class="n">BasePermission</span><span class="p">):</span>
      <span class="k">def</span> <span class="nf">has_permission</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">view</span><span class="p">):</span>
          <span class="k">return</span> <span class="n">request</span><span class="p">.</span><span class="n">method</span> <span class="ow">in</span> <span class="n">SAFE_METHODS</span>

  <span class="k">class</span> <span class="nc">IsOwner</span><span class="p">(</span><span class="n">BasePermission</span><span class="p">):</span>
      <span class="k">def</span> <span class="nf">has_permission</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">view</span><span class="p">):</span>
          <span class="k">return</span> <span class="n">request</span><span class="p">.</span><span class="n">method</span> <span class="ow">in</span> <span class="n">SAFE_METHODS</span>

      <span class="k">def</span> <span class="nf">has_object_permission</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
          <span class="k">return</span> <span class="n">obj</span><span class="p">.</span><span class="n">owner</span> <span class="o">==</span> <span class="n">request</span><span class="p">.</span><span class="n">user</span>
</code></pre></div>    </div>
  </li>
  <li>권한이 있으면 True를, 아니면 False를 반환하도록 설계합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">has_object_permission</code>는 <code class="language-plaintext highlighter-rouge">has_permission</code> 검사를 통과한 이 후에 실행됩니다.</li>
  <li><code class="language-plaintext highlighter-rouge">ModelViewSet</code>이 상속받는 <code class="language-plaintext highlighter-rouge">GenericAPIView</code>에 <code class="language-plaintext highlighter-rouge">get_object</code> 메서드 내부에 <code class="language-plaintext highlighter-rouge">self.check_object_permissions</code>는 해당 object가 지정해둔 permission에 따라 권한을 갖는지를 판단합니다.</li>
  <li>Django의 mixins 모듈을 살펴보면, <code class="language-plaintext highlighter-rouge">get_object</code> 메서드를 사용하는 믹스인은 detail 관련 <code class="language-plaintext highlighter-rouge">Retrieve</code>(조회), <code class="language-plaintext highlighter-rouge">Update</code>(수정), <code class="language-plaintext highlighter-rouge">Destroy</code>(삭제) 모듈에서 사용하게 되며, 이 때 object-level Permission을 확인합니다.</li>
</ul>]]></content><author><name>Yeham Kim</name></author><category term="Strategy" /><summary type="html"><![CDATA[글을 작성한 계기 최근 과제전형을 보며, 백오피스로 주로 사용하는 Django에서 권한 관리에 대한 중요성을 많이 느끼게 되었습니다. ViewSet의 메서드를 사용할 때 Global Permission을 적용시켜야 하는지, Object-level Permission을 적용시켜야하는지 등 기본에 충실해서 학습해야함을 느꼈습니다. 아래 내용들은 단순히 DRF 문서의 번역이 아닌, 실제 사용하며 분석한 내용과 사용 전략이 포함되어있습니다.]]></summary></entry><entry><title type="html">[Study] Operating System - Process, Thread</title><link href="http://localhost:4000/study/study-cs-os-process-thread/" rel="alternate" type="text/html" title="[Study] Operating System - Process, Thread" /><published>2023-08-16T00:05:07+09:00</published><updated>2023-08-16T00:05:07+09:00</updated><id>http://localhost:4000/study/study-cs-os-process-thread</id><content type="html" xml:base="http://localhost:4000/study/study-cs-os-process-thread/"><![CDATA[<h2 id="프로세스">프로세스</h2>
<ul>
  <li>메모리 상에서 실행 중인 프로그램입니다.</li>
  <li>디스크로부터 메모리에 적재되어 CPU의 할당을 받습니다. 운영체제로부터 주소 공간, 파일, 메모리 등을 할당받습니다.</li>
  <li>코드 영역: 프로그램의 소스 코드 자체를 구성하는 메모리 영역</li>
  <li>데이터 영역: 전역변수, 정적변수, 배열 등에 대한 메모리 영역 (초기화 데이터는 data 영역에, 초기화되지 않은 데이터는 bss 영역에 저장)</li>
  <li>Heap 영역: 동적 할당 시 사용하는 (<code class="language-plaintext highlighter-rouge">new()</code>, <code class="language-plaintext highlighter-rouge">malloc()</code>) 영역입니다.</li>
  <li>Stack 영역: 지역변수, 매개변수, 리턴 값 (임시 메모리 영역)</li>
  <li>함수의 매개변수, 복귀 주소와 로컬 변수와 같은 임시 자료를 갖는 프로세스 스택, 전역 변수들을 수록하는 데이터 섹션을 포함합니다.</li>
  <li>하나의 프로세스가 생성될 때, 기본적으로 하나의 스레드가 같이 생성됩니다.</li>
</ul>

<h3 id="프로세스의-5가지-상태">프로세스의 5가지 상태</h3>
<ul>
  <li>생성 (New): 프로세스의 생성 상태</li>
  <li>실행 (Running): 프로세스가 CPU에 할당되어 실행 중인 상태</li>
  <li>준비 (Ready): 프로세스가 CPU에 할당되는 것을 기다리는 상태</li>
  <li>대기 (Waiting): 보류(Block) 상태라고도 하며, 프로세스가 입출력이나 이벤트를 기다리는 상태</li>
  <li>종료 (Terminated): 프로세스 종료 상태</li>
</ul>

<h3 id="멀티프로세스">멀티프로세스</h3>
<ul>
  <li>하나의 프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 병렬적으로 작업을 수행하도록 하는 것입니다.</li>
  <li>장점: 메모리 침법 문제를 OS 차원에서 해결하기 때문에 안전성이 높습니다.</li>
  <li>단점: 각각의 독립된 메모리 영역을 가지고 있기 때문에, 작업량이 많을수록 오버헤드가 발생합니다. Context Switching으로 인한 성능 저하가 발생합니다.</li>
</ul>

<h2 id="스레드">스레드</h2>
<ul>
  <li>프로세스의 실행 단위로, 한 프로세스 내에서 동작되는 여러 실행 흐름입니다. 프로세스 내의 주소 공간이나 자원을 스레드 간에 공유할 수 있습니다.</li>
  <li>스레드는 독립적인 동작을 수행하기 위해 존재하며, 독립적인 실행 흐름을 추가하기 위한 최소 조건으로 독립된 Stack 영역만 따로 할당받습니다.</li>
  <li>스레드는 스레드 ID, 프로그램 카운터, 레지스터 집합, 스택으로 구성됩니다.</li>
  <li>같은 프로세스에 속한 다른 스레드와 코드, 데이터 섹션, 열린 파일, 신호 등의 운영체제 자원들을 공유합니다.</li>
  <li>멀티 스레딩: 하나의 프로세스를 다수의 실행 단위로 구분하여 자원을 공유하고, 자원의 생성과 관리의 중복성을 최소화하여 수행능력을 향상시킵니다.</li>
</ul>

<h3 id="스택을-스레드마다-독립적으로-할당하는-이유">스택을 스레드마다 독립적으로 할당하는 이유</h3>
<ul>
  <li>스택은 함수 호출 시 전달되는 인자이며, 되돌아갈 주소값 및 함수 내 변수를 저장하기 위해 사용되는 메모리 공간입니다.</li>
  <li>스택 메모리 공간이 독립적이라는 것은, 독립적인 함수 호출이 가능하다는 것이며 이는 독립적인 실행 흐름이 가능하다는 것입니다.</li>
  <li>따라서, 독립적인 실행 흐름을 위한 최소 조건으로 독립된 스택을 할당하는 것입니다.</li>
</ul>

<h3 id="pc-레지스터를-스레드마다-독립적으로-할당하는-이유">PC 레지스터를 스레드마다 독립적으로 할당하는 이유</h3>
<ul>
  <li>PC 값은 스레드의 명령어 수행 위치값을 나타냅니다. 스레드는 CPU를 할당받았다가, 스케줄러에 의해 다시 선점당합니다.</li>
  <li>따라서, 명령어가 연속적으로 수행되지 못하고 어느 부분까지 수행했는지 기억할 필요가 있으므로, PC 레지스터를 독립적으로 할당합니다.</li>
</ul>

<h3 id="멀티-스레드">멀티 스레드</h3>
<ul>
  <li>장점: 공유 메모리만큼의 시간, 메모리 공간과 시스템 자원 소모가 절약되고, 전역변수와 정적 변수에 대한 자료를 공유할 수 있습니다.</li>
  <li>단점: 하나의 스레드가 데이터 공간을 망가뜨리면 모든 스레드가 작동 불능 상태가 되기 때문에 안전성에 문제가 있습니다. (공유 메모리를 갖기 때문)
(이는 뮤텍스와 세마포어를 통해 대비할 수 있습니다.)</li>
  <li>스레드 간의 통신이 필요한 경우에도 별도의 자원을 이용하지 않고, Heap 영역을 통해 데이터를 주고받습니다.</li>
  <li>프로세스 간 통신 방법에 비해 훨씬 간단하다는 장점이 있습니다.</li>
  <li>스레드의 context switch는 캐시 메모리를 비울 필요가 없기 때문에, 프로세스 context switch보다 더 빠릅니다.</li>
  <li>시스템의 throughput이 향상되고 자원 소모가 줄어들며 자연스럽게 프로그램 응답 시간이 단축됩니다.</li>
</ul>

<h3 id="멀티-스레딩의-문제">멀티 스레딩의 문제</h3>
<ul>
  <li>스레드 간 공유하는 자원에 동시에 접근하는 일이 발생하게 됩니다.</li>
  <li>따라서, 동기화 작업이 필요하고, 동기화를 위해 작업 처리 순서를 컨트롤하고 공유 자원에 대한 접근을 컨트롤 해야합니다.</li>
  <li>병목현상이 발생할 수 있으며, 성능이 저하될 가능성이 높습니다. 따라서, 과도한 락으로 인한 병목현상을 줄여야 합니다.</li>
  <li>멀티 프로세스 방식은 하나의 프로세스가 죽더라도 다른 프로세스에는 영향을 끼치지 않지만, 멀티 스레드는 하나의 스레드가 종료될 때, 전체 스레드도 이에 대한 영향을 받을 수 있습니다.</li>
</ul>

<h2 id="프로세스-제어-블록-process-control-block">프로세스 제어 블록 (Process Control Block)</h2>
<ul>
  <li>PCB는 특정 프로세스에 대한 중요한 정보를 저장하는 운영체제의 자료구조입니다.
(관련 저장 정보 아래에 서술)</li>
  <li>운영체제는 프로세스를 관리하기 위해 프로세스의 생성과 동시에 PCB를 생성합니다.</li>
  <li>CPU를 할당받아 작업을 처리하다가 프로세스 전환이 발생하면, 작업을 저장하고 CPU를 반환해야 하는데, 이때 진행상황을 PCB에 저장합니다.
(즉, 앞으로 다시 수행할 대기 중인 프로세스에 대한 저장 값을 PCB에 저장합니다.)</li>
  <li>다시 CPU를 할당받게 되면 이전에 종료됐던 시점부터 다시 작업을 수행합니다.</li>
  <li>PCB는 Linked List 방식으로 관리되어, List Head에 PCB들이 생성될 때마다 노드가 추가됩니다. 주소값으로 연결이 이루어진 연결리스트이기 때문에 삽입, 삭제가 용이합니다.</li>
  <li>프로세스가 생성되면 해당 PCB가 생성되고 프로세스 완료 시 제거됩니다.</li>
</ul>

<p><strong>PCB에 저장되는 정보</strong></p>
<ul>
  <li>PID, 프로세스의 상태(new, ready, running, waiting, terminated)</li>
  <li>프로그램 카운터: 프로세스가 다음에 실행할 명령어의 주소</li>
  <li>CPU 레지스터</li>
  <li>CPU 스케쥴링 정보: 프로세스의 우선순위, 스케줄 큐에 대한 포인터</li>
  <li>메모리 관리 정보: 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보 포함</li>
  <li>입출력 상태 정보: 프로세스에 할당된 입출력 장치들과 열린 파일 목록</li>
  <li>어카운팅 정보: 사용된 CPU 시간, 시간제한, 계정번호 등</li>
</ul>

<h3 id="context-switching">Context Switching</h3>
<ul>
  <li>프로세스의 상태 정보를 저장하고 복원하는 일련의 과정으로, 동작 중인 프로세스가 대기하며 해당 프로세스의 상태를 보관하고, 대기하고 있던 다음 순번의 프로세스가 동작하며 이전에 보관했던 프로세스 상태를 복구하는 과정입니다.</li>
  <li>
    <p>프로세스는 각 독립된 메모리 영역을 할당받아 사용되므로, 캐시 메모리 초기화와 같은 무거운 작업이 진행될 때 오버헤드가 발생하는 문제가 있습니다. 따라서, 프로세스의 컨텍스트 스위칭이 스레드의 컨텍스트 스위칭보다 늦습니다.</p>
  </li>
  <li>CPU가 이전의 프로세스 상태를 PCB에 보관하고, 또 다른 프로세스의 정보를 PCB에서 읽어 레지스터에 적재하는 과정입니다.</li>
</ul>

<p><strong>발생하는 경우</strong></p>
<ul>
  <li>인터럽트가 발생하는 경우</li>
  <li>실행 중인 CPU의 사용 허가 시간을 모두 소모하는 경우</li>
  <li>입출력을 위해 대기해야 하는 경우</li>
</ul>

<h2 id="cpu-scheduling">CPU Scheduling</h2>
<ul>
  <li>CPU를 잘 사용하기 위해 프로세스를 잘 배정하기 위한 방법입니다.</li>
  <li>프로세스가 작업을 수행하려면, 스케줄러로부터 CPU를 할당 받아야하므로, 순서와 처리 시간을 효율적으로 정하기 위한 정책입니다.</li>
  <li>조건: 오버헤드는 낮게, 사용률은 높게, 기아 현상은 낮게</li>
  <li>목표
    <ol>
      <li>Batch System: 한 번에 하나의 프로그램만 수행하는 것을 말합니다. 따라서, 가능하면 많은 일을 수행하며, 시간보다 처리량이 중요합니다. CPU Utilization과 같은 측면을 극대화하는 것이 배치 시스템에 더 좋습니다.</li>
      <li>Interactive System: 사용자가 컴퓨터와 대화형으로 동작하기 때문에, 응답시간이 중요합니다. 응답시간을 빠르게, 대기시간은 적게 합니다.</li>
      <li>Real-time System: 일반적으로 시간이라는 제약 조건이 추가된 시스템이기 때문에, 주어진 인풋에 대한 아웃풋의 처리 시간이 중요합니다. 따라서, 시간제약 조건(Deadline)을 맞추는 것입니다.</li>
    </ol>
  </li>
</ul>

<h3 id="프로세스의-상태-전이">프로세스의 상태 전이</h3>
<ul>
  <li>승인 (Admitted): 프로세스 생성이 가능하여 승인.</li>
  <li>스케줄러 디스패치(Scheduler Dispatch): 준비 상태에 있는 프로세스 중 하나를 선택하여 실행시키는 것.</li>
  <li>인터럽트(interrupt): 예외, 입출력, 이벤트 등이 발생하여 현재 실행 중인 프로세스를 준비 상태로 바꾸고, 해당 작업을 먼저 처리하는 것.</li>
  <li>입출력 또는 이벤트 대기 (I/O or Event wait): 실행 중인 프로세스가 입출력이나 이벤트를 처리해야 하는 경우, 입출력/이벤트가 모두 끝날 때까지 대기 상태로 만드는 것.</li>
  <li>입출력 또는 이벤트 완료 (I/O or Event Completion): 입출력/이벤트가 끝난 프로세스를 준비 상태로 전환하여 스케줄러에 의해 선택될 수 있도록 만드는 것.</li>
</ul>

<h3 id="선점-스케줄링">선점 스케줄링</h3>
<ul>
  <li>한 프로세스가 CPU를 할당받아 실행하고 있을 때, 다른 프로세스가 CPU를 사용하고 있는 프로세스를 중지시키고 CPU를 차지할 수 있는 스케줄링 기법입니다.<br />
(처리시간에 대한 예측이 어렵습니다.)</li>
  <li>우선순위가 높은 프로세스를 먼저 수행할 때 유리하며, 빠른 응답 시간을 요구하는 대화식 시분할 시스템에 유용합니다.</li>
  <li>많은 오버헤드를 초래합니다.</li>
  <li>Interrupt, I/O or Event Completion, I/O or Event Wait, Exit</li>
</ul>

<p>Priority Scheduling</p>
<ul>
  <li>정적/동적으로 우선순위를 부여하여 우선순위가 높은 순서대로 처리합니다.</li>
  <li>우선순위가 낮은 프로세스가 무한정 기다리는 Starvation이 발생할 수 있습니다.<br />
(Aging 방법으로 Starvation 문제를 해결할 수 있음)</li>
</ul>

<p>Round Robin</p>
<ul>
  <li>FCFS에 의해 프로세스들이 보내지면 각 프로세스는 동일한 시간의 Time Quantum만큼 CPU를 할당받습니다.<br />
(time quantum, time slice: 실행의 최소 단위 시간)</li>
  <li>할당 시간(time quantum)이 크면 FCFS와 같게 되고, 작으면 컨텍스트 스위칭이 잦아져서 오버헤드가 증가합니다.</li>
</ul>

<p>Multilevel-Queue</p>
<ul>
  <li>작업들을 여러 종류의 그룹으로 나누어 여러 개의 큐를 이용하는 기법입니다.</li>
  <li>우선순위가 낮은 큐들이 실행하지 못하는 것을 방지하고자 각 큐마다 다른 <code class="language-plaintext highlighter-rouge">time quantum</code>을 설정해 주는 방식이 사용됩니다.</li>
  <li>우선순위가 높은 큐는 작은 <code class="language-plaintext highlighter-rouge">time quantum</code>을, 우선순위가 낮은 큐는 큰 <code class="language-plaintext highlighter-rouge">time quantum</code>을 할당합니다.</li>
</ul>

<p>Multilevel-Feedback-Queue</p>
<ul>
  <li>Multilevel-Queue에서 자신의 <code class="language-plaintext highlighter-rouge">time quantum</code>을 다 채운 프로세스는 밑으로 내려가고, <code class="language-plaintext highlighter-rouge">time quantum</code>을 다 채운 프로세스는 원래 큐에 그대로 있습니다.</li>
  <li><code class="language-plaintext highlighter-rouge">time quantum</code>을 다 채운 프로세스는 CPU burst 프로세스로 판단됩니다.</li>
  <li>짧은 작업에 유리하며, interrupt가 잦은 입출력 위주의 작업에 우선권을 줍니다.</li>
  <li>처리 시간이 짧은 프로세스를 먼저 처리하기 때문에 turn around 평균 시간을 줄여줍니다.</li>
</ul>

<h3 id="비선점-스케줄링">비선점 스케줄링</h3>
<ul>
  <li>이미 사용되는 CPU를 회수하지는 못하고, 끝날 때까지 기다리는 스케줄링 기법입니다.</li>
  <li>따라서, 프로세스 종료 또는 I/O 이벤트가 있을 때까지 실행이 보장됩니다. 처리시간 예측이 용이합니다.</li>
  <li>일괄 처리방식이 적합합니다.</li>
  <li>모든 프로세스 요구에 대해 공정하며, 중요도가 높은 작업이 낮은 작업을 기다리는 경우가 발생할 수도 있습니다.</li>
  <li>I/O or Event Wait, Exit</li>
</ul>

<p>FCFS (First Come First Served)</p>
<ul>
  <li>큐에 도착한 순서대로 CPU를 할당합니다.</li>
  <li>실행 시간이 짧은 작업이 뒤로 가면 평균 대기시간이 길어집니다.</li>
</ul>

<p>SJF (Shortest Job First)</p>
<ul>
  <li>수행시간이 가장 짧다고 판단되는 작업을 먼저 수행합니다.</li>
  <li>FCFS 보다 평균 대기 시간이 감소하고, 짧은 작업에 유리합니다.</li>
</ul>

<p>HRN (Highest Response-ratio Next)</p>
<ul>
  <li>우선순위를 계산하여 점유 불평등을 보완하는 방법으로, SJF의 단점을 보완합니다.</li>
  <li>우선순위 = (대기시간 + 실행시간) / 실행시간</li>
</ul>

<h2 id="deadlock교착상태">Deadlock(교착상태)</h2>
<ul>
  <li>둘 이상의 프로세스가 다른 프로세스가 점유하고 있는 자원을 기다리기 위해 무한 대기에 빠지는 상황을 의미합니다.</li>
</ul>

<h3 id="발생조건">발생조건</h3>
<p>이 중 하나라도 만족하지 않으면 교착상태는 발생하지 않습니다.</p>
<ul>
  <li>상호배제(Mutual exclusion): <strong>한 번에 프로세스 하나만 해당 자원을 사용할 수 있다</strong>. 사용 중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다.</li>
  <li>점유대기(Hold and Wait): 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다.</li>
  <li>비선점(No preemption): 프로세스가 어떤 자원의 사용이 끝날 때까지 그 자원을 뺏을 수 없습니다.</li>
  <li>순환대기(Circular wait): Hold and Wait 관계의 프로세스들이 서로를 기다립니다.</li>
</ul>

<h3 id="교착상태-방지방법">교착상태 방지방법</h3>
<ul>
  <li>예방(Prevention): 할당 구조 측면에서, 교착상태가 발생할 수 있는 요구조건을 만족시키지 않도록 함으로써 교착상태를 방지합니다.</li>
  <li>회피(Avoidance): 교착상태가 발생할 가능성이 있는 자원을 할당(unsafe allocation)하지 않습니다. (대표적으로, 은행원 알고리즘, 자원 할당 그래프)</li>
  <li>탐지 및 회복(Detection and Recovery): 교착상태가 발생할 수 있도록 놔두고 교착상태가 발생할 경우 이를 찾아내어 고칩니다.</li>
</ul>

<p><strong>예방</strong></p>
<ul>
  <li>상호 배제 조건 방지: 한 번에 여러 프로세스가 공유 자원을 사용할 수 있도록 합니다.</li>
  <li>점유 대기 조건 방지
    <ul>
      <li>프로세스 대기를 없애기 위해서 프로세스가 실행되기 전에 필요한 모든 자원을 할당합니다. (자원 낭비 발생)</li>
      <li>자원을 점유하지 않고 있을 때에만 다른 자원을 요청할 수 있도록 합니다. 한 프로세스가 추가적인 자원을 필요로 하면, 자신의 자원을 모두 해제하여 빈상태에서 다시 요청합니다. (기아상태가 될 수 있음)</li>
    </ul>
  </li>
  <li>비선점 조건 방지: 이미 다른 프로세스에 할당된 자원에 대해 선점권이 없다면, 높은 우선순위의 프로세스가 해당 자원을 선점할 수 있도록 합니다.</li>
  <li>순환대기 조건 방지: 자원을 순환 형태로 대기하도록 하지 않고, 일정한 방향으로 자원을 요구할 수 있도록 합니다. (임의로 순서를 부여)</li>
</ul>

<p><strong>회피</strong></p>
<ul>
  <li>시스템의 프로세스들이 데드락을 발생시키지 않도록 요청되는 자원을 모두에게 할당할 수 있다면, <code class="language-plaintext highlighter-rouge">안정 상태(safe state)</code>에 있다고 말합니다.</li>
  <li>프로세스들에게 자원을 할당하고 실행 및 종료 등의 작업을 할 때, 데드락을 발생시키지 않게 하는 특정한 순서를 찾는다면, 이를 <code class="language-plaintext highlighter-rouge">안전 순서(safe sequence)</code>라고 합니다.</li>
  <li>데드락은 불안정 상태에 있을 때 발생합니다. 따라서, 불안정 상태가 데드락보다 더 큰 집합입니다.</li>
  <li>회피 알고리즘은 자원을 할당한 후에도 시스템이 항상 Safe state에 있도록 할당을 허용하게 됩니다.</li>
</ul>

<p><strong>탐지 및 회복</strong></p>

<p>교착상태가 발생하도록 두고, 교착상태가 발생한다면 그 후에 해결하는 방식입니다.</p>

<p>탐지 기법</p>
<ul>
  <li>Allocation, Request, Available 등으로 시스템에 데드락이 발생했는지 여부를 탐색합니다.</li>
  <li>자원 할당 그래프를 통해 탐지하는 방법도 있습니다.</li>
</ul>

<p>회복 기법</p>
<ul>
  <li>교착상태에 빠진 모든 프로세스를 중단시키는 방법이 있지만, 연산중이던 프로세스들도 모두 일시에 중단되므로, 작업 중인 부분 결과가 폐기될 수 있습니다.</li>
  <li>프로세스를 중단시킬 때마다 탐지 알고리즘으로 데드락을 탐지하며 회복시키는 방법이 있습니다. 매번 탐지 알고리즘을 호출 및 수행해야하기 때문에 부담되는 작업일 수 있습니다.</li>
  <li>프로세스에 할당된 자원을 선점하여 데드락을 해결할 때까지 해당 자원을 다른 프로세스에 할당하는 방법이 있습니다.</li>
</ul>]]></content><author><name>Yeham Kim</name></author><category term="Study" /><summary type="html"><![CDATA[프로세스 메모리 상에서 실행 중인 프로그램입니다. 디스크로부터 메모리에 적재되어 CPU의 할당을 받습니다. 운영체제로부터 주소 공간, 파일, 메모리 등을 할당받습니다. 코드 영역: 프로그램의 소스 코드 자체를 구성하는 메모리 영역 데이터 영역: 전역변수, 정적변수, 배열 등에 대한 메모리 영역 (초기화 데이터는 data 영역에, 초기화되지 않은 데이터는 bss 영역에 저장) Heap 영역: 동적 할당 시 사용하는 (new(), malloc()) 영역입니다. Stack 영역: 지역변수, 매개변수, 리턴 값 (임시 메모리 영역) 함수의 매개변수, 복귀 주소와 로컬 변수와 같은 임시 자료를 갖는 프로세스 스택, 전역 변수들을 수록하는 데이터 섹션을 포함합니다. 하나의 프로세스가 생성될 때, 기본적으로 하나의 스레드가 같이 생성됩니다.]]></summary></entry><entry><title type="html">[Study] Network - TCP</title><link href="http://localhost:4000/study/study-cs-network-tcp/" rel="alternate" type="text/html" title="[Study] Network - TCP" /><published>2023-08-16T00:05:07+09:00</published><updated>2023-08-16T00:05:07+09:00</updated><id>http://localhost:4000/study/study-cs-network-tcp</id><content type="html" xml:base="http://localhost:4000/study/study-cs-network-tcp/"><![CDATA[<h3 id="tcp-통신이란">TCP 통신이란?</h3>
<ul>
  <li>네트워크 통신에서 데이터를 안정적이고 신뢰성 있게 전송하기 위한 연결방식입니다.</li>
  <li>unreliable network에서 reliable network를 보장할 수 있도록 하는 프로토콜입니다.</li>
  <li>network congetion avoidance algorithm을 사용합니다.</li>
</ul>

<p><strong>reliable network를 보장한다? 아래 문제들을 해결하는 것</strong></p>
<ul>
  <li>packet이 손실될 수 있는 문제</li>
  <li>packet의 순서가 바뀌는 문제</li>
  <li>네트워크가 혼잡하게(congestion) 되는 문제</li>
  <li>receiver가 과부화(overload) 되는 문제</li>
</ul>

<h3 id="흐름제어">흐름제어</h3>
<ul>
  <li>송신측과 수신측의 데이터 처리 속도 차이를 해결하는 것</li>
  <li>송신측이 수신측보다 데이터 처리 속도가 빠르게 되면 문제가 발생합니다.</li>
  <li>수신측에서 제한된 저장 용량을 초과한 이후에 도착하는 데이터(packet)는 손실될 수 있습니다. 이를 위해 송신 측의 데이터 전송량을 조절해야 합니다.</li>
  <li>receiver가 sender에게 상태를 feedback 합니다.</li>
</ul>

<p><strong>전송의 전체 과정</strong></p>
<ol>
  <li>Application Layer에서 데이터 전송 시, sender의 애플리케이션은 소켓에 데이터를 씁니다.</li>
  <li>이 데이터는 Transport Layer로 전달되어 세그먼트(Segment)라는 단위로 나뉩니다.</li>
  <li>전송 계층은 이 세그먼트를 Network Layer에 넘깁니다.</li>
  <li>전송된 데이터는 수신자 쪽으로 전달되고 수신자는 수신 버퍼에 데이터를 저장합니다.<br />
(이때, 수신자 쪽에서는 수신 버퍼의 용량을 넘치지 않도록 조절해야 합니다.)</li>
  <li>수신자 쪽에서는 자신의 수신 버퍼의 남은 용량을 송신자에게 알려주는데, 이를 수신 윈도우(receive window)라고 합니다.</li>
  <li>송신자는 수신자의 수신 윈도우를 확인하여 수신자의 수신 버퍼 용량을 초과하지 않도록 데이터를 전송합니다.</li>
  <li>데이터 전송 중에 수신 버퍼가 넘치는 현상을 방지하면서, 안정적인 데이터 전송을 보장하며, 이를 흐름제어(Flow Control)이라고 합니다.</li>
</ol>

<p><strong>해결방법</strong></p>
<ul>
  <li>Stop and Wait: 매번 전송한 패킷에 대해 확인 응답을 받은 후에만 그다음 패킷을 전송하는 방법입니다.</li>
  <li>Sliding Window(Go Back N ARQ): 수신측에서 설정한 윈도우 크기만큼 송신측에서 확인/응답 없이 세그먼트를 전송할 수 있도록 데이터 흐름을 동적으로 조절하는 제어 방법입니다.</li>
</ul>

<p><strong>Sliding Window</strong></p>
<ul>
  <li>목적: 전송은 되었지만, ACK 패킷을 받지 못한 byte의 숫자를 파악하기 위해 사용하는 프로토콜입니다.</li>
  <li>동작방식: 윈도우에 포함되는 모든 패킷을 전송 후, 그 패킷들의 전달이 확인되는 대로 윈도우를 이동시키며 그다음 패킷을 전송합니다.</li>
</ul>

<h3 id="혼잡제어">혼잡제어</h3>
<ul>
  <li>송신측의 데이터 전달과 네트워크의 데이터 처리 속도 차이를 해결하기 위한 방법입니다.</li>
  <li>송신측의 데이터는 지역망이나 인터넷으로 연결된 대형 네트워크를 통해 전달됩니다. 따라서, 만약 한 라우터에 데이터가 몰리면, 자신에게 온 데이터를 모두 처리할 수 없게 됩니다.</li>
  <li>따라서, 이러한 네트워크의 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송속도를 강제로 줄이게 되며, 이를 혼잡제어라고 합니다.</li>
</ul>

<p><strong>해결방법</strong></p>

<p>참고: window size는 단위시간당 전송 패킷 수</p>

<p>AMID(Additive Increase / Multiplicate Decrease)</p>
<ul>
  <li>처음에 패킷을 하나씩 보내다 문제가 없으면, window size를 1씩 증가시키며 전송하는 방법입니다.</li>
  <li>패킷 전송에 실패하거나 일정 시간을 넘으면, 패킷의 전송 속도를 절반으로 줄입니다.</li>
  <li>시간이 흐르면 평형상태로 수렴하게 되는 공평한 방식입니다. (여러 호스트가 한 네트워크를 공유하면 나중에 진입하는 쪽이 불리)</li>
  <li>초기에 높은 대역폭을 사용하지 못하기 때문에, 오랜 시간이 걸리며, 네트워크 혼잡 상황을 미리 파악하기 힘듭니다.</li>
  <li>따라서, 네트워크가 혼잡해진 후에야 대역폭을 줄일 수 있습니다.</li>
</ul>

<p>Slow Start</p>
<ul>
  <li>AIMD와 마찬가지로 패킷을 하나씩 보내면서 시작하고, 패킷이 문제없이 도착하면 각각의 ACK 패킷마다 window size를 늘립니다. 한 주기가 지나면 window size가 2배가 됩니다.</li>
  <li>따라서, 전송속도는 AIMD에 비해 지수 함수 꼴로 증가하지만, 혼잡 현상이 발생하면 window size를 1로 떨어뜨립니다.</li>
  <li>한 번 혼잡 현상이 발생하고 나면 네트워크의 수용량을 어느 정도 예상할 수 있습니다.</li>
  <li>그래서, 혼잡 현상이 발생하였던 window size의 절반까지는 이전처럼 지수함수 꼴로 증가시키고, 그 이후부터는 완만하게 1씩 증가시킵니다.</li>
</ul>

<p>Fast Retransmit</p>
<ul>
  <li>패킷을 받는 쪽에서 먼저 도착해야 할 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 ACK 패킷을 보냅니다.</li>
  <li>순서대로 잘 도착한 마지막 패킷의 다음 패킷 순번을 ACK 패킷에 실어서 보내므로, 중간에 하나가 손실되면 송신 측에서는 순번이 중복된 ACK를 받게 됩니다.</li>
  <li>이를 감지하는 순간, 문제가 되는 순번의 패킷을 재전송합니다.</li>
  <li>중복된 순번의 패킷 3개를 받으면 재전송을 하게 되고, 혼잡 상황이라 판단 후, window size를 줄입니다.</li>
</ul>

<p>Fast Recovery</p>
<ul>
  <li>혼잡 상태가 되면 window size를 1로 줄이지 않고 반으로 줄이고 선형 증가시키는 방법입니다.</li>
  <li>이를 적용하면 혼잡 상황을 한 번 겪은 후 AIMD 방식으로 동작합니다.</li>
</ul>]]></content><author><name>Yeham Kim</name></author><category term="Study" /><summary type="html"><![CDATA[TCP 통신이란? 네트워크 통신에서 데이터를 안정적이고 신뢰성 있게 전송하기 위한 연결방식입니다. unreliable network에서 reliable network를 보장할 수 있도록 하는 프로토콜입니다. network congetion avoidance algorithm을 사용합니다.]]></summary></entry><entry><title type="html">[Study] Network - OSI 계층</title><link href="http://localhost:4000/study/study-cs-network-osi/" rel="alternate" type="text/html" title="[Study] Network - OSI 계층" /><published>2023-08-16T00:05:07+09:00</published><updated>2023-08-16T00:05:07+09:00</updated><id>http://localhost:4000/study/study-cs-network-osi</id><content type="html" xml:base="http://localhost:4000/study/study-cs-network-osi/"><![CDATA[<h3 id="osi-7계층">OSI 7계층</h3>
<p><strong>7 계층 - Application Layer</strong></p>
<ul>
  <li>사용자에게 보이는 부분으로, 최종 사용자에게 가장 가까운 계층으로, 사용자와 직접적으로 상호작용합니다.</li>
  <li>애플리케이션 목적에 맞는 통신 방법을 제공합니다.</li>
  <li>HTTP, DNS, SMTP, FTP등의 대표적인 프로토콜이 해당 레이어에 속합니다.</li>
</ul>

<p><strong>6 계층 - Presentation Layer</strong></p>
<ul>
  <li>애플리케이션 통신에서 메시지 포맷을 관리하는 계층입니다.</li>
  <li>데이터를 안전하게 전송하기 위해 암호화, 복호화하여 소통합니다.</li>
</ul>

<p><strong>5 게층 - Session Layer</strong></p>
<ul>
  <li>애플리케이션 통신에서 세션을 관리하는 계층입니다.</li>
  <li>예시로 RPC(remote procedure call)가 있습니다.</li>
</ul>

<p><strong>4 계층 - Transport Layer</strong></p>
<ul>
  <li>애플리케이션 통신을 담당하며, 실제로 목적지 애필리케이션으로 데이터를 전송합니다.</li>
  <li>TCP, UDP 프로토콜을 사용합니다.</li>
  <li>TCP: 안정적이고 신뢰할 수 있는 데이터 전송을 보장합니다.</li>
  <li>UDP: 데이터가 중간에 유실되거나 순서가 꼬일 수 있지만, 데이터를 무조건 전송합니다.</li>
  <li>Network Layer의 기능을 사용하여 데이터를 전송합니다.</li>
</ul>

<p><strong>3 계층 - Network Layer</strong></p>
<ul>
  <li>호스트 간의 통신을 담당합니다. (IP 프로토콜)</li>
  <li>목적지 호스트로 데이터를 전송합니다.</li>
  <li>네트워크 간의 최적의 경로를 결정합니다.</li>
  <li>Data Link Layer의 기능을 사용하여 기능을 구현합니다.</li>
</ul>

<p><strong>2 계층 - Data Link Layer</strong></p>
<ul>
  <li>IP 주소가 아닌 MAC 주소 기반으로 통신합니다.</li>
  <li>ARP: IP 주소를 MAC 주소로 변환하는 프로토콜입니다.</li>
</ul>

<p><strong>1 계층 - Physical Layer</strong></p>
<ul>
  <li>
    <p>bits 단위로 데이터를 전송합니다.</p>
  </li>
  <li>서로 다른 컴퓨터가 통신을 할 떄 역시, 7계층을 기반으로 통신합니다.</li>
  <li>라우터는 Network Layer, Data Link Layer, Physical Layer에 있는 프로토콜을 구현합니다.</li>
  <li>유튜브 댓글 작성시 유튜브 서버까지 어떻게 전달되는지 살펴보기
    <ol>
      <li>애플리케이션 레이어에 메시지를 전송하기 위해 처리과정을 거칩니다. 부가적인 정보들을 애플리케이션 헤더에 담습니다.</li>
      <li>presentation layer 관련 데이터들을 헤더에 담고, 담긴 정보를 Session Layer로 보냅니다.</li>
    </ol>
  </li>
</ul>

<h2 id="구글을-주소창에서-입력하면-일어나는-일">구글을 주소창에서 입력하면 일어나는 일</h2>
<ul>
  <li>DNS (Domain Name System Servers): URL들의 이름과 IP 주소를 저장하고 있는 데이터 베이스로, 웹사이트를 위한 주소록입니다. 숫자로된 IP를 사용자가 편리한 주소로 맵핑합니다. 최종적으로 사용자를 어떤 서버에 연결할 것인지 제어하는 요청을 쿼리라고 부릅니다.</li>
  <li>DNS query: DNS 서버들을 검색해서 해당 사이트의 IP 주소를 찾습니다. 재귀적으로 서로 다른 DNS 서버를 오가며 에러가 날 때까지 반복적으로 요청합니다. (recursive search)</li>
  <li>TCIP/IP (Transmission Control Protocol / Internet Protocol): 이를 따른다는 것은, IP 주소 체계를 따르며 TCP의 특성을 활용해 송신자와 수신자의 논리적 연결을 생성하고 신뢰성을 유지할 수 있도록 하겠다는 의미입니다.</li>
  <li>HTTP(Hypertext Transfer Protocol):</li>
</ul>

<ol>
  <li>사용자가 웹브라우저 검색창에 www.google.com을 입력</li>
  <li>웹브라우저는 캐싱된 DNS 기록들을 통해 도메인 주소와 대응하는 IP 주소응답 (캐시에 없다면 3, 있다면 4로)</li>
  <li>웹브라우저가 HTTP를 사용하여 DNS에 입력된 도메인 주소 요청 및 IP 주소 응답</li>
  <li>웹브라우저가 웹서버에게 IP 주소를 통해 html 문서를 요청합니다. (TCP/IP)</li>
  <li>웹어플리케이션서버(WAS)와 데이터베이스에서 우선적으로 웹페이지 작업을 처리합니다.</li>
  <li>처리된 작업의 결과를 웹서버로 전송합니다.</li>
  <li>웹서버는 브라우저에게 html 문셔 결과를 응답합니다.</li>
  <li>웹브라우저는 화면에 웹페이지 내용을 출력합니다.</li>
</ol>

<h2 id="웹서버--어플리케이션-서버--웹컨테이너">웹서버 / 어플리케이션 서버 / 웹컨테이너</h2>
<p><strong>웹서버</strong></p>
<ul>
  <li>웹서버 소프트웨어와 HTML, CSS, JavaScript파일과 같은 정적 파일들을 저장하는 하드웨어</li>
  <li>Client가 어떻게 호스트 파일들에 접근하는지 관리하는 소프트웨어</li>
  <li>URI(Uniform Resource Identifier)와 HTTP(브라우저가 웹 페이지를 보여주기 위해 사용하는 프로토콜) 소프트웨어의 일부</li>
  <li>HTTP를 통해 웹브라우저에서 요청하는 HTML 문서나 오브젝트들을 전송해주는 서비스 프로그램을 말합니다. 이 때, 다른 가공없이 파일을 그대로 전송하기만 하면 되기 때문에 정적(static)이라고 합니다.</li>
  <li>단순히 데이터만 반환하면 되기 떄문에 처리 속도가 빠르며, 트래픽의 과부하를 잘 처리할 수 있습니다.
<strong>애플리케이션 서버</strong></li>
  <li>웹 서비스가 복잡해지고 기능이 다양함에 따라서 데이터를 가공해서 처리하는 비즈니스 로직이 필요하게 됩니다.</li>
  <li>웹서버 하나에서 다른 로직까지 처리하기에 부하가 크기 때문에, 로직을 처리하는 서버가 필요하게 되어 만들어집니다.</li>
  <li>애플리케이션 서버가 HTTP 서버를 통해 브라우저에게 요청된 데이터를 전송하기 전에, 애플리케이션 서버가 데이터를 가공하기 때문에 동적이라고 부릅니다.
<strong>웹 컨테이너</strong></li>
  <li>웹 서버에서 동적인 데이터를 반환하려면 요청에 알맞는 프로그램이 필요합니다. 또한, 그 프로그램에 인자를 전달하기 위한 규약이 필요합니다.</li>
  <li>CGI(Common Gateway Interface)는 프로그램 사이에 데이터를 전달하는 중간자 역할에 필요한 통신규약을 의미합니다.</li>
  <li></li>
</ul>

<h3 id="django에서의-wsgi-cgi">Django에서의 wsgi, cgi</h3>
<p><strong>CGI(Common Gateway Interface)</strong></p>
<ul>
  <li>www 서버와 서버 상에 등장하는 다른 프로그램등 HTML에서는 불가능한 동적인 요소를 홈페이지에 받아들여 쓸 수 있도록하는 웹서버와 웹어플리케이션 사이를 이어주는 미들웨어입니다.</li>
  <li>CGI는 요청이 들어올 때마다 스레드를 생성하여 웹 어플리케이션을 동작시키게 됩니다. 이는 부하가 너무 크고, 10000개 이상의 동시 요청을 처리할 수 없다는 단점이 있습니다.</li>
</ul>

<p><strong>WSGI(Web Server Gateway Interface)</strong></p>
<ul>
  <li>웹 서버 소프트웨어와 파이썬으로 작성된 스크립트(웹 응용 프로그램) 간 통신을 위한 표준 인터페이스입니다.</li>
  <li>즉, Nginx로 들어오는 http request를 파이썬이 이해할 수 있도록 통역합니다.</li>
  <li>CGI의 단점을 보완하여 클라이언트 요청에 대해 멀티 스레드를 생성하여 효율적으로 처리합니다.</li>
  <li>Django 진영에서는 uwsgi, gunicon 등을 사용하고 있습니다.</li>
  <li>동작 과정: 클라이언트 요청 -&gt; server side에서 middleware component 호출 -&gt; middleware component가 application side의 application 호출</li>
</ul>

<p><strong>uWSGI와 Gunicorn</strong><br />
uWSGI</p>
<ul>
  <li>C 언어로 작성된 웹서버이며, 파이썬 애플리케이션을 외부 웹서버와 연결하여 오청을 처리하는 방식입니다.</li>
  <li>다양한 프로그래밍 언어를 지원하며 고성능 및 확장성이 뛰어납니다.</li>
  <li>여러 프로세스 또는 스레드를 사용하여 동시에 여러 요청을 처리할 수 있습니다.</li>
  <li>초기설정 옵션이 다양하지만 복잡합니다. 유연성과 강력한 기능을 제공합니다.</li>
  <li>다양한 플러그인과 확장 기능을 제공하여 다양한 요구 사항에 대응할 수 있습니다.</li>
</ul>

<p>Gunicorn</p>
<ul>
  <li>Python으로 작성된 웹서버이며, 독자적으로 애플리케이션을 실행하고 관리하는 단일서버로, 프론트엔드 웹서버와 직접 연결하여 사용합니다.</li>
  <li>단일 프로세스에서 동작하며, 작은 규모의 애플리케이션을 처리하는데 적합합니다.</li>
  <li>간단하고 설정이 쉽습니다. 추가설정 없이도 동작합니다.</li>
  <li>파이썬 애플리케이션에 초점을 맞춘 경량 웹서버입니다.</li>
</ul>

<p>참고 블로그</p>
<ul>
  <li>biunx님: <a href="https://binux.tistory.com/32">웹서버와 웹어플리케이션서버</a></li>
  <li>waonderboy님: <a href="https://velog.io/@waoderboy/%EC%9B%B9-%EC%84%9C%EB%B2%84-WAS-%EC%9B%B9-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88">웹 서버, WAS, 웹 컨테이너</a></li>
  <li>stg0123님: <a href="https://stg0123.github.io/study/41/">uwsgi를 django와 연결하기</a></li>
  <li>elastic7327님: <a href="https://elastic7327.medium.com/python%EA%B0%9C%EB%B0%9C%EC%9E%90-uwsgi%EB%A5%BC-%EB%B2%84%EB%A6%AC%EA%B3%A0-gunicorn%EC%9C%BC%EB%A1%9C-%EA%B0%88%EC%95%84%ED%83%80%EB%8B%A4-df1c95f220c5">uwsgi를 버린 이유</a></li>
</ul>]]></content><author><name>Yeham Kim</name></author><category term="Study" /><summary type="html"><![CDATA[OSI 7계층 7 계층 - Application Layer 사용자에게 보이는 부분으로, 최종 사용자에게 가장 가까운 계층으로, 사용자와 직접적으로 상호작용합니다. 애플리케이션 목적에 맞는 통신 방법을 제공합니다. HTTP, DNS, SMTP, FTP등의 대표적인 프로토콜이 해당 레이어에 속합니다.]]></summary></entry><entry><title type="html">[Study] Database</title><link href="http://localhost:4000/study/study-cs-database/" rel="alternate" type="text/html" title="[Study] Database" /><published>2023-08-16T00:05:07+09:00</published><updated>2023-08-16T00:05:07+09:00</updated><id>http://localhost:4000/study/study-cs-database</id><content type="html" xml:base="http://localhost:4000/study/study-cs-database/"><![CDATA[<h2 id="sql과-nosql">SQL과 NoSQL</h2>

<h3 id="sql">SQL</h3>
<ul>
  <li>데이터는 테이블에 레코드로 저장되며, 각 테이블마다 명확히 정의된 구조(필드의 이름, 데이터 유형)가 있습니다. 정해진 스키마에 따라야지만 데이터를 저장할 수 있습니다.</li>
  <li>데이터는 서로간에 관계를 통해 여러 테이블에 분산됩니다.</li>
</ul>

<p><strong>장점</strong></p>
<ul>
  <li>명확하게 스키마가 정의되어있으며, 데이터의 무결성을 보장합니다.</li>
  <li>관계는 각 테이블에 중복없이 한 번만 저장하도록 하여 중복도를 낮출 수 있습니다.</li>
</ul>

<p><strong>단점</strong></p>
<ul>
  <li>스키마가 정의되어 있기 때문에 덜 유연하며 스키마를 변경하려면 데이터들을 수정해야하는 문제가 발생할 수 있습니다.</li>
  <li>테이블 간에 관계를 맺고 있기 때문에, JOIN이 많은 복잡한 쿼리가 만들어지게 될 수 있습니다.</li>
  <li>대체적으로 수평적 확장이 힘들기 떄문에, 수직적 확장이 많습니다.</li>
</ul>

<p><strong>주로 사용하는 경우</strong></p>
<ul>
  <li>관계를 맺고 있는 데이터가 자주 변경되는 애플리케이션인 경우입니다.
(NoSQL은 중복된 값을 변경하려면 모든 컬렉션에서 수행해야하기 때문입니다.)</li>
  <li>변경될 여지가 없고, 명확한 스키마가 사용자와 데이터에게 중요한 경우입니다.</li>
</ul>

<h3 id="nosql">NoSQL</h3>
<ul>
  <li>NoSQL에서는 레코드를 도큐멘트라고 부릅니다.</li>
  <li>정해진 스키마를 따르지 않으면 데이터를 추가할 수 없는 SQL과 달리, 다른 구조의 데이터를 같은 컬렉션에 추가할 수 있습니다.</li>
  <li>도큐멘트는 Json과 비슷한 형태로 가지며, RDB와 같이 여러 테이블에 나누어 담는 것이 아닌, 동일한 컬렉션에 넣게 됩니다. 즉, JOIN할 필요 없이 이미 모든 것을 갖춘 문서를 작성하는 것이 기본 철학입니다.</li>
</ul>

<p><strong>장점</strong></p>
<ul>
  <li>스키마가 없기 때문에 유연하며, 언제든지 저장된 데이터를 조정하고 새로운 필드를 추가할 수 있습니다.</li>
  <li>데이터는 애플리케이션이 필요로 하는 형식으로 저장되며, 읽는 속도가 빨라집니다.</li>
  <li>수직 및 수평 확장이 가능하기 때문에 애플리케이션이 발생시키는 모든 읽기/쓰기 
요청을 처리할 수 있습니다.</li>
</ul>

<p><strong>단점</strong></p>
<ul>
  <li>너무 유연한 나머지, 데이터 구조를 결정하지 않고 사용하게 될 수 있습니다.</li>
  <li>데이터가 여러 컬렉션에 중복되어 있기 때문에 중복된 값 수정 시 모든 컬렉션에서 수행해야 합니다.</li>
</ul>

<p><strong>주로 사용하는 경우</strong></p>
<ul>
  <li>정확한 데이터 구조를 알 수 없거나 변경/확장이 될 수 있는 경우입니다.</li>
  <li>데이터 조회를 자주 하지만, 데이터 수정은 적은 경우입니다.</li>
  <li>막대한 양의 데이터를 다루기 위해 데이터베이스를 수평적으로 확장해야하는 경우입니다.</li>
</ul>

<h3 id="데이터베이스의-확장">데이터베이스의 확장</h3>
<p><strong>수직적 확장 (Scale up)</strong></p>
<ul>
  <li>단일 서버의 스펙(성능)을 단순히 향상시키는 것으로, CPU를 업그레이드하는 것입니다.</li>
  <li>서버의 스펙을 업그레이드 하는 동안 발생하는 다운타임(시스템 이용불가 시간)을 피할 수 없습니다.</li>
  <li>하나의 서버로 부하가 집중된다는 문제가 발생하며, 단일 장애점(Single Point of Failure, SPOF)을 갖게 됩니다.</li>
</ul>

<p><strong>수평적 확장 (Scale out)</strong></p>
<ul>
  <li>하나의 서버가 처리하는 일을 여러대의 서버가 처리하도록 만듭니다.</li>
  <li>한 서버처럼 사용하기 위한 클러스터링 작업에 추가비용이 발생하게 됩니다.
(예를 들어, 로드밸런스 등 네트워크 구축이 있습니다.)</li>
  <li>기술적으로나 관리적으로나 수직확장에 비해 까다롭습니다.</li>
  <li>수직적 확장과 다르게 단일 장애점을 가지고 있지 않기 때문에 장애상황에 치명적이지 않습니다.</li>
  <li>이론적으로 확장에 제한이 없기 때문에 무한대로 확장해나갈 수 있습니다.</li>
</ul>

<h2 id="transaction">Transaction</h2>
<ul>
  <li>데이터베이스의 상태를 변화시키기 위해 <code class="language-plaintext highlighter-rouge">수행하는 작업의 단위</code>입니다.</li>
  <li>commit: 하나의 트랜잭션이 성공적으로 끝났고, DB가 일관성있는 상태라면 변경된 상태를 영구적으로 반영하는 것입니다.</li>
  <li>rollback: 테이블 내에 입력/수정/삭제한 데이터에 대해 commit 이전 변경 사항을 취소합니다. 이 때, 관련된 행에 대한 잠금(locking)이 해제되고, 다른 사용자들이 데이터 변경을 가능하도록 합니다.</li>
  <li>savepoint: rollback 시, 트랜잭션에 포함된 전체 작업을 rollback하지 않고, 현시점에서 savepoint까지의 트랜잭션의 일부만 rollback 가능합니다.</li>
</ul>

<p><strong>특징</strong></p>
<ul>
  <li>Atomic(원자성): 트랜잭션이 DB에 모두 반영되거나, 전혀 반영되지 않아야 합니다.</li>
  <li>Consistency(일관성): 트랜잭션의 작업 처리 결과는 항상 일관성이 있어야 합니다.</li>
  <li>Isolation(독립성): 둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 때, 서로 다른 트랜잭션 연산은 독립적이어야 합니다.</li>
  <li>Durability(지속성): 트랜잭션이 성공적으로 완료된다면, 결과는 영구적으로 반영되어야 합니다.</li>
  <li>추가: 일관성은 기본 키, 외래 키 제약과 같은 명시적인 무결성 제약 조건들 뿐만 아니라, 이체 예시에서 두 계좌 잔고의 합은 이체 전후가 같아야 한다는 사항과 같은 비명시적인 일관성 조건들도 있습니다.</li>
</ul>

<h3 id="isolation-level-격리수준">Isolation Level (격리수준)</h3>
<p><strong>Read Uncommitted (Level 0)</strong></p>
<ul>
  <li>SELECT 문이 수행되는 동안 해당 데이터에 Shared Lock이 걸리지 않는 계층입니다.</li>
  <li>트랜잭션이 처리중이거나, 아직 commit되지 않은 데이터를 다른 트랜잭션이 읽는 것조차 허용합니다.</li>
  <li>데이터베이스의 일관성을 유지하는 것이 불가능합니다.</li>
</ul>

<p><strong>Read Committed (Level 1)</strong></p>
<ul>
  <li>대부분의 SQL 서버가 기본적으로 사용하는 격리수준입니다.</li>
  <li>커밋된 데이터만 조회할 수 있습니다. Phantom Read, Non-Retable Read 문제가 발생할 수 있습니다.</li>
  <li>트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어서 대기하게 됩니다.</li>
</ul>

<p><strong>Repeatable Read (Level 2)</strong></p>
<ul>
  <li>MySQL에서 기본으로 사용하는 격리수준입니다.</li>
  <li>일반적인 RDBMS는 변경 전의 레코드를 언두 공간에 백업해둡니다. 
(MVCC. 동일한 레코드에 대해 여러 버전의 데이터가 존재)</li>
  <li>트랜잭션이 롤백된 경우에 데이터를 복원할 수 있을 뿐 아니라,</li>
  <li>트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Loack이 걸리는 단계입니다.</li>
  <li>트랜잭션이 범위 내에서 조회한 데이터 내용이 항상 동일함을 보장합니다.</li>
  <li>다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정이 불가능합니다.</li>
</ul>

<p><strong>Serializable (Level 3)</strong></p>
<ul>
  <li>여러 트랜잭션이 동일한 레코드에 동시에 접근(읽기/쓰기/수정 모두)할 수 없습니다. 하지만, 트랜잭션이 순차적으로 처리되어야 하기 때문에 동시처리 성능이 매우 떨어집니다.</li>
  <li>순수한 SELECT 작업에 대해서도 대상 레코드에 넥스트 키 락을 읽기잠금(공유락, Shared Lock)으로 겁니다.</li>
  <li>완벽한 읽기 일관성 모드를 제공합니다.</li>
</ul>

<h3 id="격리수준이-낮을-때-발생할-수-있는-문제">격리수준이 낮을 때 발생할 수 있는 문제</h3>

<p><strong>Dirty Read</strong></p>
<ul>
  <li>발생 격리 수준: Read Uncommitted</li>
  <li>어떤 트랜잭션에서 아직 실행이 끝나지 않았을 때, <code class="language-plaintext highlighter-rouge">다른 트랜잭션에 의한 변경 사항</code>을 트랜잭션 수행 중 조회하게 되는 경우입니다.</li>
  <li>커밋되지 않은 수정중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할 때 발생합니다.</li>
</ul>

<p><strong>Non-Repeatable Read</strong></p>
<ul>
  <li>발생 격리 수준: Read Committed, Read Uncommitted</li>
  <li>한 트랜잭션에서 같은 쿼리를 두 번 수행할 때, 그 사이에 다른 트랜잭션 값을 수정/삭제 하면서 두 쿼리의 결과가 다르게 나타나며 일관성이 깨지는 현상입니다.</li>
</ul>

<p><strong>Phantom Read</strong></p>
<ul>
  <li>발생 격리 수준: Repeatable Read, Read Committed, Read Uncommitted</li>
  <li>트랜잭션 도중에 새로운 레코드 삽입을 허용하기 때문에 나타나는 현상입니다.</li>
  <li>한 트랜잭션 안에서 일정 범위의 레코드를 두 번 이상 읽을 때, 첫 번째 쿼리에서 없던 레코드가 두 번째 쿼리에서 나타나는 현상입니다.</li>
</ul>

<h3 id="dbms의-구조">DBMS의 구조</h3>
<ul>
  <li>크게 <code class="language-plaintext highlighter-rouge">Query Processor</code>와 <code class="language-plaintext highlighter-rouge">Storage System</code>이 있습니다.</li>
  <li>입출력은 고정 길이의 page 단위로 disk에 읽거나 씁니다.</li>
  <li>저장 공간은 비휘발성 저장 장치인 disk에 저장하며, 일부를 Main Memory에 저장합니다.</li>
</ul>

<h3 id="page-buffer-manageror-buffer-manager">Page Buffer Manager(or Buffer Manager)</h3>
<ul>
  <li>DBMS의 Storage System에 속하는 모듈 중 하나로, Main Memory에 유지하는 페이지를 관리합니다.</li>
  <li>Buffer 관리 정책에 따라서, UNDO 복구와 REDO 복구가 요구되거나 그렇지 않게 되므로, transaction 관리에 매우 중요한 결정을 합니다.</li>
</ul>

<h3 id="undo">UNDO</h3>
<ul>
  <li>트랜잭션은 시작 됐지만 아직 완료되지 않은 commit되지 않은 부분에 대해 연산을 취소합니다.</li>
  <li>수정된 Page들이 <strong>Buffer 교체 알고리즘에 따라 디스크에 출력</strong>될 수 있습니다.</li>
  <li>Buffer 관리 정책에 영향을 받습니다.</li>
</ul>

<h3 id="redo">REDO</h3>
<ul>
  <li>이미 commit된 transaction의 수정을 재반영하는 복구 작업입니다.</li>
  <li>Buffer 관리 정책에 영향을 받습니다.</li>
</ul>

<h3 id="참고자료">참고자료</h3>
<ul>
  <li><a href="https://d2.naver.com/helloworld/407507">Naver D2 블로그</a> - DBMS 구조</li>
  <li><a href="https://mangkyu.tistory.com/299">mangkuy님의 블로그</a> - transaction isolation level</li>
  <li><a href="https://youtu.be/sLJ8ypeHGlM?si=xMBEnPdTyh4w1p3t">쉬운코드님 강의</a></li>
</ul>]]></content><author><name>Yeham Kim</name></author><category term="Study" /><summary type="html"><![CDATA[SQL과 NoSQL]]></summary></entry><entry><title type="html">[Study] Django - 코딩 스타일</title><link href="http://localhost:4000/django%20study/study-django-coding-style/" rel="alternate" type="text/html" title="[Study] Django - 코딩 스타일" /><published>2023-08-15T00:05:07+09:00</published><updated>2023-08-15T00:05:07+09:00</updated><id>http://localhost:4000/django%20study/study-django-coding-style</id><content type="html" xml:base="http://localhost:4000/django%20study/study-django-coding-style/"><![CDATA[<h3 id="pre-commit-checks">Pre-commit checks</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">flake8</code> 모듈을 사용하여 코딩 컨벤션을 확인하는 방법도 있습니다.</li>
  <li><code class="language-plaintext highlighter-rouge">git hook</code>: git과 관련된 이벤트 발생시, 특정 스크립트를 실행할 수 있도록 하는 기능입니다.</li>
  <li><code class="language-plaintext highlighter-rouge">pre-commit</code>은 pre-commit hook들을 관리하는 프레임워크로, 이를 통해 리뷰를 위한 코드 커밋 전, 간단한 이슈들을 확인할 수 있습니다.</li>
</ul>

<h3 id="python-style">Python style</h3>
<ul>
  <li>모든 파일은 <code class="language-plaintext highlighter-rouge">black auto-fomatter</code>를 사용하여 포맷되어야합니다.</li>
  <li>프로젝트 레포지토리는 <code class="language-plaintext highlighter-rouge">.editorconfig</code> 파일을 포함해야합니다.</li>
  <li>장고 운영진은 whitespace 이슈들을 피하기 위해 <code class="language-plaintext highlighter-rouge">EditorConfig</code>와 함께 텍스트 에디터를 사용하는 것을 추천합니다.</li>
  <li>만약 구체적으로 정한 부분이 없으면 대체적으로, <code class="language-plaintext highlighter-rouge">PEP 8</code> 따릅니다.</li>
  <li>스트링 값은 <code class="language-plaintext highlighter-rouge">%-formatting</code>, <code class="language-plaintext highlighter-rouge">f-string</code>, <code class="language-plaintext highlighter-rouge">str.format()</code> 형태로 사용하는 것을 권장합니다. (가독성) 또한, <code class="language-plaintext highlighter-rouge">f-string</code> 사용시 plain variable로 사용해야합니다.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1"># Disallowed
</span>  <span class="sa">f</span><span class="sh">"</span><span class="s">hello </span><span class="si">{</span><span class="nf">get_user</span><span class="p">()</span><span class="si">}</span><span class="sh">"</span>
    
  <span class="c1"># Allowed
</span>  <span class="n">user</span> <span class="o">=</span> <span class="nf">get_user</span><span class="p">()</span>
  <span class="sa">f</span><span class="sh">"</span><span class="s">hello </span><span class="si">{</span><span class="n">user</span><span class="si">}</span><span class="sh">""</span><span class="s">
</span></code></pre></div>    </div>
  </li>
  <li>camel 표기법 보다 snake 표기법을 권장합니다.</li>
  <li>docstring은 <code class="language-plaintext highlighter-rouge">PEP 257</code> 스타일을 따릅니다.</li>
  <li>테스트 수행 시, <code class="language-plaintext highlighter-rouge">assertRaises()</code>를 사용하기 보다, <code class="language-plaintext highlighter-rouge">assertRaisesMessage()</code>와 <code class="language-plaintext highlighter-rouge">assertWarnsMessage()</code>를 사용하여, 예외에 대한 경고 메시지까지 함꼐 봅니다.</li>
  <li><code class="language-plaintext highlighter-rouge">assertRaisesRegex()</code>와 <code class="language-plaintext highlighter-rouge">assertWarnsRegex()</code>는 정규식 매칭이 필요한 경우에만 사용합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">assertTrue()</code>와 <code class="language-plaintext highlighter-rouge">assertFalse()</code> 보다 <code class="language-plaintext highlighter-rouge">assertIs(..., True/False)</code>를 사용합니다.</li>
</ul>

<h3 id="imports">Imports</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">isort</code> 모듈을 사용하여 import를 자동으로 소팅합니다.</li>
  <li>아래와 같이 그룹별로 모듈을 묶어서 import 합니다.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1"># future
</span>  <span class="bp">...</span>
  <span class="c1"># standard library
</span>  <span class="bp">...</span>
  <span class="c1"># third-party
</span>  <span class="bp">...</span>
  <span class="c1"># Django
</span>  <span class="bp">...</span>
  <span class="c1"># local Django
</span>  <span class="bp">...</span>
  <span class="c1"># try/except
</span>  <span class="bp">...</span>
</code></pre></div>    </div>
  </li>
  <li><code class="language-plaintext highlighter-rouge">import ...</code>만 사용하는 경우를 <code class="language-plaintext highlighter-rouge">from ... import ...</code>로 모듈을 호출하는 경우들보다 상위에 위치시킵니다.</li>
  <li>알파벳 순서로 모듈을 호출하는 것을 권장합니다.</li>
  <li>너무 긴 모듈 호출은 끊어서 구분합니다. (4 space와 trailing comma 사용)</li>
</ul>

<h3 id="template-style">Template style</h3>
<ul>
  <li>중괄호 사이의 tag comment들 사이에는 공백을 삽입합니다.
(<code class="language-plaintext highlighter-rouge"> -&gt; </code>)</li>
</ul>

<h3 id="view-style">View style</h3>
<ul>
  <li>view 함수의 첫 번째 파라미터는 <code class="language-plaintext highlighter-rouge">req</code>가 아닌 <code class="language-plaintext highlighter-rouge">request</code>로 확실히 표기합니다.</li>
</ul>

<h3 id="model-style">Model style</h3>
<ul>
  <li>필드명은 소문자 snake 표기법을 사용하여 정의합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">class Meta</code>는 필드 정의 뒤에 single line을 공백으로 둔 후, 정의합니다.</li>
  <li>모델 메서드의 정의 순서는 아래와 같습니다.
    <ul>
      <li>All database fields</li>
      <li>Custom manager attributes</li>
      <li><code class="language-plaintext highlighter-rouge">class Meta</code></li>
      <li><code class="language-plaintext highlighter-rouge">def __str__()</code></li>
      <li><code class="language-plaintext highlighter-rouge">def save()</code></li>
      <li><code class="language-plaintext highlighter-rouge">def get_absolute_url()</code></li>
      <li>Any custom method</li>
    </ul>
  </li>
</ul>

<h3 id="djangoconfsettings-사용하기"><code class="language-plaintext highlighter-rouge">django.conf.settings</code> 사용하기</h3>
<ul>
  <li>모듈들은 일반적으로 최상위 레벨의 <code class="language-plaintext highlighter-rouge">django.conf.settings</code>에 저장된 설정들을 사용하지 않도록 해야합니다.</li>
  <li>환경변수인 <code class="language-plaintext highlighter-rouge">DJANGO_SETTINGS_MODULE</code>에 의존하지 않도록 설정해야합니다.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kn">from</span> <span class="n">django.conf</span> <span class="kn">import</span> <span class="n">settings</span>
  <span class="n">setting</span><span class="p">.</span><span class="nf">configure</span><span class="p">({},</span> <span class="n">SOME_SETTING</span><span class="o">=</span><span class="sh">"</span><span class="s">foo</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
</ul>]]></content><author><name>Yeham Kim</name></author><category term="Django Study" /><summary type="html"><![CDATA[Pre-commit checks flake8 모듈을 사용하여 코딩 컨벤션을 확인하는 방법도 있습니다. git hook: git과 관련된 이벤트 발생시, 특정 스크립트를 실행할 수 있도록 하는 기능입니다. pre-commit은 pre-commit hook들을 관리하는 프레임워크로, 이를 통해 리뷰를 위한 코드 커밋 전, 간단한 이슈들을 확인할 수 있습니다.]]></summary></entry><entry><title type="html">[Study] Django - 설계 철학</title><link href="http://localhost:4000/django%20study/study-django-philosophy/" rel="alternate" type="text/html" title="[Study] Django - 설계 철학" /><published>2023-08-15T00:05:07+09:00</published><updated>2023-08-15T00:05:07+09:00</updated><id>http://localhost:4000/django%20study/study-django-philosophy</id><content type="html" xml:base="http://localhost:4000/django%20study/study-django-philosophy/"><![CDATA[<h3 id="기본을-충실히-하자">기본을 충실히 하자!</h3>
<ul>
  <li>구현을 서둘러 하다보니, 기본적인 프레임워크의 철학과 기본기를 돌아볼 여유가 없어왔던 것 같습니다.</li>
  <li>프레임워크에 대해서나 왜 사용하게 되었는지를 생각해 볼 때 설득력있는 설명을 할 수 있는 방법이 궁금했습니다.</li>
</ul>

<h2 id="설계-철학">설계 철학</h2>

<h3 id="django를-선택하는-이유">Django를 선택하는 이유</h3>
<ul>
  <li>개발이 빠릅니다. Django는 포괄적인 도구와 라이브러리를 제공하여 새로운 프로젝트를 신속하게 구축할 수 있도록 합니다.</li>
  <li>확장성이 좋습니다. 트래픽이 증가하는 등 요구사항이 증가함에 따라 쉽게 확장할 수 있도록 설계되어있습니다.</li>
  <li>보안에 대해 강조합니다. 사이트 간 스크립팅(XSS), 요청 위조(CSRF), SQL 인젝션 등과 같은 취약점에 대해 내장된 보호 기능을 갖추고 있습니다.</li>
  <li>서드파티 패키지나 플러그인을 함께 사용하기 편리합니다.</li>
</ul>

<h3 id="일반">일반</h3>
<ul>
  <li>Django는 Python을 사용한 견고하고 확장 가능한 웹어플리케이션을 개발하기 위한 고수준 오픈소스 웹 프레임워크입니다.</li>
  <li>Django 스택의 근본적인 목표는, 느슨한 결합과 탄탄한 응집으로 프레임워크의 각 계층이 서로 알지 못하도록 하는 것이 기본 원칙입니다.</li>
  <li>Django는 가능한 한 최소한의 코드를 사용하고, 틀에 박힌 코드를 배제하며, Python의 동적인 기능(ex. introspection)을 최대한 활용합니다.
    <blockquote>
      <p>introspection이란, 런타임 동안 객체의 타입을 결정하는 능력입니다. 파이썬의 모든 것은 객체이고, 객체가 지원하는 내장 함수와 모듈들이 있습니다.</p>
    </blockquote>
  </li>
  <li>DRY: 중복성을 최소화하고, 최소한의 것들을 가지고 최대한의 것을 만들어내도록 합니다.</li>
  <li>명시적인 것이 묵시적인 것보다 낫다는 PEP20을 따릅니다.</li>
  <li>프레임워크는 모든 수준에서 일관적이어야 합니다. 이는 저수준(python code style)에서 고수준(django framework)에 이르기까지 적용됩니다.</li>
</ul>

<h3 id="모델">모델</h3>
<ul>
  <li>명시적인 것이 묵시적인 것보다 나음으로, 필드의 성질은 키워드 인자에 근거해야 하며, 경우에 따라서는 필드의 유형에 근거해야합니다.</li>
  <li>활성 레코드 디자인 패턴에 따라 “객체”의 모든 aspect를 캡슐화해야합니다.</li>
  <li>데이터를 모델로 표현하고, 모델을 이해하는 데 요구되는 모든 정보가 모델 내에 있어야 합니다.</li>
</ul>

<h3 id="데이터베이스-api">데이터베이스 API</h3>
<ul>
  <li>SQL문은 가능한 적은 횟수로 실행해야 하며, 내부적으로 최적화해야합니다.</li>
  <li>프레임워크에서 <code class="language-plaintext highlighter-rouge">save()</code>를 조용히 처리하는 것이 아닌, 개발자가 명시적으로 <code class="language-plaintext highlighter-rouge">save()</code>를 호출하도록 되어 있습니다.</li>
  <li><code class="language-plaintext highlighter-rouge">join</code> 명령어가 요구될 때에는 겉으로 드러나지 않게 자동으로 수행되어야 합니다.</li>
  <li>모든 객체는 시스템의 모든 관련 객체에 접근할 수 있어야 하며, 이러한 접근은 양방향이어야합니다.</li>
  <li>필요할 경우에 SQL 문을 직접 작성하기 쉽게 설계해야합니다.</li>
</ul>

<h3 id="url-설계">URL 설계</h3>
<ul>
  <li>Django 앱의 URL을 Python 함수 이름과 같게 만드는 것은 좋지 않습니다.</li>
  <li>웹페이지 URL에 파일 확장자를 넣는 것은 지양해야합니다.</li>
  <li>기술적으로 <code class="language-plaintext highlighter-rouge">foo.com/bar</code>와 <code class="language-plaintext highlighter-rouge">foo.com/bar/</code>는 서로 다른 URL이며, 검색 엔진 로봇은 이를 별도로 취급합니다.</li>
  <li>따라서, APPEND_SLASH 설정을 True로 하는 경우, <code class="language-plaintext highlighter-rouge">/</code>가 붙지 않더라도 리다이렉션 시킵니다.
    <blockquote>
      <p>주의: POST 메서드를 사용하는 경우 리다이렉트를 사용해버리면 데이터가 소실될 가능성도 있습니다.</p>
    </blockquote>
  </li>
</ul>

<h3 id="django의-mvt-아키텍처-model-view-template">Django의 MVT 아키텍처 (Model View Template)</h3>

<p><strong>Model</strong></p>
<ul>
  <li>데이터의 구조를 나타내며, CRUD에 대해 정의합니다.</li>
  <li>테이블의 구조와 각 테이블 간의 관계를 정의하는 Python 클래스입니다.</li>
</ul>

<p><strong>View</strong></p>
<ul>
  <li>사용자 요청을 처리하고 적절한 응답을 반환합니다.</li>
  <li>데이터를 검색한 뒤, HTTP 응답을 반환하는 Python 함수로, Template이나 Json을 반환합니다.</li>
</ul>

<p><strong>Template</strong></p>
<ul>
  <li>클라이언트로 전송되는 HTML의 구조와 레이아웃을 정의합니다.</li>
  <li>텍스트 파일로서, HTML 구조를 응용하여 동적 컨텐츠를 포함할 수 있도록합니다.</li>
</ul>

<h3 id="template">Template</h3>
<ul>
  <li>표현과 로직을 분리해야합니다.</li>
  <li>대다수의 동적인 웹사이트는 공통 헤더, 푸터, 네비게이션 바와 같은 사이트의 공통 디자인을 갖습니다. Django 템플릿 시스템은 이러한 요소를 한 곳에 저장하기 쉽게하여 중복 코드를 없애야합니다.</li>
  <li>템플릿은 HTML 뿐만 아니라, 텍스트 기반 포맷 또는 일반 텍스트도 잘 생성할 수 있어야 합니다.</li>
  <li>XML을 템플릿 언어로 사용하지 않아야 합니다.</li>
  <li>템플릿은 데이터베이스의 레코드를 삭제하는 명령과 같은 악의적인 코드를 포함할 수 없어야 합니다.</li>
</ul>

<h3 id="view">View</h3>
<ul>
  <li>함수로 처리할 수 있는 일을 하기 위해 클래스의 인스턴스를 굳이 생성하지 않아도 됩니다.</li>
  <li>글로벌 변수의 요청 데이터에 접근하는 것이 아닌 뷰 함수에 전달된 요청 객체에 각각 접근해야합니다.</li>
  <li>뷰는 개발자가 어떤 템플릿을 사용하는지에 무관해야합니다.</li>
</ul>]]></content><author><name>Yeham Kim</name></author><category term="Django Study" /><summary type="html"><![CDATA[기본을 충실히 하자! 구현을 서둘러 하다보니, 기본적인 프레임워크의 철학과 기본기를 돌아볼 여유가 없어왔던 것 같습니다. 프레임워크에 대해서나 왜 사용하게 되었는지를 생각해 볼 때 설득력있는 설명을 할 수 있는 방법이 궁금했습니다.]]></summary></entry><entry><title type="html">[Study] Django - ORM Basic</title><link href="http://localhost:4000/django%20study/study-django-orm-basic/" rel="alternate" type="text/html" title="[Study] Django - ORM Basic" /><published>2023-08-12T00:05:07+09:00</published><updated>2023-08-12T00:05:07+09:00</updated><id>http://localhost:4000/django%20study/study-django-orm-basic</id><content type="html" xml:base="http://localhost:4000/django%20study/study-django-orm-basic/"><![CDATA[<h2 id="orm이란-무엇인가">ORM이란 무엇인가?</h2>

<ul>
  <li>객체지향 프로그래밍은 클래스를 사용하지만, 관계형 데이터베이스는 테이블을 사용하기 때문에, 객체 모델과 관계형 모델 간에 불일치가 발생합니다.</li>
  <li>ORM은 SQL문을 자동으로 생성하여 이러한 불일치를 해결할 수 있습니다.</li>
</ul>

<h2 id="orm의-장단점">ORM의 장단점</h2>

<h3 id="장점">장점</h3>

<ul>
  <li>완벽한 객체지향적인 코드
    <ul>
      <li>SQL문이 아닌 클래스의 메서드를 통한 데이터베이스 조작이 가능하기 때문에, 개발자가 객체 모델만을 이용해서 프로그래밍을하는데 집중할 수 있습니다.</li>
      <li>SQL문을 사용하며 함께 필요한 선언문, 할당, 종료와 같은 부수적인 코드가 사라지거나 줄어들게 됩니다.</li>
    </ul>
  </li>
  <li>재사용, 유지보수, 리팩토링이 용이합니다.</li>
  <li>DBMS에 대한 종속성이 줄어듭니다.
    <ul>
      <li>객체 간의 관계를 바탕으로 SQL문을 자동으로 생성하며, 객체의 자료형 타입까지 사용할 수 있습니다.</li>
      <li>따라서, RDBMS의 데이터 구조와 객체지향 모델 사이의 간격을 좁힐 수 있습니다.</li>
    </ul>
  </li>
</ul>

<h3 id="단점">단점</h3>

<ul>
  <li>프로젝트의 복잡성이 커질수록 난이도도 올라가고, 잘못 구현되는 경우 속도 저하가 발생합니다. 일관성을 무너뜨리게 될 수도 있습니다.</li>
  <li>잘못된 사용으루 N+1 문제와 같은 비효율적인 동작을 야기할 수 있습니다.</li>
  <li>대형 SQL문은 속도를 위해 별도의 튜닝이 필요하므로, 결국 SQL문법을 사용해야할 때가 생깁니다.</li>
  <li>쿼리문이 복잡한 경우, SQL문 사용이 직관적이고 효율적일 수 있습니다.</li>
</ul>

<h3 id="orm을-적절하게-사용하는-방법">ORM을 적절하게 사용하는 방법</h3>

<p><strong>타겟 DB를 이해하기</strong></p>

<ul>
  <li>SQL 및 DB의 locking 모델을 무시하면 안됩니다.</li>
  <li>ORM 적용 환경에서 발생하는 많은 부류의 문제들은 DB와 SQL의 문제를 간과함에서 발생합니다.</li>
</ul>

<p><strong>필요한 경우 SQL을 사용하기</strong></p>

<ul>
  <li>Hibernate, TopLink와 같은 ORM들은 SQL 쿼리 작성 기능을 제공하지만, 경우에 따라 SQL문을 직접 작성해야합니다.</li>
</ul>

<p><strong>O-R 매핑 제품을 선택하기 전에 충분히 검토하기</strong></p>

<ul>
  <li>모든 ORM 제품이 동일한 수준의 기능을 제공하지 않기 때문에, 요구 사항을 반영하는 환경을 구축하고 제품들을 비교, 테스트 해야합니다.</li>
  <li>엔터프라이즈 개발 과정의 다른 요소들과 마찬가지로, 프로젝트 라이프사이클 초기 단계에서 성능과 관련된 리스크를 최소화하는 것이 중요합니다.</li>
  <li>매핑 기능에 과도한 오버헤드가 수반되지 않는지 분석해야 합니다.</li>
</ul>

<p><strong>ORM이 적절히 사용될 수 있는 상황을 이해하기</strong></p>

<ul>
  <li>ORM은 엔티티를 개별적으로 업데이트하고 간헐적으로 셋 기반 작업을 수행하는 OLTP 애플리케이션이 적합합니다.</li>
</ul>

<p><strong>ORM이 적합하지 않은 경우</strong></p>

<ul>
  <li>많은 수의 레코드에 대해 잦은 빈도로 bulk 업데이트를 수행하는 애플리케이션(OLAP 애플리케이션)</li>
  <li>데이터 마이닝을 위해 사용되는 애플리케이션에서는 이미 데이터를 본래의 엔티티 상태로 사용하기 어렵습니다.</li>
  <li>데이터의 인출 및 업데이트를 위해 핸드코딩으로 작성된 SQL 및 저장 프로시저를 이용하는 DB 환경</li>
  <li>순수 SQL 기반 접근 방법을 적용하는 것이 적절한 애플리케이션
    <ul>
      <li>비즈니스 로직의 대부분이 DB에 이미 구현되어 있거나, 데이터베이스 무결성 제약(integrity constraint)이 적용된 경우 등입니다.</li>
      <li>이러한 애플리케이션에서는 오브젝트 또는 ORM의 활용 여지가 적으며, 데이터베이스 테이블을 도메인 오브젝트로 모델링 함으로써 기대할 수 있는 효과가 거의 없습니다.</li>
    </ul>
  </li>
</ul>

<h2 id="django-orm의-특징">Django ORM의 특징</h2>

<h3 id="queryset">QuerySet</h3>

<ul>
  <li>Django ORM을 통해 생성된 자료형으로, 데이터베이스의 테이블로부터 가져온 객체의 목록입니다.</li>
</ul>

<h3 id="lazy-loading">Lazy Loading</h3>

<ul>
  <li>필요한 시점에만 SQL을 호출하는 Lazy한 특성이 있습니다.</li>
  <li><code class="language-plaintext highlighter-rouge">users=User.objects.all()</code> 문법을 사용하더라도, 이 때 DB를 호출하는 것이 아닌, <code class="language-plaintext highlighter-rouge">user=users[0]</code>, <code class="language-plaintext highlighter-rouge">list(users)</code>와 같이 실제 파이썬에서 해당 데이터를 사용할 때 호출됩니다.</li>
  <li>따라서, <code class="language-plaintext highlighter-rouge">Result Cache</code>를 통해 미리 데이터를 캐싱해두는 것이 더 효율적입니다. <code class="language-plaintext highlighter-rouge">user_list=list(User.objects.all())</code></li>
  <li>지연 로딩의 또 다른 문제는, 외래키 관계에 있는 데이터를 참조해서 호출할 때 발생합니다. lazy-loading은 쿼리문이 날라갈 때 당장 필요하지 않기 때문에 참조모델의 데이터는 가지고 오지 않고 해당 모델이 갖는 한개의 데이터를 가져옵니다.</li>
  <li>따라서, 외래키 값을 호출할 때 한 번 더 쿼리가 날라가는 <code class="language-plaintext highlighter-rouge">N+1 문제</code>가 발생하게 됩니다.</li>
</ul>

<h3 id="eager-loading">Eager Loading</h3>

<ul>
  <li>N+1 문제를 해결하기 위해, <code class="language-plaintext highlighter-rouge">select_related()</code>와 <code class="language-plaintext highlighter-rouge">prefetch_related()</code> 메서드로 즉시 로딩할 수 있습니다.</li>
  <li><code class="language-plaintext highlighter-rouge">select_related()</code>는 join을 통해 데이터를 즉시 로딩하는 방법으로, 정참조 외래키에서 사용됩니다.</li>
  <li><code class="language-plaintext highlighter-rouge">prefetch_related()</code>: 추가 쿼리를 수행해서 데이터를 즉시 로딩하는 방법으로, 역참조 외래키에서 사용됩니다.</li>
</ul>

<h2 id="참고">참고</h2>
<ul>
  <li><a href="https://bentist.tistory.com/109">bentist님의 블로그</a></li>
</ul>]]></content><author><name>Yeham Kim</name></author><category term="Django Study" /><summary type="html"><![CDATA[ORM이란 무엇인가?]]></summary></entry></feed>