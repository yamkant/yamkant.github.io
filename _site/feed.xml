<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-08-21T15:14:00+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Yam’s Dev Logs</title><subtitle>An amazing website.</subtitle><author><name>Yeham Kim</name></author><entry><title type="html">[Django Strategy] permissions</title><link href="http://localhost:4000/django%20strategy/study-django-strategy-permissions/" rel="alternate" type="text/html" title="[Django Strategy] permissions" /><published>2023-08-21T00:05:07+09:00</published><updated>2023-08-21T00:05:07+09:00</updated><id>http://localhost:4000/django%20strategy/study-django-strategy-permissions</id><content type="html" xml:base="http://localhost:4000/django%20strategy/study-django-strategy-permissions/"><![CDATA[<h3 id="글을-작성한-계기">글을 작성한 계기</h3>
<ul>
  <li>최근 과제전형을 보며, 백오피스로 주로 사용하는 Django에서 권한 관리에 대한 중요성을 많이 느끼게 되었습니다.</li>
  <li>ViewSet의 메서드를 사용할 때 Global Permission을 적용시켜야 하는지, Object-level Permission을 적용시켜야하는지 등 기본에 충실해서 학습해야함을 느꼈습니다.</li>
  <li>아래 내용들은 단순히 DRF 문서의 번역이 아닌, 실제 사용하며 분석한 내용과 사용 전략이 포함되어있습니다.</li>
</ul>

<h2 id="django-permissions">Django Permissions</h2>
<ul>
  <li>ModelViewSet등 APIView 기반의 뷰를 사용하기 위해 권한이 있는 사용자만 사용할 수 있도록 제한해야하는 경우가 있습니다.</li>
</ul>

<h3 id="기본적인-형태">기본적인 형태</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">UserViewSet</span><span class="p">(</span><span class="n">viewsets</span><span class="p">.</span><span class="n">ModelViewSet</span><span class="p">):</span>
    <span class="n">serializer_class</span> <span class="o">=</span> <span class="n">UserSerializer</span>
    <span class="n">queryset</span> <span class="o">=</span> <span class="n">User</span><span class="p">.</span><span class="n">objects</span><span class="p">.</span><span class="nf">all</span><span class="p">()</span>
    <span class="c1"># permission_classes = [IsAccountAdminOrReadOnly]
</span>
    <span class="k">def</span> <span class="nf">get_permissions</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">action</span> <span class="o">==</span> <span class="sh">'</span><span class="s">list</span><span class="sh">'</span><span class="p">:</span>
            <span class="n">permission_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">IsAuthenticated</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">permission_classes</span> <span class="o">=</span> <span class="p">[</span><span class="n">IsAdminUser</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="nf">permission</span><span class="p">()</span> <span class="k">for</span> <span class="n">permission</span> <span class="ow">in</span> <span class="n">permission_classes</span><span class="p">]</span>
</code></pre></div></div>
<ul>
  <li>ViewSet 내의 모든 메서드에 공통적인 Permission Class를 적용하기 위해서는 ViewSet의 클래스 변수로 처리합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">permission_classes</code>에 custom permission 클래스들을 추가하여 원하는 권한에 해당하는 사용자만 메서드를 이용할 수 있도록 전처리할 수 있습니다.</li>
  <li>이 때, ViewSet의 클래스 메서드인 <code class="language-plaintext highlighter-rouge">get_queryset</code>는 필수적입니다.</li>
  <li>method에 따라 적용하는 권한이 변경된다면, <code class="language-plaintext highlighter-rouge">get_permissions</code> 메서드를 이용합니다.</li>
</ul>

<h3 id="custom-permission-class">Custom Permission Class</h3>
<ul>
  <li>DRF에서 제공하는 <code class="language-plaintext highlighter-rouge">BasePermission</code>를 상속받는 커스텀 Permission은 아래와 같은 형태를 가지며, <code class="language-plaintext highlighter-rouge">has_permission</code> 또는 <code class="language-plaintext highlighter-rouge">has_object_permission</code>를 override하여 사용합니다.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">BasePermission</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">BasePermissionMetaclass</span><span class="p">):</span>
      <span class="k">def</span> <span class="nf">has_permission</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">view</span><span class="p">):</span>
          <span class="k">return</span> <span class="bp">True</span>

      <span class="k">def</span> <span class="nf">has_object_permission</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
          <span class="k">return</span> <span class="bp">True</span>

  <span class="n">SAFE_METHODS</span> <span class="o">=</span> <span class="p">(</span><span class="sh">'</span><span class="s">GET</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">HEAD</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">OPTIONS</span><span class="sh">'</span><span class="p">)</span>
  <span class="k">class</span> <span class="nc">ReadOnly</span><span class="p">(</span><span class="n">BasePermission</span><span class="p">):</span>
      <span class="k">def</span> <span class="nf">has_permission</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">view</span><span class="p">):</span>
          <span class="k">return</span> <span class="n">request</span><span class="p">.</span><span class="n">method</span> <span class="ow">in</span> <span class="n">SAFE_METHODS</span>

  <span class="k">class</span> <span class="nc">IsOwner</span><span class="p">(</span><span class="n">BasePermission</span><span class="p">):</span>
      <span class="k">def</span> <span class="nf">has_permission</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">view</span><span class="p">):</span>
          <span class="k">return</span> <span class="n">request</span><span class="p">.</span><span class="n">method</span> <span class="ow">in</span> <span class="n">SAFE_METHODS</span>

      <span class="k">def</span> <span class="nf">has_object_permission</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
          <span class="k">return</span> <span class="n">obj</span><span class="p">.</span><span class="n">owner</span> <span class="o">==</span> <span class="n">request</span><span class="p">.</span><span class="n">user</span>
</code></pre></div>    </div>
  </li>
  <li>권한이 있으면 True를, 아니면 False를 반환하도록 설계합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">has_object_permission</code>는 <code class="language-plaintext highlighter-rouge">has_permission</code> 검사를 통과한 이 후에 실행됩니다.</li>
  <li><code class="language-plaintext highlighter-rouge">ModelViewSet</code>이 상속받는 <code class="language-plaintext highlighter-rouge">GenericAPIView</code>에 <code class="language-plaintext highlighter-rouge">get_object</code> 메서드 내부에 <code class="language-plaintext highlighter-rouge">self.check_object_permissions</code>는 해당 object가 지정해둔 permission에 따라 권한을 갖는지를 판단합니다.</li>
  <li>Django의 mixins 모듈을 살펴보면, <code class="language-plaintext highlighter-rouge">get_object</code> 메서드를 사용하는 믹스인은 detail 관련 <code class="language-plaintext highlighter-rouge">Retrieve</code>(조회), <code class="language-plaintext highlighter-rouge">Update</code>(수정), <code class="language-plaintext highlighter-rouge">Destroy</code>(삭제) 모듈에서 사용하게 되며, 이 때 object-level Permission을 확인합니다.</li>
</ul>]]></content><author><name>Yeham Kim</name></author><category term="Django Strategy" /><summary type="html"><![CDATA[글을 작성한 계기 최근 과제전형을 보며, 백오피스로 주로 사용하는 Django에서 권한 관리에 대한 중요성을 많이 느끼게 되었습니다. ViewSet의 메서드를 사용할 때 Global Permission을 적용시켜야 하는지, Object-level Permission을 적용시켜야하는지 등 기본에 충실해서 학습해야함을 느꼈습니다. 아래 내용들은 단순히 DRF 문서의 번역이 아닌, 실제 사용하며 분석한 내용과 사용 전략이 포함되어있습니다.]]></summary></entry><entry><title type="html">[Study] Database</title><link href="http://localhost:4000/study/study-cs-database/" rel="alternate" type="text/html" title="[Study] Database" /><published>2023-08-16T00:05:07+09:00</published><updated>2023-08-16T00:05:07+09:00</updated><id>http://localhost:4000/study/study-cs-database</id><content type="html" xml:base="http://localhost:4000/study/study-cs-database/"><![CDATA[<h2 id="sql과-nosql">SQL과 NoSQL</h2>

<h3 id="sql">SQL</h3>
<ul>
  <li>데이터는 테이블에 레코드로 저장되며, 각 테이블마다 명확히 정의된 구조(필드의 이름, 데이터 유형)가 있습니다. 정해진 스키마에 따라야지만 데이터를 저장할 수 있습니다.</li>
  <li>데이터는 서로간에 관계를 통해 여러 테이블에 분산됩니다.</li>
</ul>

<p><strong>장점</strong></p>
<ul>
  <li>명확하게 스키마가 정의되어있으며, 데이터의 무결성을 보장합니다.</li>
  <li>관계는 각 테이블에 중복없이 한 번만 저장하도록 하여 중복도를 낮출 수 있습니다.</li>
</ul>

<p><strong>단점</strong></p>
<ul>
  <li>스키마가 정의되어 있기 때문에 덜 유연하며 스키마를 변경하려면 데이터들을 수정해야하는 문제가 발생할 수 있습니다.</li>
  <li>테이블 간에 관계를 맺고 있기 때문에, JOIN이 많은 복잡한 쿼리가 만들어지게 될 수 있습니다.</li>
  <li>대체적으로 수평적 확장이 힘들기 떄문에, 수직적 확장이 많습니다.</li>
</ul>

<p><strong>주로 사용하는 경우</strong></p>
<ul>
  <li>관계를 맺고 있는 데이터가 자주 변경되는 애플리케이션인 경우입니다.
(NoSQL은 중복된 값을 변경하려면 모든 컬렉션에서 수행해야하기 때문입니다.)</li>
  <li>변경될 여지가 없고, 명확한 스키마가 사용자와 데이터에게 중요한 경우입니다.</li>
</ul>

<h3 id="nosql">NoSQL</h3>
<ul>
  <li>NoSQL에서는 레코드를 도큐멘트라고 부릅니다.</li>
  <li>정해진 스키마를 따르지 않으면 데이터를 추가할 수 없는 SQL과 달리, 다른 구조의 데이터를 같은 컬렉션에 추가할 수 있습니다.</li>
  <li>도큐멘트는 Json과 비슷한 형태로 가지며, RDB와 같이 여러 테이블에 나누어 담는 것이 아닌, 동일한 컬렉션에 넣게 됩니다. 즉, JOIN할 필요 없이 이미 모든 것을 갖춘 문서를 작성하는 것이 기본 철학입니다.</li>
</ul>

<p><strong>장점</strong></p>
<ul>
  <li>스키마가 없기 때문에 유연하며, 언제든지 저장된 데이터를 조정하고 새로운 필드를 추가할 수 있습니다.</li>
  <li>데이터는 애플리케이션이 필요로 하는 형식으로 저장되며, 읽는 속도가 빨라집니다.</li>
  <li>수직 및 수평 확장이 가능하기 때문에 애플리케이션이 발생시키는 모든 읽기/쓰기 
요청을 처리할 수 있습니다.</li>
</ul>

<p><strong>단점</strong></p>
<ul>
  <li>너무 유연한 나머지, 데이터 구조를 결정하지 않고 사용하게 될 수 있습니다.</li>
  <li>데이터가 여러 컬렉션에 중복되어 있기 때문에 중복된 값 수정 시 모든 컬렉션에서 수행해야 합니다.</li>
</ul>

<p><strong>주로 사용하는 경우</strong></p>
<ul>
  <li>정확한 데이터 구조를 알 수 없거나 변경/확장이 될 수 있는 경우입니다.</li>
  <li>데이터 조회를 자주 하지만, 데이터 수정은 적은 경우입니다.</li>
  <li>막대한 양의 데이터를 다루기 위해 데이터베이스를 수평적으로 확장해야하는 경우입니다.</li>
</ul>

<h3 id="데이터베이스의-확장">데이터베이스의 확장</h3>
<p><strong>수직적 확장 (Scale up)</strong></p>
<ul>
  <li>단일 서버의 스펙(성능)을 단순히 향상시키는 것으로, CPU를 업그레이드하는 것입니다.</li>
  <li>서버의 스펙을 업그레이드 하는 동안 발생하는 다운타임(시스템 이용불가 시간)을 피할 수 없습니다.</li>
  <li>하나의 서버로 부하가 집중된다는 문제가 발생하며, 단일 장애점(Single Point of Failure, SPOF)을 갖게 됩니다.</li>
</ul>

<p><strong>수평적 확장 (Scale out)</strong></p>
<ul>
  <li>하나의 서버가 처리하는 일을 여러대의 서버가 처리하도록 만듭니다.</li>
  <li>한 서버처럼 사용하기 위한 클러스터링 작업에 추가비용이 발생하게 됩니다.
(예를 들어, 로드밸런스 등 네트워크 구축이 있습니다.)</li>
  <li>기술적으로나 관리적으로나 수직확장에 비해 까다롭습니다.</li>
  <li>수직적 확장과 다르게 단일 장애점을 가지고 있지 않기 때문에 장애상황에 치명적이지 않습니다.</li>
  <li>이론적으로 확장에 제한이 없기 때문에 무한대로 확장해나갈 수 있습니다.</li>
</ul>

<h2 id="transaction">Transaction</h2>
<ul>
  <li>데이터베이스의 상태를 변화시키기 위해 <code class="language-plaintext highlighter-rouge">수행하는 작업의 단위</code>입니다.</li>
  <li>commit: 하나의 트랜잭션이 성공적으로 끝났고, DB가 일관성있는 상태라면 변경된 상태를 영구적으로 반영하는 것입니다.</li>
  <li>rollback: 테이블 내에 입력/수정/삭제한 데이터에 대해 commit 이전 변경 사항을 취소합니다. 이 때, 관련된 행에 대한 잠금(locking)이 해제되고, 다른 사용자들이 데이터 변경을 가능하도록 합니다.</li>
  <li>savepoint: rollback 시, 트랜잭션에 포함된 전체 작업을 rollback하지 않고, 현시점에서 savepoint까지의 트랜잭션의 일부만 rollback 가능합니다.</li>
</ul>

<p><strong>특징</strong></p>
<ul>
  <li>Atomic(원자성): 트랜잭션이 DB에 모두 반영되거나, 전혀 반영되지 않아야 합니다.</li>
  <li>Consistency(일관성): 트랜잭션의 작업 처리 결과는 항상 일관성이 있어야 합니다.</li>
  <li>Isolation(독립성): 둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 때, 서로 다른 트랜잭션 연산은 독립적이어야 합니다.</li>
  <li>Durability(지속성): 트랜잭션이 성공적으로 완료된다면, 결과는 영구적으로 반영되어야 합니다.</li>
  <li>추가: 일관성은 기본 키, 외래 키 제약과 같은 명시적인 무결성 제약 조건들 뿐만 아니라, 이체 예시에서 두 계좌 잔고의 합은 이체 전후가 같아야 한다는 사항과 같은 비명시적인 일관성 조건들도 있습니다.</li>
</ul>

<h3 id="isolation-level-격리수준">Isolation Level (격리수준)</h3>
<p><strong>Read Uncommitted (Level 0)</strong></p>
<ul>
  <li>SELECT 문이 수행되는 동안 해당 데이터에 Shared Lock이 걸리지 않는 계층입니다.</li>
  <li>트랜잭션이 처리중이거나, 아직 commit되지 않은 데이터를 다른 트랜잭션이 읽는 것조차 허용합니다.</li>
  <li>데이터베이스의 일관성을 유지하는 것이 불가능합니다.</li>
</ul>

<p><strong>Read Committed (Level 1)</strong></p>
<ul>
  <li>대부분의 SQL 서버가 기본적으로 사용하는 격리수준입니다.</li>
  <li>커밋된 데이터만 조회할 수 있습니다. Phantom Read, Non-Retable Read 문제가 발생할 수 있습니다.</li>
  <li>트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어서 대기하게 됩니다.</li>
</ul>

<p><strong>Repeatable Read (Level 2)</strong></p>
<ul>
  <li>MySQL에서 기본으로 사용하는 격리수준입니다.</li>
  <li>일반적인 RDBMS는 변경 전의 레코드를 언두 공간에 백업해둡니다. 
(MVCC. 동일한 레코드에 대해 여러 버전의 데이터가 존재)</li>
  <li>트랜잭션이 롤백된 경우에 데이터를 복원할 수 있을 뿐 아니라,</li>
  <li>트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Loack이 걸리는 단계입니다.</li>
  <li>트랜잭션이 범위 내에서 조회한 데이터 내용이 항상 동일함을 보장합니다.</li>
  <li>다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정이 불가능합니다.</li>
</ul>

<p><strong>Serializable (Level 3)</strong></p>
<ul>
  <li>여러 트랜잭션이 동일한 레코드에 동시에 접근(읽기/쓰기/수정 모두)할 수 없습니다. 하지만, 트랜잭션이 순차적으로 처리되어야 하기 때문에 동시처리 성능이 매우 떨어집니다.</li>
  <li>순수한 SELECT 작업에 대해서도 대상 레코드에 넥스트 키 락을 읽기잠금(공유락, Shared Lock)으로 겁니다.</li>
  <li>완벽한 읽기 일관성 모드를 제공합니다.</li>
</ul>

<h3 id="격리수준이-낮을-때-발생할-수-있는-문제">격리수준이 낮을 때 발생할 수 있는 문제</h3>

<p><strong>Dirty Read</strong></p>
<ul>
  <li>발생 격리 수준: Read Uncommitted</li>
  <li>어떤 트랜잭션에서 아직 실행이 끝나지 않았을 때, <code class="language-plaintext highlighter-rouge">다른 트랜잭션에 의한 변경 사항</code>을 트랜잭션 수행 중 조회하게 되는 경우입니다.</li>
  <li>커밋되지 않은 수정중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할 때 발생합니다.</li>
</ul>

<p><strong>Non-Repeatable Read</strong></p>
<ul>
  <li>발생 격리 수준: Read Committed, Read Uncommitted</li>
  <li>한 트랜잭션에서 같은 쿼리를 두 번 수행할 때, 그 사이에 다른 트랜잭션 값을 수정/삭제 하면서 두 쿼리의 결과가 다르게 나타나며 일관성이 깨지는 현상입니다.</li>
</ul>

<p><strong>Phantom Read</strong></p>
<ul>
  <li>발생 격리 수준: Repeatable Read, Read Committed, Read Uncommitted</li>
  <li>트랜잭션 도중에 새로운 레코드 삽입을 허용하기 때문에 나타나는 현상입니다.</li>
  <li>한 트랜잭션 안에서 일정 범위의 레코드를 두 번 이상 읽을 때, 첫 번째 쿼리에서 없던 레코드가 두 번째 쿼리에서 나타나는 현상입니다.</li>
</ul>

<h3 id="dbms의-구조">DBMS의 구조</h3>
<ul>
  <li>크게 <code class="language-plaintext highlighter-rouge">Query Processor</code>와 <code class="language-plaintext highlighter-rouge">Storage System</code>이 있습니다.</li>
  <li>입출력은 고정 길이의 page 단위로 disk에 읽거나 씁니다.</li>
  <li>저장 공간은 비휘발성 저장 장치인 disk에 저장하며, 일부를 Main Memory에 저장합니다.</li>
</ul>

<h3 id="page-buffer-manageror-buffer-manager">Page Buffer Manager(or Buffer Manager)</h3>
<ul>
  <li>DBMS의 Storage System에 속하는 모듈 중 하나로, Main Memory에 유지하는 페이지를 관리합니다.</li>
  <li>Buffer 관리 정책에 따라서, UNDO 복구와 REDO 복구가 요구되거나 그렇지 않게 되므로, transaction 관리에 매우 중요한 결정을 합니다.</li>
</ul>

<h3 id="undo">UNDO</h3>
<ul>
  <li>트랜잭션은 시작 됐지만 아직 완료되지 않은 commit되지 않은 부분에 대해 연산을 취소합니다.</li>
  <li>수정된 Page들이 <strong>Buffer 교체 알고리즘에 따라 디스크에 출력</strong>될 수 있습니다.</li>
  <li>Buffer 관리 정책에 영향을 받습니다.</li>
</ul>

<h3 id="redo">REDO</h3>
<ul>
  <li>이미 commit된 transaction의 수정을 재반영하는 복구 작업입니다.</li>
  <li>Buffer 관리 정책에 영향을 받습니다.</li>
</ul>

<h3 id="참고자료">참고자료</h3>
<ul>
  <li><a href="https://d2.naver.com/helloworld/407507">Naver D2 블로그</a> - DBMS 구조</li>
  <li><a href="https://mangkyu.tistory.com/299">mangkuy님의 블로그</a> - transaction isolation level</li>
  <li><a href="https://youtu.be/sLJ8ypeHGlM?si=xMBEnPdTyh4w1p3t">쉬운코드님 강의</a></li>
</ul>]]></content><author><name>Yeham Kim</name></author><category term="Study" /><summary type="html"><![CDATA[SQL과 NoSQL]]></summary></entry><entry><title type="html">[Study] Network - TCP</title><link href="http://localhost:4000/study/study-cs-network-tcp/" rel="alternate" type="text/html" title="[Study] Network - TCP" /><published>2023-08-16T00:05:07+09:00</published><updated>2023-08-16T00:05:07+09:00</updated><id>http://localhost:4000/study/study-cs-network-tcp</id><content type="html" xml:base="http://localhost:4000/study/study-cs-network-tcp/"><![CDATA[<h3 id="tcp-통신이란">TCP 통신이란?</h3>
<ul>
  <li>네트워크 통신에서 데이터를 안정적이고 신뢰성 있게 전송하기 위한 연결방식입니다.</li>
  <li>unreliable network에서 reliable network를 보장할 수 있도록 하는 프로토콜입니다.</li>
  <li>network congetion avoidance algorithm을 사용합니다.</li>
</ul>

<p><strong>reliable network를 보장한다? 아래 문제들을 해결하는 것</strong></p>
<ul>
  <li>packet이 손실될 수 있는 문제</li>
  <li>packet의 순서가 바뀌는 문제</li>
  <li>네트워크가 혼잡하게(congestion) 되는 문제</li>
  <li>receiver가 과부화(overload) 되는 문제</li>
</ul>

<h3 id="흐름제어">흐름제어</h3>
<ul>
  <li>송신측과 수신측의 데이터 처리 속도 차이를 해결하는 것</li>
  <li>송신측이 수신측보다 데이터 처리 속도가 빠르게 되면 문제가 발생합니다.</li>
  <li>수신측에서 제한된 저장 용량을 초과한 이후에 도착하는 데이터(packet)는 손실될 수 있습니다. 이를 위해 송신 측의 데이터 전송량을 조절해야 합니다.</li>
  <li>receiver가 sender에게 상태를 feedback 합니다.</li>
</ul>

<p><strong>전송의 전체 과정</strong></p>
<ol>
  <li>Application Layer에서 데이터 전송 시, sender의 애플리케이션은 소켓에 데이터를 씁니다.</li>
  <li>이 데이터는 Transport Layer로 전달되어 세그먼트(Segment)라는 단위로 나뉩니다.</li>
  <li>전송 계층은 이 세그먼트를 Network Layer에 넘깁니다.</li>
  <li>전송된 데이터는 수신자 쪽으로 전달되고 수신자는 수신 버퍼에 데이터를 저장합니다.<br />
(이때, 수신자 쪽에서는 수신 버퍼의 용량을 넘치지 않도록 조절해야 합니다.)</li>
  <li>수신자 쪽에서는 자신의 수신 버퍼의 남은 용량을 송신자에게 알려주는데, 이를 수신 윈도우(receive window)라고 합니다.</li>
  <li>송신자는 수신자의 수신 윈도우를 확인하여 수신자의 수신 버퍼 용량을 초과하지 않도록 데이터를 전송합니다.</li>
  <li>데이터 전송 중에 수신 버퍼가 넘치는 현상을 방지하면서, 안정적인 데이터 전송을 보장하며, 이를 흐름제어(Flow Control)이라고 합니다.</li>
</ol>

<p><strong>해결방법</strong></p>
<ul>
  <li>Stop and Wait: 매번 전송한 패킷에 대해 확인 응답을 받은 후에만 그다음 패킷을 전송하는 방법입니다.</li>
  <li>Sliding Window(Go Back N ARQ): 수신측에서 설정한 윈도우 크기만큼 송신측에서 확인/응답 없이 세그먼트를 전송할 수 있도록 데이터 흐름을 동적으로 조절하는 제어 방법입니다.</li>
</ul>

<p><strong>Sliding Window</strong></p>
<ul>
  <li>목적: 전송은 되었지만, ACK 패킷을 받지 못한 byte의 숫자를 파악하기 위해 사용하는 프로토콜입니다.</li>
  <li>동작방식: 윈도우에 포함되는 모든 패킷을 전송 후, 그 패킷들의 전달이 확인되는 대로 윈도우를 이동시키며 그다음 패킷을 전송합니다.</li>
</ul>

<h3 id="혼잡제어">혼잡제어</h3>
<ul>
  <li>송신측의 데이터 전달과 네트워크의 데이터 처리 속도 차이를 해결하기 위한 방법입니다.</li>
  <li>송신측의 데이터는 지역망이나 인터넷으로 연결된 대형 네트워크를 통해 전달됩니다. 따라서, 만약 한 라우터에 데이터가 몰리면, 자신에게 온 데이터를 모두 처리할 수 없게 됩니다.</li>
  <li>따라서, 이러한 네트워크의 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송속도를 강제로 줄이게 되며, 이를 혼잡제어라고 합니다.</li>
</ul>

<p><strong>해결방법</strong></p>

<p>참고: window size는 단위시간당 전송 패킷 수</p>

<p>AMID(Additive Increase / Multiplicate Decrease)</p>
<ul>
  <li>처음에 패킷을 하나씩 보내다 문제가 없으면, window size를 1씩 증가시키며 전송하는 방법입니다.</li>
  <li>패킷 전송에 실패하거나 일정 시간을 넘으면, 패킷의 전송 속도를 절반으로 줄입니다.</li>
  <li>시간이 흐르면 평형상태로 수렴하게 되는 공평한 방식입니다. (여러 호스트가 한 네트워크를 공유하면 나중에 진입하는 쪽이 불리)</li>
  <li>초기에 높은 대역폭을 사용하지 못하기 때문에, 오랜 시간이 걸리며, 네트워크 혼잡 상황을 미리 파악하기 힘듭니다.</li>
  <li>따라서, 네트워크가 혼잡해진 후에야 대역폭을 줄일 수 있습니다.</li>
</ul>

<p>Slow Start</p>
<ul>
  <li>AIMD와 마찬가지로 패킷을 하나씩 보내면서 시작하고, 패킷이 문제없이 도착하면 각각의 ACK 패킷마다 window size를 늘립니다. 한 주기가 지나면 window size가 2배가 됩니다.</li>
  <li>따라서, 전송속도는 AIMD에 비해 지수 함수 꼴로 증가하지만, 혼잡 현상이 발생하면 window size를 1로 떨어뜨립니다.</li>
  <li>한 번 혼잡 현상이 발생하고 나면 네트워크의 수용량을 어느 정도 예상할 수 있습니다.</li>
  <li>그래서, 혼잡 현상이 발생하였던 window size의 절반까지는 이전처럼 지수함수 꼴로 증가시키고, 그 이후부터는 완만하게 1씩 증가시킵니다.</li>
</ul>

<p>Fast Retransmit</p>
<ul>
  <li>패킷을 받는 쪽에서 먼저 도착해야 할 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 ACK 패킷을 보냅니다.</li>
  <li>순서대로 잘 도착한 마지막 패킷의 다음 패킷 순번을 ACK 패킷에 실어서 보내므로, 중간에 하나가 손실되면 송신 측에서는 순번이 중복된 ACK를 받게 됩니다.</li>
  <li>이를 감지하는 순간, 문제가 되는 순번의 패킷을 재전송합니다.</li>
  <li>중복된 순번의 패킷 3개를 받으면 재전송을 하게 되고, 혼잡 상황이라 판단 후, window size를 줄입니다.</li>
</ul>

<p>Fast Recovery</p>
<ul>
  <li>혼잡 상태가 되면 window size를 1로 줄이지 않고 반으로 줄이고 선형 증가시키는 방법입니다.</li>
  <li>이를 적용하면 혼잡 상황을 한 번 겪은 후 AIMD 방식으로 동작합니다.</li>
</ul>]]></content><author><name>Yeham Kim</name></author><category term="Study" /><summary type="html"><![CDATA[TCP 통신이란? 네트워크 통신에서 데이터를 안정적이고 신뢰성 있게 전송하기 위한 연결방식입니다. unreliable network에서 reliable network를 보장할 수 있도록 하는 프로토콜입니다. network congetion avoidance algorithm을 사용합니다.]]></summary></entry><entry><title type="html">[Study] Network - OSI 계층</title><link href="http://localhost:4000/study/study-cs-network-osi/" rel="alternate" type="text/html" title="[Study] Network - OSI 계층" /><published>2023-08-16T00:05:07+09:00</published><updated>2023-08-16T00:05:07+09:00</updated><id>http://localhost:4000/study/study-cs-network-osi</id><content type="html" xml:base="http://localhost:4000/study/study-cs-network-osi/"><![CDATA[<h3 id="osi-7계층">OSI 7계층</h3>
<p><strong>7 계층 - Application Layer</strong></p>
<ul>
  <li>사용자에게 보이는 부분으로, 최종 사용자에게 가장 가까운 계층으로, 사용자와 직접적으로 상호작용합니다.</li>
  <li>애플리케이션 목적에 맞는 통신 방법을 제공합니다.</li>
  <li>HTTP, DNS, SMTP, FTP등의 대표적인 프로토콜이 해당 레이어에 속합니다.</li>
</ul>

<p><strong>6 계층 - Presentation Layer</strong></p>
<ul>
  <li>애플리케이션 통신에서 메시지 포맷을 관리하는 계층입니다.</li>
  <li>데이터를 안전하게 전송하기 위해 암호화, 복호화하여 소통합니다.</li>
</ul>

<p><strong>5 게층 - Session Layer</strong></p>
<ul>
  <li>애플리케이션 통신에서 세션을 관리하는 계층입니다.</li>
  <li>예시로 RPC(remote procedure call)가 있습니다.</li>
</ul>

<p><strong>4 계층 - Transport Layer</strong></p>
<ul>
  <li>애플리케이션 통신을 담당하며, 실제로 목적지 애필리케이션으로 데이터를 전송합니다.</li>
  <li>TCP, UDP 프로토콜을 사용합니다.</li>
  <li>TCP: 안정적이고 신뢰할 수 있는 데이터 전송을 보장합니다.</li>
  <li>UDP: 데이터가 중간에 유실되거나 순서가 꼬일 수 있지만, 데이터를 무조건 전송합니다.</li>
  <li>Network Layer의 기능을 사용하여 데이터를 전송합니다.</li>
</ul>

<p><strong>3 계층 - Network Layer</strong></p>
<ul>
  <li>호스트 간의 통신을 담당합니다. (IP 프로토콜)</li>
  <li>목적지 호스트로 데이터를 전송합니다.</li>
  <li>네트워크 간의 최적의 경로를 결정합니다.</li>
  <li>Data Link Layer의 기능을 사용하여 기능을 구현합니다.</li>
</ul>

<p><strong>2 계층 - Data Link Layer</strong></p>
<ul>
  <li>IP 주소가 아닌 MAC 주소 기반으로 통신합니다.</li>
  <li>ARP: IP 주소를 MAC 주소로 변환하는 프로토콜입니다.</li>
</ul>

<p><strong>1 계층 - Physical Layer</strong></p>
<ul>
  <li>
    <p>bits 단위로 데이터를 전송합니다.</p>
  </li>
  <li>서로 다른 컴퓨터가 통신을 할 떄 역시, 7계층을 기반으로 통신합니다.</li>
  <li>라우터는 Network Layer, Data Link Layer, Physical Layer에 있는 프로토콜을 구현합니다.</li>
  <li>유튜브 댓글 작성시 유튜브 서버까지 어떻게 전달되는지 살펴보기
    <ol>
      <li>애플리케이션 레이어에 메시지를 전송하기 위해 처리과정을 거칩니다. 부가적인 정보들을 애플리케이션 헤더에 담습니다.</li>
      <li>presentation layer 관련 데이터들을 헤더에 담고, 담긴 정보를 Session Layer로 보냅니다.</li>
    </ol>
  </li>
</ul>

<h2 id="구글을-주소창에서-입력하면-일어나는-일">구글을 주소창에서 입력하면 일어나는 일</h2>
<ul>
  <li>DNS (Domain Name System Servers): URL들의 이름과 IP 주소를 저장하고 있는 데이터 베이스로, 웹사이트를 위한 주소록입니다. 숫자로된 IP를 사용자가 편리한 주소로 맵핑합니다. 최종적으로 사용자를 어떤 서버에 연결할 것인지 제어하는 요청을 쿼리라고 부릅니다.</li>
  <li>DNS query: DNS 서버들을 검색해서 해당 사이트의 IP 주소를 찾습니다. 재귀적으로 서로 다른 DNS 서버를 오가며 에러가 날 때까지 반복적으로 요청합니다. (recursive search)</li>
  <li>TCIP/IP (Transmission Control Protocol / Internet Protocol): 이를 따른다는 것은, IP 주소 체계를 따르며 TCP의 특성을 활용해 송신자와 수신자의 논리적 연결을 생성하고 신뢰성을 유지할 수 있도록 하겠다는 의미입니다.</li>
  <li>HTTP(Hypertext Transfer Protocol):</li>
</ul>

<ol>
  <li>사용자가 웹브라우저 검색창에 www.google.com을 입력</li>
  <li>웹브라우저는 캐싱된 DNS 기록들을 통해 도메인 주소와 대응하는 IP 주소응답 (캐시에 없다면 3, 있다면 4로)</li>
  <li>웹브라우저가 HTTP를 사용하여 DNS에 입력된 도메인 주소 요청 및 IP 주소 응답</li>
  <li>웹브라우저가 웹서버에게 IP 주소를 통해 html 문서를 요청합니다. (TCP/IP)</li>
  <li>웹어플리케이션서버(WAS)와 데이터베이스에서 우선적으로 웹페이지 작업을 처리합니다.</li>
  <li>처리된 작업의 결과를 웹서버로 전송합니다.</li>
  <li>웹서버는 브라우저에게 html 문셔 결과를 응답합니다.</li>
  <li>웹브라우저는 화면에 웹페이지 내용을 출력합니다.</li>
</ol>

<h2 id="웹서버--어플리케이션-서버--웹컨테이너">웹서버 / 어플리케이션 서버 / 웹컨테이너</h2>
<p><strong>웹서버</strong></p>
<ul>
  <li>웹서버 소프트웨어와 HTML, CSS, JavaScript파일과 같은 정적 파일들을 저장하는 하드웨어</li>
  <li>Client가 어떻게 호스트 파일들에 접근하는지 관리하는 소프트웨어</li>
  <li>URI(Uniform Resource Identifier)와 HTTP(브라우저가 웹 페이지를 보여주기 위해 사용하는 프로토콜) 소프트웨어의 일부</li>
  <li>HTTP를 통해 웹브라우저에서 요청하는 HTML 문서나 오브젝트들을 전송해주는 서비스 프로그램을 말합니다. 이 때, 다른 가공없이 파일을 그대로 전송하기만 하면 되기 때문에 정적(static)이라고 합니다.</li>
  <li>단순히 데이터만 반환하면 되기 떄문에 처리 속도가 빠르며, 트래픽의 과부하를 잘 처리할 수 있습니다.
<strong>애플리케이션 서버</strong></li>
  <li>웹 서비스가 복잡해지고 기능이 다양함에 따라서 데이터를 가공해서 처리하는 비즈니스 로직이 필요하게 됩니다.</li>
  <li>웹서버 하나에서 다른 로직까지 처리하기에 부하가 크기 때문에, 로직을 처리하는 서버가 필요하게 되어 만들어집니다.</li>
  <li>애플리케이션 서버가 HTTP 서버를 통해 브라우저에게 요청된 데이터를 전송하기 전에, 애플리케이션 서버가 데이터를 가공하기 때문에 동적이라고 부릅니다.
<strong>웹 컨테이너</strong></li>
  <li>웹 서버에서 동적인 데이터를 반환하려면 요청에 알맞는 프로그램이 필요합니다. 또한, 그 프로그램에 인자를 전달하기 위한 규약이 필요합니다.</li>
  <li>CGI(Common Gateway Interface)는 프로그램 사이에 데이터를 전달하는 중간자 역할에 필요한 통신규약을 의미합니다.</li>
  <li></li>
</ul>

<h3 id="django에서의-wsgi-cgi">Django에서의 wsgi, cgi</h3>
<p><strong>CGI(Common Gateway Interface)</strong></p>
<ul>
  <li>www 서버와 서버 상에 등장하는 다른 프로그램등 HTML에서는 불가능한 동적인 요소를 홈페이지에 받아들여 쓸 수 있도록하는 웹서버와 웹어플리케이션 사이를 이어주는 미들웨어입니다.</li>
  <li>CGI는 요청이 들어올 때마다 스레드를 생성하여 웹 어플리케이션을 동작시키게 됩니다. 이는 부하가 너무 크고, 10000개 이상의 동시 요청을 처리할 수 없다는 단점이 있습니다.</li>
</ul>

<p><strong>WSGI(Web Server Gateway Interface)</strong></p>
<ul>
  <li>웹 서버 소프트웨어와 파이썬으로 작성된 스크립트(웹 응용 프로그램) 간 통신을 위한 표준 인터페이스입니다.</li>
  <li>즉, Nginx로 들어오는 http request를 파이썬이 이해할 수 있도록 통역합니다.</li>
  <li>CGI의 단점을 보완하여 클라이언트 요청에 대해 멀티 스레드를 생성하여 효율적으로 처리합니다.</li>
  <li>Django 진영에서는 uwsgi, gunicon 등을 사용하고 있습니다.</li>
  <li>동작 과정: 클라이언트 요청 -&gt; server side에서 middleware component 호출 -&gt; middleware component가 application side의 application 호출</li>
</ul>

<p><strong>uWSGI와 Gunicorn</strong><br />
uWSGI</p>
<ul>
  <li>C 언어로 작성된 웹서버이며, 파이썬 애플리케이션을 외부 웹서버와 연결하여 오청을 처리하는 방식입니다.</li>
  <li>다양한 프로그래밍 언어를 지원하며 고성능 및 확장성이 뛰어납니다.</li>
  <li>여러 프로세스 또는 스레드를 사용하여 동시에 여러 요청을 처리할 수 있습니다.</li>
  <li>초기설정 옵션이 다양하지만 복잡합니다. 유연성과 강력한 기능을 제공합니다.</li>
  <li>다양한 플러그인과 확장 기능을 제공하여 다양한 요구 사항에 대응할 수 있습니다.</li>
</ul>

<p>Gunicorn</p>
<ul>
  <li>Python으로 작성된 웹서버이며, 독자적으로 애플리케이션을 실행하고 관리하는 단일서버로, 프론트엔드 웹서버와 직접 연결하여 사용합니다.</li>
  <li>단일 프로세스에서 동작하며, 작은 규모의 애플리케이션을 처리하는데 적합합니다.</li>
  <li>간단하고 설정이 쉽습니다. 추가설정 없이도 동작합니다.</li>
  <li>파이썬 애플리케이션에 초점을 맞춘 경량 웹서버입니다.</li>
</ul>

<p>참고 블로그</p>
<ul>
  <li>biunx님: <a href="https://binux.tistory.com/32">웹서버와 웹어플리케이션서버</a></li>
  <li>waonderboy님: <a href="https://velog.io/@waoderboy/%EC%9B%B9-%EC%84%9C%EB%B2%84-WAS-%EC%9B%B9-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88">웹 서버, WAS, 웹 컨테이너</a></li>
  <li>stg0123님: <a href="https://stg0123.github.io/study/41/">uwsgi를 django와 연결하기</a></li>
  <li>elastic7327님: <a href="https://elastic7327.medium.com/python%EA%B0%9C%EB%B0%9C%EC%9E%90-uwsgi%EB%A5%BC-%EB%B2%84%EB%A6%AC%EA%B3%A0-gunicorn%EC%9C%BC%EB%A1%9C-%EA%B0%88%EC%95%84%ED%83%80%EB%8B%A4-df1c95f220c5">uwsgi를 버린 이유</a></li>
</ul>]]></content><author><name>Yeham Kim</name></author><category term="Study" /><summary type="html"><![CDATA[OSI 7계층 7 계층 - Application Layer 사용자에게 보이는 부분으로, 최종 사용자에게 가장 가까운 계층으로, 사용자와 직접적으로 상호작용합니다. 애플리케이션 목적에 맞는 통신 방법을 제공합니다. HTTP, DNS, SMTP, FTP등의 대표적인 프로토콜이 해당 레이어에 속합니다.]]></summary></entry><entry><title type="html">[Study] Operating System - Process, Thread</title><link href="http://localhost:4000/study/study-cs-os-process-thread/" rel="alternate" type="text/html" title="[Study] Operating System - Process, Thread" /><published>2023-08-16T00:05:07+09:00</published><updated>2023-08-16T00:05:07+09:00</updated><id>http://localhost:4000/study/study-cs-os-process-thread</id><content type="html" xml:base="http://localhost:4000/study/study-cs-os-process-thread/"><![CDATA[<h2 id="프로세스">프로세스</h2>
<ul>
  <li>메모리 상에서 실행 중인 프로그램입니다.</li>
  <li>디스크로부터 메모리에 적재되어 CPU의 할당을 받습니다. 운영체제로부터 주소 공간, 파일, 메모리 등을 할당받습니다.</li>
  <li>코드 영역: 프로그램의 소스 코드 자체를 구성하는 메모리 영역</li>
  <li>데이터 영역: 전역변수, 정적변수, 배열 등에 대한 메모리 영역 (초기화 데이터는 data 영역에, 초기화되지 않은 데이터는 bss 영역에 저장)</li>
  <li>Heap 영역: 동적 할당 시 사용하는 (<code class="language-plaintext highlighter-rouge">new()</code>, <code class="language-plaintext highlighter-rouge">malloc()</code>) 영역입니다.</li>
  <li>Stack 영역: 지역변수, 매개변수, 리턴 값 (임시 메모리 영역)</li>
  <li>함수의 매개변수, 복귀 주소와 로컬 변수와 같은 임시 자료를 갖는 프로세스 스택, 전역 변수들을 수록하는 데이터 섹션을 포함합니다.</li>
  <li>하나의 프로세스가 생성될 때, 기본적으로 하나의 스레드가 같이 생성됩니다.</li>
</ul>

<h3 id="프로세스의-5가지-상태">프로세스의 5가지 상태</h3>
<ul>
  <li>생성 (New): 프로세스의 생성 상태</li>
  <li>실행 (Running): 프로세스가 CPU에 할당되어 실행 중인 상태</li>
  <li>준비 (Ready): 프로세스가 CPU에 할당되는 것을 기다리는 상태</li>
  <li>대기 (Waiting): 보류(Block) 상태라고도 하며, 프로세스가 입출력이나 이벤트를 기다리는 상태</li>
  <li>종료 (Terminated): 프로세스 종료 상태</li>
</ul>

<h3 id="멀티프로세스">멀티프로세스</h3>
<ul>
  <li>하나의 프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 병렬적으로 작업을 수행하도록 하는 것입니다.</li>
  <li>장점: 메모리 침법 문제를 OS 차원에서 해결하기 때문에 안전성이 높습니다.</li>
  <li>단점: 각각의 독립된 메모리 영역을 가지고 있기 때문에, 작업량이 많을수록 오버헤드가 발생합니다. Context Switching으로 인한 성능 저하가 발생합니다.</li>
</ul>

<h2 id="스레드">스레드</h2>
<ul>
  <li>프로세스의 실행 단위로, 한 프로세스 내에서 동작되는 여러 실행 흐름입니다. 프로세스 내의 주소 공간이나 자원을 스레드 간에 공유할 수 있습니다.</li>
  <li>스레드는 독립적인 동작을 수행하기 위해 존재하며, 독립적인 실행 흐름을 추가하기 위한 최소 조건으로 독립된 Stack 영역만 따로 할당받습니다.</li>
  <li>스레드는 스레드 ID, 프로그램 카운터, 레지스터 집합, 스택으로 구성됩니다.</li>
  <li>같은 프로세스에 속한 다른 스레드와 코드, 데이터 섹션, 열린 파일, 신호 등의 운영체제 자원들을 공유합니다.</li>
  <li>멀티 스레딩: 하나의 프로세스를 다수의 실행 단위로 구분하여 자원을 공유하고, 자원의 생성과 관리의 중복성을 최소화하여 수행능력을 향상시킵니다.</li>
</ul>

<h3 id="스택을-스레드마다-독립적으로-할당하는-이유">스택을 스레드마다 독립적으로 할당하는 이유</h3>
<ul>
  <li>스택은 함수 호출 시 전달되는 인자이며, 되돌아갈 주소값 및 함수 내 변수를 저장하기 위해 사용되는 메모리 공간입니다.</li>
  <li>스택 메모리 공간이 독립적이라는 것은, 독립적인 함수 호출이 가능하다는 것이며 이는 독립적인 실행 흐름이 가능하다는 것입니다.</li>
  <li>따라서, 독립적인 실행 흐름을 위한 최소 조건으로 독립된 스택을 할당하는 것입니다.</li>
</ul>

<h3 id="pc-레지스터를-스레드마다-독립적으로-할당하는-이유">PC 레지스터를 스레드마다 독립적으로 할당하는 이유</h3>
<ul>
  <li>PC 값은 스레드의 명령어 수행 위치값을 나타냅니다. 스레드는 CPU를 할당받았다가, 스케줄러에 의해 다시 선점당합니다.</li>
  <li>따라서, 명령어가 연속적으로 수행되지 못하고 어느 부분까지 수행했는지 기억할 필요가 있으므로, PC 레지스터를 독립적으로 할당합니다.</li>
</ul>

<h3 id="멀티-스레드">멀티 스레드</h3>
<ul>
  <li>장점: 공유 메모리만큼의 시간, 메모리 공간과 시스템 자원 소모가 절약되고, 전역변수와 정적 변수에 대한 자료를 공유할 수 있습니다.</li>
  <li>단점: 하나의 스레드가 데이터 공간을 망가뜨리면 모든 스레드가 작동 불능 상태가 되기 때문에 안전성에 문제가 있습니다. (공유 메모리를 갖기 때문)
(이는 뮤텍스와 세마포어를 통해 대비할 수 있습니다.)</li>
  <li>스레드 간의 통신이 필요한 경우에도 별도의 자원을 이용하지 않고, Heap 영역을 통해 데이터를 주고받습니다.</li>
  <li>프로세스 간 통신 방법에 비해 훨씬 간단하다는 장점이 있습니다.</li>
  <li>스레드의 context switch는 캐시 메모리를 비울 필요가 없기 때문에, 프로세스 context switch보다 더 빠릅니다.</li>
  <li>시스템의 throughput이 향상되고 자원 소모가 줄어들며 자연스럽게 프로그램 응답 시간이 단축됩니다.</li>
</ul>

<h3 id="멀티-스레딩의-문제">멀티 스레딩의 문제</h3>
<ul>
  <li>스레드 간 공유하는 자원에 동시에 접근하는 일이 발생하게 됩니다.</li>
  <li>따라서, 동기화 작업이 필요하고, 동기화를 위해 작업 처리 순서를 컨트롤하고 공유 자원에 대한 접근을 컨트롤 해야합니다.</li>
  <li>병목현상이 발생할 수 있으며, 성능이 저하될 가능성이 높습니다. 따라서, 과도한 락으로 인한 병목현상을 줄여야 합니다.</li>
  <li>멀티 프로세스 방식은 하나의 프로세스가 죽더라도 다른 프로세스에는 영향을 끼치지 않지만, 멀티 스레드는 하나의 스레드가 종료될 때, 전체 스레드도 이에 대한 영향을 받을 수 있습니다.</li>
</ul>

<h2 id="프로세스-제어-블록-process-control-block">프로세스 제어 블록 (Process Control Block)</h2>
<ul>
  <li>PCB는 특정 프로세스에 대한 중요한 정보를 저장하는 운영체제의 자료구조입니다.
(관련 저장 정보 아래에 서술)</li>
  <li>운영체제는 프로세스를 관리하기 위해 프로세스의 생성과 동시에 PCB를 생성합니다.</li>
  <li>CPU를 할당받아 작업을 처리하다가 프로세스 전환이 발생하면, 작업을 저장하고 CPU를 반환해야 하는데, 이때 진행상황을 PCB에 저장합니다.
(즉, 앞으로 다시 수행할 대기 중인 프로세스에 대한 저장 값을 PCB에 저장합니다.)</li>
  <li>다시 CPU를 할당받게 되면 이전에 종료됐던 시점부터 다시 작업을 수행합니다.</li>
  <li>PCB는 Linked List 방식으로 관리되어, List Head에 PCB들이 생성될 때마다 노드가 추가됩니다. 주소값으로 연결이 이루어진 연결리스트이기 때문에 삽입, 삭제가 용이합니다.</li>
  <li>프로세스가 생성되면 해당 PCB가 생성되고 프로세스 완료 시 제거됩니다.</li>
</ul>

<p><strong>PCB에 저장되는 정보</strong></p>
<ul>
  <li>PID, 프로세스의 상태(new, ready, running, waiting, terminated)</li>
  <li>프로그램 카운터: 프로세스가 다음에 실행할 명령어의 주소</li>
  <li>CPU 레지스터</li>
  <li>CPU 스케쥴링 정보: 프로세스의 우선순위, 스케줄 큐에 대한 포인터</li>
  <li>메모리 관리 정보: 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보 포함</li>
  <li>입출력 상태 정보: 프로세스에 할당된 입출력 장치들과 열린 파일 목록</li>
  <li>어카운팅 정보: 사용된 CPU 시간, 시간제한, 계정번호 등</li>
</ul>

<h3 id="context-switching">Context Switching</h3>
<ul>
  <li>프로세스의 상태 정보를 저장하고 복원하는 일련의 과정으로, 동작 중인 프로세스가 대기하며 해당 프로세스의 상태를 보관하고, 대기하고 있던 다음 순번의 프로세스가 동작하며 이전에 보관했던 프로세스 상태를 복구하는 과정입니다.</li>
  <li>
    <p>프로세스는 각 독립된 메모리 영역을 할당받아 사용되므로, 캐시 메모리 초기화와 같은 무거운 작업이 진행될 때 오버헤드가 발생하는 문제가 있습니다. 따라서, 프로세스의 컨텍스트 스위칭이 스레드의 컨텍스트 스위칭보다 늦습니다.</p>
  </li>
  <li>CPU가 이전의 프로세스 상태를 PCB에 보관하고, 또 다른 프로세스의 정보를 PCB에서 읽어 레지스터에 적재하는 과정입니다.</li>
</ul>

<p><strong>발생하는 경우</strong></p>
<ul>
  <li>인터럽트가 발생하는 경우</li>
  <li>실행 중인 CPU의 사용 허가 시간을 모두 소모하는 경우</li>
  <li>입출력을 위해 대기해야 하는 경우</li>
</ul>

<h2 id="cpu-scheduling">CPU Scheduling</h2>
<ul>
  <li>CPU를 잘 사용하기 위해 프로세스를 잘 배정하기 위한 방법입니다.</li>
  <li>프로세스가 작업을 수행하려면, 스케줄러로부터 CPU를 할당 받아야하므로, 순서와 처리 시간을 효율적으로 정하기 위한 정책입니다.</li>
  <li>조건: 오버헤드는 낮게, 사용률은 높게, 기아 현상은 낮게</li>
  <li>목표
    <ol>
      <li>Batch System: 한 번에 하나의 프로그램만 수행하는 것을 말합니다. 따라서, 가능하면 많은 일을 수행하며, 시간보다 처리량이 중요합니다. CPU Utilization과 같은 측면을 극대화하는 것이 배치 시스템에 더 좋습니다.</li>
      <li>Interactive System: 사용자가 컴퓨터와 대화형으로 동작하기 때문에, 응답시간이 중요합니다. 응답시간을 빠르게, 대기시간은 적게 합니다.</li>
      <li>Real-time System: 일반적으로 시간이라는 제약 조건이 추가된 시스템이기 때문에, 주어진 인풋에 대한 아웃풋의 처리 시간이 중요합니다. 따라서, 시간제약 조건(Deadline)을 맞추는 것입니다.</li>
    </ol>
  </li>
</ul>

<h3 id="프로세스의-상태-전이">프로세스의 상태 전이</h3>
<ul>
  <li>승인 (Admitted): 프로세스 생성이 가능하여 승인.</li>
  <li>스케줄러 디스패치(Scheduler Dispatch): 준비 상태에 있는 프로세스 중 하나를 선택하여 실행시키는 것.</li>
  <li>인터럽트(interrupt): 예외, 입출력, 이벤트 등이 발생하여 현재 실행 중인 프로세스를 준비 상태로 바꾸고, 해당 작업을 먼저 처리하는 것.</li>
  <li>입출력 또는 이벤트 대기 (I/O or Event wait): 실행 중인 프로세스가 입출력이나 이벤트를 처리해야 하는 경우, 입출력/이벤트가 모두 끝날 때까지 대기 상태로 만드는 것.</li>
  <li>입출력 또는 이벤트 완료 (I/O or Event Completion): 입출력/이벤트가 끝난 프로세스를 준비 상태로 전환하여 스케줄러에 의해 선택될 수 있도록 만드는 것.</li>
</ul>

<h3 id="선점-스케줄링">선점 스케줄링</h3>
<ul>
  <li>한 프로세스가 CPU를 할당받아 실행하고 있을 때, 다른 프로세스가 CPU를 사용하고 있는 프로세스를 중지시키고 CPU를 차지할 수 있는 스케줄링 기법입니다.<br />
(처리시간에 대한 예측이 어렵습니다.)</li>
  <li>우선순위가 높은 프로세스를 먼저 수행할 때 유리하며, 빠른 응답 시간을 요구하는 대화식 시분할 시스템에 유용합니다.</li>
  <li>많은 오버헤드를 초래합니다.</li>
  <li>Interrupt, I/O or Event Completion, I/O or Event Wait, Exit</li>
</ul>

<p>Priority Scheduling</p>
<ul>
  <li>정적/동적으로 우선순위를 부여하여 우선순위가 높은 순서대로 처리합니다.</li>
  <li>우선순위가 낮은 프로세스가 무한정 기다리는 Starvation이 발생할 수 있습니다.<br />
(Aging 방법으로 Starvation 문제를 해결할 수 있음)</li>
</ul>

<p>Round Robin</p>
<ul>
  <li>FCFS에 의해 프로세스들이 보내지면 각 프로세스는 동일한 시간의 Time Quantum만큼 CPU를 할당받습니다.<br />
(time quantum, time slice: 실행의 최소 단위 시간)</li>
  <li>할당 시간(time quantum)이 크면 FCFS와 같게 되고, 작으면 컨텍스트 스위칭이 잦아져서 오버헤드가 증가합니다.</li>
</ul>

<p>Multilevel-Queue</p>
<ul>
  <li>작업들을 여러 종류의 그룹으로 나누어 여러 개의 큐를 이용하는 기법입니다.</li>
  <li>우선순위가 낮은 큐들이 실행하지 못하는 것을 방지하고자 각 큐마다 다른 <code class="language-plaintext highlighter-rouge">time quantum</code>을 설정해 주는 방식이 사용됩니다.</li>
  <li>우선순위가 높은 큐는 작은 <code class="language-plaintext highlighter-rouge">time quantum</code>을, 우선순위가 낮은 큐는 큰 <code class="language-plaintext highlighter-rouge">time quantum</code>을 할당합니다.</li>
</ul>

<p>Multilevel-Feedback-Queue</p>
<ul>
  <li>Multilevel-Queue에서 자신의 <code class="language-plaintext highlighter-rouge">time quantum</code>을 다 채운 프로세스는 밑으로 내려가고, <code class="language-plaintext highlighter-rouge">time quantum</code>을 다 채운 프로세스는 원래 큐에 그대로 있습니다.</li>
  <li><code class="language-plaintext highlighter-rouge">time quantum</code>을 다 채운 프로세스는 CPU burst 프로세스로 판단됩니다.</li>
  <li>짧은 작업에 유리하며, interrupt가 잦은 입출력 위주의 작업에 우선권을 줍니다.</li>
  <li>처리 시간이 짧은 프로세스를 먼저 처리하기 때문에 turn around 평균 시간을 줄여줍니다.</li>
</ul>

<h3 id="비선점-스케줄링">비선점 스케줄링</h3>
<ul>
  <li>이미 사용되는 CPU를 회수하지는 못하고, 끝날 때까지 기다리는 스케줄링 기법입니다.</li>
  <li>따라서, 프로세스 종료 또는 I/O 이벤트가 있을 때까지 실행이 보장됩니다. 처리시간 예측이 용이합니다.</li>
  <li>일괄 처리방식이 적합합니다.</li>
  <li>모든 프로세스 요구에 대해 공정하며, 중요도가 높은 작업이 낮은 작업을 기다리는 경우가 발생할 수도 있습니다.</li>
  <li>I/O or Event Wait, Exit</li>
</ul>

<p>FCFS (First Come First Served)</p>
<ul>
  <li>큐에 도착한 순서대로 CPU를 할당합니다.</li>
  <li>실행 시간이 짧은 작업이 뒤로 가면 평균 대기시간이 길어집니다.</li>
</ul>

<p>SJF (Shortest Job First)</p>
<ul>
  <li>수행시간이 가장 짧다고 판단되는 작업을 먼저 수행합니다.</li>
  <li>FCFS 보다 평균 대기 시간이 감소하고, 짧은 작업에 유리합니다.</li>
</ul>

<p>HRN (Highest Response-ratio Next)</p>
<ul>
  <li>우선순위를 계산하여 점유 불평등을 보완하는 방법으로, SJF의 단점을 보완합니다.</li>
  <li>우선순위 = (대기시간 + 실행시간) / 실행시간</li>
</ul>]]></content><author><name>Yeham Kim</name></author><category term="Study" /><summary type="html"><![CDATA[프로세스 메모리 상에서 실행 중인 프로그램입니다. 디스크로부터 메모리에 적재되어 CPU의 할당을 받습니다. 운영체제로부터 주소 공간, 파일, 메모리 등을 할당받습니다. 코드 영역: 프로그램의 소스 코드 자체를 구성하는 메모리 영역 데이터 영역: 전역변수, 정적변수, 배열 등에 대한 메모리 영역 (초기화 데이터는 data 영역에, 초기화되지 않은 데이터는 bss 영역에 저장) Heap 영역: 동적 할당 시 사용하는 (new(), malloc()) 영역입니다. Stack 영역: 지역변수, 매개변수, 리턴 값 (임시 메모리 영역) 함수의 매개변수, 복귀 주소와 로컬 변수와 같은 임시 자료를 갖는 프로세스 스택, 전역 변수들을 수록하는 데이터 섹션을 포함합니다. 하나의 프로세스가 생성될 때, 기본적으로 하나의 스레드가 같이 생성됩니다.]]></summary></entry><entry><title type="html">[Study] Django - 코딩 스타일</title><link href="http://localhost:4000/django%20study/study-django-coding-style/" rel="alternate" type="text/html" title="[Study] Django - 코딩 스타일" /><published>2023-08-15T00:05:07+09:00</published><updated>2023-08-15T00:05:07+09:00</updated><id>http://localhost:4000/django%20study/study-django-coding-style</id><content type="html" xml:base="http://localhost:4000/django%20study/study-django-coding-style/"><![CDATA[<h3 id="pre-commit-checks">Pre-commit checks</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">flake8</code> 모듈을 사용하여 코딩 컨벤션을 확인하는 방법도 있습니다.</li>
  <li><code class="language-plaintext highlighter-rouge">git hook</code>: git과 관련된 이벤트 발생시, 특정 스크립트를 실행할 수 있도록 하는 기능입니다.</li>
  <li><code class="language-plaintext highlighter-rouge">pre-commit</code>은 pre-commit hook들을 관리하는 프레임워크로, 이를 통해 리뷰를 위한 코드 커밋 전, 간단한 이슈들을 확인할 수 있습니다.</li>
</ul>

<h3 id="python-style">Python style</h3>
<ul>
  <li>모든 파일은 <code class="language-plaintext highlighter-rouge">black auto-fomatter</code>를 사용하여 포맷되어야합니다.</li>
  <li>프로젝트 레포지토리는 <code class="language-plaintext highlighter-rouge">.editorconfig</code> 파일을 포함해야합니다.</li>
  <li>장고 운영진은 whitespace 이슈들을 피하기 위해 <code class="language-plaintext highlighter-rouge">EditorConfig</code>와 함께 텍스트 에디터를 사용하는 것을 추천합니다.</li>
  <li>만약 구체적으로 정한 부분이 없으면 대체적으로, <code class="language-plaintext highlighter-rouge">PEP 8</code> 따릅니다.</li>
  <li>스트링 값은 <code class="language-plaintext highlighter-rouge">%-formatting</code>, <code class="language-plaintext highlighter-rouge">f-string</code>, <code class="language-plaintext highlighter-rouge">str.format()</code> 형태로 사용하는 것을 권장합니다. (가독성) 또한, <code class="language-plaintext highlighter-rouge">f-string</code> 사용시 plain variable로 사용해야합니다.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1"># Disallowed
</span>  <span class="sa">f</span><span class="sh">"</span><span class="s">hello </span><span class="si">{</span><span class="nf">get_user</span><span class="p">()</span><span class="si">}</span><span class="sh">"</span>
    
  <span class="c1"># Allowed
</span>  <span class="n">user</span> <span class="o">=</span> <span class="nf">get_user</span><span class="p">()</span>
  <span class="sa">f</span><span class="sh">"</span><span class="s">hello </span><span class="si">{</span><span class="n">user</span><span class="si">}</span><span class="sh">""</span><span class="s">
</span></code></pre></div>    </div>
  </li>
  <li>camel 표기법 보다 snake 표기법을 권장합니다.</li>
  <li>docstring은 <code class="language-plaintext highlighter-rouge">PEP 257</code> 스타일을 따릅니다.</li>
  <li>테스트 수행 시, <code class="language-plaintext highlighter-rouge">assertRaises()</code>를 사용하기 보다, <code class="language-plaintext highlighter-rouge">assertRaisesMessage()</code>와 <code class="language-plaintext highlighter-rouge">assertWarnsMessage()</code>를 사용하여, 예외에 대한 경고 메시지까지 함꼐 봅니다.</li>
  <li><code class="language-plaintext highlighter-rouge">assertRaisesRegex()</code>와 <code class="language-plaintext highlighter-rouge">assertWarnsRegex()</code>는 정규식 매칭이 필요한 경우에만 사용합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">assertTrue()</code>와 <code class="language-plaintext highlighter-rouge">assertFalse()</code> 보다 <code class="language-plaintext highlighter-rouge">assertIs(..., True/False)</code>를 사용합니다.</li>
</ul>

<h3 id="imports">Imports</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">isort</code> 모듈을 사용하여 import를 자동으로 소팅합니다.</li>
  <li>아래와 같이 그룹별로 모듈을 묶어서 import 합니다.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1"># future
</span>  <span class="bp">...</span>
  <span class="c1"># standard library
</span>  <span class="bp">...</span>
  <span class="c1"># third-party
</span>  <span class="bp">...</span>
  <span class="c1"># Django
</span>  <span class="bp">...</span>
  <span class="c1"># local Django
</span>  <span class="bp">...</span>
  <span class="c1"># try/except
</span>  <span class="bp">...</span>
</code></pre></div>    </div>
  </li>
  <li><code class="language-plaintext highlighter-rouge">import ...</code>만 사용하는 경우를 <code class="language-plaintext highlighter-rouge">from ... import ...</code>로 모듈을 호출하는 경우들보다 상위에 위치시킵니다.</li>
  <li>알파벳 순서로 모듈을 호출하는 것을 권장합니다.</li>
  <li>너무 긴 모듈 호출은 끊어서 구분합니다. (4 space와 trailing comma 사용)</li>
</ul>

<h3 id="template-style">Template style</h3>
<ul>
  <li>중괄호 사이의 tag comment들 사이에는 공백을 삽입합니다.
(<code class="language-plaintext highlighter-rouge"> -&gt; </code>)</li>
</ul>

<h3 id="view-style">View style</h3>
<ul>
  <li>view 함수의 첫 번째 파라미터는 <code class="language-plaintext highlighter-rouge">req</code>가 아닌 <code class="language-plaintext highlighter-rouge">request</code>로 확실히 표기합니다.</li>
</ul>

<h3 id="model-style">Model style</h3>
<ul>
  <li>필드명은 소문자 snake 표기법을 사용하여 정의합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">class Meta</code>는 필드 정의 뒤에 single line을 공백으로 둔 후, 정의합니다.</li>
  <li>모델 메서드의 정의 순서는 아래와 같습니다.
    <ul>
      <li>All database fields</li>
      <li>Custom manager attributes</li>
      <li><code class="language-plaintext highlighter-rouge">class Meta</code></li>
      <li><code class="language-plaintext highlighter-rouge">def __str__()</code></li>
      <li><code class="language-plaintext highlighter-rouge">def save()</code></li>
      <li><code class="language-plaintext highlighter-rouge">def get_absolute_url()</code></li>
      <li>Any custom method</li>
    </ul>
  </li>
</ul>

<h3 id="djangoconfsettings-사용하기"><code class="language-plaintext highlighter-rouge">django.conf.settings</code> 사용하기</h3>
<ul>
  <li>모듈들은 일반적으로 최상위 레벨의 <code class="language-plaintext highlighter-rouge">django.conf.settings</code>에 저장된 설정들을 사용하지 않도록 해야합니다.</li>
  <li>환경변수인 <code class="language-plaintext highlighter-rouge">DJANGO_SETTINGS_MODULE</code>에 의존하지 않도록 설정해야합니다.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kn">from</span> <span class="n">django.conf</span> <span class="kn">import</span> <span class="n">settings</span>
  <span class="n">setting</span><span class="p">.</span><span class="nf">configure</span><span class="p">({},</span> <span class="n">SOME_SETTING</span><span class="o">=</span><span class="sh">"</span><span class="s">foo</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
</ul>]]></content><author><name>Yeham Kim</name></author><category term="Django Study" /><summary type="html"><![CDATA[Pre-commit checks flake8 모듈을 사용하여 코딩 컨벤션을 확인하는 방법도 있습니다. git hook: git과 관련된 이벤트 발생시, 특정 스크립트를 실행할 수 있도록 하는 기능입니다. pre-commit은 pre-commit hook들을 관리하는 프레임워크로, 이를 통해 리뷰를 위한 코드 커밋 전, 간단한 이슈들을 확인할 수 있습니다.]]></summary></entry><entry><title type="html">[Study] Django - 설계 철학</title><link href="http://localhost:4000/django%20study/study-django-philosophy/" rel="alternate" type="text/html" title="[Study] Django - 설계 철학" /><published>2023-08-15T00:05:07+09:00</published><updated>2023-08-15T00:05:07+09:00</updated><id>http://localhost:4000/django%20study/study-django-philosophy</id><content type="html" xml:base="http://localhost:4000/django%20study/study-django-philosophy/"><![CDATA[<h3 id="기본을-충실히-하자">기본을 충실히 하자!</h3>
<ul>
  <li>구현을 서둘러 하다보니, 기본적인 프레임워크의 철학과 기본기를 돌아볼 여유가 없어왔던 것 같습니다.</li>
  <li>프레임워크에 대해서나 왜 사용하게 되었는지를 생각해 볼 때 설득력있는 설명을 할 수 있는 방법이 궁금했습니다.</li>
</ul>

<h2 id="설계-철학">설계 철학</h2>

<h3 id="django를-선택하는-이유">Django를 선택하는 이유</h3>
<ul>
  <li>개발이 빠릅니다. Django는 포괄적인 도구와 라이브러리를 제공하여 새로운 프로젝트를 신속하게 구축할 수 있도록 합니다.</li>
  <li>확장성이 좋습니다. 트래픽이 증가하는 등 요구사항이 증가함에 따라 쉽게 확장할 수 있도록 설계되어있습니다.</li>
  <li>보안에 대해 강조합니다. 사이트 간 스크립팅(XSS), 요청 위조(CSRF), SQL 인젝션 등과 같은 취약점에 대해 내장된 보호 기능을 갖추고 있습니다.</li>
  <li>서드파티 패키지나 플러그인을 함께 사용하기 편리합니다.</li>
</ul>

<h3 id="일반">일반</h3>
<ul>
  <li>Django는 Python을 사용한 견고하고 확장 가능한 웹어플리케이션을 개발하기 위한 고수준 오픈소스 웹 프레임워크입니다.</li>
  <li>Django 스택의 근본적인 목표는, 느슨한 결합과 탄탄한 응집으로 프레임워크의 각 계층이 서로 알지 못하도록 하는 것이 기본 원칙입니다.</li>
  <li>Django는 가능한 한 최소한의 코드를 사용하고, 틀에 박힌 코드를 배제하며, Python의 동적인 기능(ex. introspection)을 최대한 활용합니다.
    <blockquote>
      <p>introspection이란, 런타임 동안 객체의 타입을 결정하는 능력입니다. 파이썬의 모든 것은 객체이고, 객체가 지원하는 내장 함수와 모듈들이 있습니다.</p>
    </blockquote>
  </li>
  <li>DRY: 중복성을 최소화하고, 최소한의 것들을 가지고 최대한의 것을 만들어내도록 합니다.</li>
  <li>명시적인 것이 묵시적인 것보다 낫다는 PEP20을 따릅니다.</li>
  <li>프레임워크는 모든 수준에서 일관적이어야 합니다. 이는 저수준(python code style)에서 고수준(django framework)에 이르기까지 적용됩니다.</li>
</ul>

<h3 id="모델">모델</h3>
<ul>
  <li>명시적인 것이 묵시적인 것보다 나음으로, 필드의 성질은 키워드 인자에 근거해야 하며, 경우에 따라서는 필드의 유형에 근거해야합니다.</li>
  <li>활성 레코드 디자인 패턴에 따라 “객체”의 모든 aspect를 캡슐화해야합니다.</li>
  <li>데이터를 모델로 표현하고, 모델을 이해하는 데 요구되는 모든 정보가 모델 내에 있어야 합니다.</li>
</ul>

<h3 id="데이터베이스-api">데이터베이스 API</h3>
<ul>
  <li>SQL문은 가능한 적은 횟수로 실행해야 하며, 내부적으로 최적화해야합니다.</li>
  <li>프레임워크에서 <code class="language-plaintext highlighter-rouge">save()</code>를 조용히 처리하는 것이 아닌, 개발자가 명시적으로 <code class="language-plaintext highlighter-rouge">save()</code>를 호출하도록 되어 있습니다.</li>
  <li><code class="language-plaintext highlighter-rouge">join</code> 명령어가 요구될 때에는 겉으로 드러나지 않게 자동으로 수행되어야 합니다.</li>
  <li>모든 객체는 시스템의 모든 관련 객체에 접근할 수 있어야 하며, 이러한 접근은 양방향이어야합니다.</li>
  <li>필요할 경우에 SQL 문을 직접 작성하기 쉽게 설계해야합니다.</li>
</ul>

<h3 id="url-설계">URL 설계</h3>
<ul>
  <li>Django 앱의 URL을 Python 함수 이름과 같게 만드는 것은 좋지 않습니다.</li>
  <li>웹페이지 URL에 파일 확장자를 넣는 것은 지양해야합니다.</li>
  <li>기술적으로 <code class="language-plaintext highlighter-rouge">foo.com/bar</code>와 <code class="language-plaintext highlighter-rouge">foo.com/bar/</code>는 서로 다른 URL이며, 검색 엔진 로봇은 이를 별도로 취급합니다.</li>
  <li>따라서, APPEND_SLASH 설정을 True로 하는 경우, <code class="language-plaintext highlighter-rouge">/</code>가 붙지 않더라도 리다이렉션 시킵니다.
    <blockquote>
      <p>주의: POST 메서드를 사용하는 경우 리다이렉트를 사용해버리면 데이터가 소실될 가능성도 있습니다.</p>
    </blockquote>
  </li>
</ul>

<h3 id="django의-mvt-아키텍처-model-view-template">Django의 MVT 아키텍처 (Model View Template)</h3>

<p><strong>Model</strong></p>
<ul>
  <li>데이터의 구조를 나타내며, CRUD에 대해 정의합니다.</li>
  <li>테이블의 구조와 각 테이블 간의 관계를 정의하는 Python 클래스입니다.</li>
</ul>

<p><strong>View</strong></p>
<ul>
  <li>사용자 요청을 처리하고 적절한 응답을 반환합니다.</li>
  <li>데이터를 검색한 뒤, HTTP 응답을 반환하는 Python 함수로, Template이나 Json을 반환합니다.</li>
</ul>

<p><strong>Template</strong></p>
<ul>
  <li>클라이언트로 전송되는 HTML의 구조와 레이아웃을 정의합니다.</li>
  <li>텍스트 파일로서, HTML 구조를 응용하여 동적 컨텐츠를 포함할 수 있도록합니다.</li>
</ul>

<h3 id="template">Template</h3>
<ul>
  <li>표현과 로직을 분리해야합니다.</li>
  <li>대다수의 동적인 웹사이트는 공통 헤더, 푸터, 네비게이션 바와 같은 사이트의 공통 디자인을 갖습니다. Django 템플릿 시스템은 이러한 요소를 한 곳에 저장하기 쉽게하여 중복 코드를 없애야합니다.</li>
  <li>템플릿은 HTML 뿐만 아니라, 텍스트 기반 포맷 또는 일반 텍스트도 잘 생성할 수 있어야 합니다.</li>
  <li>XML을 템플릿 언어로 사용하지 않아야 합니다.</li>
  <li>템플릿은 데이터베이스의 레코드를 삭제하는 명령과 같은 악의적인 코드를 포함할 수 없어야 합니다.</li>
</ul>

<h3 id="view">View</h3>
<ul>
  <li>함수로 처리할 수 있는 일을 하기 위해 클래스의 인스턴스를 굳이 생성하지 않아도 됩니다.</li>
  <li>글로벌 변수의 요청 데이터에 접근하는 것이 아닌 뷰 함수에 전달된 요청 객체에 각각 접근해야합니다.</li>
  <li>뷰는 개발자가 어떤 템플릿을 사용하는지에 무관해야합니다.</li>
</ul>]]></content><author><name>Yeham Kim</name></author><category term="Django Study" /><summary type="html"><![CDATA[기본을 충실히 하자! 구현을 서둘러 하다보니, 기본적인 프레임워크의 철학과 기본기를 돌아볼 여유가 없어왔던 것 같습니다. 프레임워크에 대해서나 왜 사용하게 되었는지를 생각해 볼 때 설득력있는 설명을 할 수 있는 방법이 궁금했습니다.]]></summary></entry><entry><title type="html">[Study] Django - ORM Basic</title><link href="http://localhost:4000/django%20study/study-django-orm-basic/" rel="alternate" type="text/html" title="[Study] Django - ORM Basic" /><published>2023-08-12T00:05:07+09:00</published><updated>2023-08-12T00:05:07+09:00</updated><id>http://localhost:4000/django%20study/study-django-orm-basic</id><content type="html" xml:base="http://localhost:4000/django%20study/study-django-orm-basic/"><![CDATA[<h2 id="orm이란-무엇인가">ORM이란 무엇인가?</h2>

<ul>
  <li>객체지향 프로그래밍은 클래스를 사용하지만, 관계형 데이터베이스는 테이블을 사용하기 때문에, 객체 모델과 관계형 모델 간에 불일치가 발생합니다.</li>
  <li>ORM은 SQL문을 자동으로 생성하여 이러한 불일치를 해결할 수 있습니다.</li>
</ul>

<h2 id="orm의-장단점">ORM의 장단점</h2>

<h3 id="장점">장점</h3>

<ul>
  <li>완벽한 객체지향적인 코드
    <ul>
      <li>SQL문이 아닌 클래스의 메서드를 통한 데이터베이스 조작이 가능하기 때문에, 개발자가 객체 모델만을 이용해서 프로그래밍을하는데 집중할 수 있습니다.</li>
      <li>SQL문을 사용하며 함께 필요한 선언문, 할당, 종료와 같은 부수적인 코드가 사라지거나 줄어들게 됩니다.</li>
    </ul>
  </li>
  <li>재사용, 유지보수, 리팩토링이 용이합니다.</li>
  <li>DBMS에 대한 종속성이 줄어듭니다.
    <ul>
      <li>객체 간의 관계를 바탕으로 SQL문을 자동으로 생성하며, 객체의 자료형 타입까지 사용할 수 있습니다.</li>
      <li>따라서, RDBMS의 데이터 구조와 객체지향 모델 사이의 간격을 좁힐 수 있습니다.</li>
    </ul>
  </li>
</ul>

<h3 id="단점">단점</h3>

<ul>
  <li>프로젝트의 복잡성이 커질수록 난이도도 올라가고, 잘못 구현되는 경우 속도 저하가 발생합니다. 일관성을 무너뜨리게 될 수도 있습니다.</li>
  <li>잘못된 사용으루 N+1 문제와 같은 비효율적인 동작을 야기할 수 있습니다.</li>
  <li>대형 SQL문은 속도를 위해 별도의 튜닝이 필요하므로, 결국 SQL문법을 사용해야할 때가 생깁니다.</li>
  <li>쿼리문이 복잡한 경우, SQL문 사용이 직관적이고 효율적일 수 있습니다.</li>
</ul>

<h3 id="orm을-적절하게-사용하는-방법">ORM을 적절하게 사용하는 방법</h3>

<p><strong>타겟 DB를 이해하기</strong></p>

<ul>
  <li>SQL 및 DB의 locking 모델을 무시하면 안됩니다.</li>
  <li>ORM 적용 환경에서 발생하는 많은 부류의 문제들은 DB와 SQL의 문제를 간과함에서 발생합니다.</li>
</ul>

<p><strong>필요한 경우 SQL을 사용하기</strong></p>

<ul>
  <li>Hibernate, TopLink와 같은 ORM들은 SQL 쿼리 작성 기능을 제공하지만, 경우에 따라 SQL문을 직접 작성해야합니다.</li>
</ul>

<p><strong>O-R 매핑 제품을 선택하기 전에 충분히 검토하기</strong></p>

<ul>
  <li>모든 ORM 제품이 동일한 수준의 기능을 제공하지 않기 때문에, 요구 사항을 반영하는 환경을 구축하고 제품들을 비교, 테스트 해야합니다.</li>
  <li>엔터프라이즈 개발 과정의 다른 요소들과 마찬가지로, 프로젝트 라이프사이클 초기 단계에서 성능과 관련된 리스크를 최소화하는 것이 중요합니다.</li>
  <li>매핑 기능에 과도한 오버헤드가 수반되지 않는지 분석해야 합니다.</li>
</ul>

<p><strong>ORM이 적절히 사용될 수 있는 상황을 이해하기</strong></p>

<ul>
  <li>ORM은 엔티티를 개별적으로 업데이트하고 간헐적으로 셋 기반 작업을 수행하는 OLTP 애플리케이션이 적합합니다.</li>
</ul>

<p><strong>ORM이 적합하지 않은 경우</strong></p>

<ul>
  <li>많은 수의 레코드에 대해 잦은 빈도로 bulk 업데이트를 수행하는 애플리케이션(OLAP 애플리케이션)</li>
  <li>데이터 마이닝을 위해 사용되는 애플리케이션에서는 이미 데이터를 본래의 엔티티 상태로 사용하기 어렵습니다.</li>
  <li>데이터의 인출 및 업데이트를 위해 핸드코딩으로 작성된 SQL 및 저장 프로시저를 이용하는 DB 환경</li>
  <li>순수 SQL 기반 접근 방법을 적용하는 것이 적절한 애플리케이션
    <ul>
      <li>비즈니스 로직의 대부분이 DB에 이미 구현되어 있거나, 데이터베이스 무결성 제약(integrity constraint)이 적용된 경우 등입니다.</li>
      <li>이러한 애플리케이션에서는 오브젝트 또는 ORM의 활용 여지가 적으며, 데이터베이스 테이블을 도메인 오브젝트로 모델링 함으로써 기대할 수 있는 효과가 거의 없습니다.</li>
    </ul>
  </li>
</ul>

<h2 id="django-orm의-특징">Django ORM의 특징</h2>

<h3 id="queryset">QuerySet</h3>

<ul>
  <li>Django ORM을 통해 생성된 자료형으로, 데이터베이스의 테이블로부터 가져온 객체의 목록입니다.</li>
</ul>

<h3 id="lazy-loading">Lazy Loading</h3>

<ul>
  <li>필요한 시점에만 SQL을 호출하는 Lazy한 특성이 있습니다.</li>
  <li><code class="language-plaintext highlighter-rouge">users=User.objects.all()</code> 문법을 사용하더라도, 이 때 DB를 호출하는 것이 아닌, <code class="language-plaintext highlighter-rouge">user=users[0]</code>, <code class="language-plaintext highlighter-rouge">list(users)</code>와 같이 실제 파이썬에서 해당 데이터를 사용할 때 호출됩니다.</li>
  <li>따라서, <code class="language-plaintext highlighter-rouge">Result Cache</code>를 통해 미리 데이터를 캐싱해두는 것이 더 효율적입니다. <code class="language-plaintext highlighter-rouge">user_list=list(User.objects.all())</code></li>
  <li>지연 로딩의 또 다른 문제는, 외래키 관계에 있는 데이터를 참조해서 호출할 때 발생합니다. lazy-loading은 쿼리문이 날라갈 때 당장 필요하지 않기 때문에 참조모델의 데이터는 가지고 오지 않고 해당 모델이 갖는 한개의 데이터를 가져옵니다.</li>
  <li>따라서, 외래키 값을 호출할 때 한 번 더 쿼리가 날라가는 <code class="language-plaintext highlighter-rouge">N+1 문제</code>가 발생하게 됩니다.</li>
</ul>

<h3 id="eager-loading">Eager Loading</h3>

<ul>
  <li>N+1 문제를 해결하기 위해, <code class="language-plaintext highlighter-rouge">select_related()</code>와 <code class="language-plaintext highlighter-rouge">prefetch_related()</code> 메서드로 즉시 로딩할 수 있습니다.</li>
  <li><code class="language-plaintext highlighter-rouge">select_related()</code>는 join을 통해 데이터를 즉시 로딩하는 방법으로, 정참조 외래키에서 사용됩니다.</li>
  <li><code class="language-plaintext highlighter-rouge">prefetch_related()</code>: 추가 쿼리를 수행해서 데이터를 즉시 로딩하는 방법으로, 역참조 외래키에서 사용됩니다.</li>
</ul>

<h2 id="참고">참고</h2>
<ul>
  <li><a href="https://bentist.tistory.com/109">bentist님의 블로그</a></li>
</ul>]]></content><author><name>Yeham Kim</name></author><category term="Django Study" /><summary type="html"><![CDATA[ORM이란 무엇인가?]]></summary></entry><entry><title type="html">[Study] Python Clean Code - Good Code</title><link href="http://localhost:4000/study/study-cleancode-goodcode/" rel="alternate" type="text/html" title="[Study] Python Clean Code - Good Code" /><published>2023-08-12T00:05:07+09:00</published><updated>2023-08-12T00:05:07+09:00</updated><id>http://localhost:4000/study/study-cleancode-goodcode</id><content type="html" xml:base="http://localhost:4000/study/study-cleancode-goodcode/"><![CDATA[<h2 id="계약에-의한-디자인">계약에 의한 디자인</h2>
<ul>
  <li>계약: 소프트웨어 컴포넌트 간의 통신 중에 반드시 지켜져야 하는 규칙을 강제하는 것입니다.</li>
  <li>사전조건: 코드가 실행되기 전에 확인해야 할 조건들로, 유효성 검사, DB 및 파일 등에 대한 것들로, 서버가 담당할 부분입니다.</li>
  <li>사후조건: 코드 실행 이후에 함수 반환 값의 유효성 검사로, 클라이언트가 담당할 부분입니다.</li>
  <li>위의 두 가지 조건을 통해, 책임소재를 신속히 파악할 수 있습니다. 사전조건 검증에 실패한다면 클라이언트의 결함, 사후조건에 실패하면 컴포넌트의 결함입니다.</li>
</ul>

<h3 id="사전조건precondition">사전조건(precondition)</h3>
<ul>
  <li>함수나 메서드가 제대로 동작하기 위해 보장해야 하는 모든 것을 의미하며, 적절한 데이터를 전달해야 합니다.</li>
  <li>파이썬은 동적으로 타입이 결정되기 때문에, 전달된 데이터가 적절한 타입인지 확인하는 경우도 있습니다.</li>
  <li>클라이언트가 함수를 호출하기 전, 모든 유효성을 검사하는 방식은 tolerant 접근법으로, 함수가 어떤 값이라도 수용하게 됩니다.</li>
  <li>하지만, 함수가 자체적으로 로직을 실행하기 전에 검사하도록 한다면 demanding 접근 방법입니다.</li>
  <li>DRY 원칙에 의해, 이때도 검증 로직은 클라이언트에 두거나 함수 자체에 두어야 합니다.</li>
</ul>

<h3 id="사후조건postcondition">사후조건(postcondition)</h3>
<ul>
  <li>메서드 또는 함수가 반환된 후의 상태를 강제하는 계약의 일부입니다.</li>
  <li>사후조건 검증에 통과하고 클라이언트는 반환 객체를 아무 문제 없이 사용할 수 있어야 합니다.</li>
</ul>

<h2 id="방어적-프로그래밍">방어적 프로그래밍</h2>
<ul>
  <li>방어적 프로그래밍은 계약에 의한 디자인과 다른 접근방식을 따릅니다.</li>
  <li>계약에서 예외를 발생시키고 실패하게 되는 조건을 기술하는 대신, 코드의 모든 부분을 유효하지 않은 것으로부터 스스로 보호할 수 있도록 합니다.</li>
  <li>에러핸들링(예상할 수 있는 시나리오의 오류를 처리하는 방법)과 어썰션(발생하지 않아야 하는 오류를 처리하는 방법)을 사용합니다.</li>
</ul>

<h3 id="에러-핸들링">에러 핸들링</h3>
<ul>
  <li>예상되는 에러에 대해 실행할 수 있을지, 프로그램을 중단할지를 판단하기 위한 절차입니다.</li>
</ul>

<p><strong>값 대체</strong></p>
<ul>
  <li>일부 시나리오에서 오류에 의해 소프트웨어가 잘못된 값을 생성하거나 전체가 종료될 위험이 있는 경우, 결괏값을 다른 값으로 대체합니다.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">os</span>
<span class="n">os</span><span class="p">.</span><span class="nf">getenv</span><span class="p">(</span><span class="sh">"</span><span class="s">DBPORT</span><span class="sh">"</span><span class="p">,</span> <span class="mi">5432</span><span class="p">)</span> <span class="c1"># "DBPORT"가 env에 없는 경우 5432 반환
</span><span class="k">def</span> <span class="nf">connect_database</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="sh">"</span><span class="s">localhost</span><span class="sh">"</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">5432</span><span class="p">):</span>
    <span class="bp">...</span>
</code></pre></div>    </div>
  </li>
  <li>데이터가 누락될 경우 None 때문에 발생하게 되는 오류를 방지합니다.</li>
</ul>

<p><strong>예외 처리</strong></p>
<ul>
  <li>함수 호출 실패는 외부 컴포넌트 중 하나의 문제로 인한 것일 수 있습니다.</li>
  <li>함수는 심각한 오류에 대해 명확하고 분명하게 알려주어 적절하게 해결할 수 있도록 해야 합니다.</li>
  <li>예외가 많을수록 호출자는 함수에 대해 더 많은 것을 알아야 하므로, 캡슐화를 약화시킵니다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">DataTransport</span><span class="p">:</span>
    <span class="n">retry_threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">retry_n_times</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">connector</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">_connector</span> <span class="o">=</span> <span class="n">connector</span>
        <span class="n">self</span><span class="p">.</span><span class="n">connection</span> <span class="o">=</span> <span class="bp">None</span>
      
    <span class="k">def</span> <span class="nf">deliver_event</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="nf">connect</span><span class="p">()</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">event</span><span class="p">.</span><span class="nf">decode</span><span class="p">()</span>
            <span class="n">self</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">except</span> <span class="nb">ConnectionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="sh">"</span><span class="s">연결 실패: %s</span><span class="sh">"</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="k">raise</span>
        <span class="k">except</span> <span class="nb">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logger</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="sh">"</span><span class="s">%r 잘못된 데이터 포함: %s</span><span class="sh">"</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="k">raise</span>
    
    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">retry_n_times</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">connection</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">_connector</span><span class="p">.</span><span class="nf">connect</span><span class="p">()</span>
            <span class="k">except</span> <span class="nb">ConnectionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="sh">"</span><span class="s">%s: 새로운 연결 시도 %is</span><span class="sh">"</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">retry_threshold</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
              <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">connection</span>
        <span class="k">raise</span> <span class="nc">ConnectionError</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">self</span><span class="p">.</span><span class="n">retry_n_times</span><span class="si">}</span><span class="s"> 번째 재시도 연결 실패</span><span class="sh">"</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">send</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">connection</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">deliver_event</code>의 경우, 두 가지의 예외상황이 발생할 수 있습니다. <code class="language-plaintext highlighter-rouge">connect</code> 메서드를 사용할 때 혹은 <code class="language-plaintext highlighter-rouge">decode()</code> 메서드를 사용할 때의 경우로, 구현을 수정할 필요가 있습니다.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">connection_with_retry</span><span class="p">(</span><span class="n">connector</span><span class="p">,</span> <span class="n">retry_n_times</span><span class="p">,</span> <span class="n">retry_threshold</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">retry_n_times</span><span class="p">):</span>
      <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">connector</span><span class="p">.</span><span class="nf">connect</span><span class="p">()</span>
      <span class="k">except</span> <span class="nb">ConnectionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
          <span class="n">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="sh">"</span><span class="s">%s: 새로운 연결 시도 %is</span><span class="sh">"</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">retry_threshold</span><span class="p">)</span>
          <span class="n">time</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="n">retry_threshold</span><span class="p">)</span>
      <span class="n">exc</span> <span class="o">=</span> <span class="nc">ConnectionError</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">self</span><span class="p">.</span><span class="n">retry_n_times</span><span class="si">}</span><span class="s"> 번째 재시도 연결 실패</span><span class="sh">"</span><span class="p">)</span>
      <span class="n">logger</span><span class="p">.</span><span class="nf">exception</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>
      <span class="k">raise</span> <span class="n">exc</span>

<span class="k">class</span> <span class="nc">DataTransport</span><span class="p">:</span>
    <span class="n">retry_threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">retry_n_times</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">connector</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">_connector</span> <span class="o">=</span> <span class="n">connector</span>
        <span class="n">self</span><span class="p">.</span><span class="n">connection</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">deliver_event</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">connection</span> <span class="o">=</span> <span class="nf">connection_with_retry</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">_connector</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">retry_n_times</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">retry_threshold</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">send</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">connection</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="nf">decode</span><span class="p">())</span>
        <span class="k">except</span> <span class="nb">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logger</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="sh">"</span><span class="s">%r 잘못된 데이터 포함: %s</span><span class="sh">"</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="k">raise</span>
    <span class="bp">...</span>
</code></pre></div></div>
<ul>
  <li>연결과 연결 예외까지를 담당하는 <code class="language-plaintext highlighter-rouge">connection_with_retry</code> 메서드를 독립적으로 구현합니다.</li>
  <li>위와 같이 방식을 변경하면, 예외처리를 <code class="language-plaintext highlighter-rouge">deliver_event</code>에서 따로 관리할 필요가 없게 되고, 의도적으로 예외가 발생하도록 내버려 둘 수 있습니다.</li>
</ul>

<h3 id="예외처리시-주의사항">예외처리시 주의사항</h3>
<p><strong>Traceback 노출 금지</strong></p>
<ul>
  <li>예외 처리시 발생하는 오류가 전파되었을 때, 세부사항을 사용자에게 보이지 않도록 해야 합니다.</li>
  <li>파이썬에서의 traceback은 중요 정보들을 유출하게될 가능성이 있기 때문입니다.</li>
</ul>

<p><strong>비어있는 except 블록 사용 금지</strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span><span class="p">:</span>
    <span class="nf">process_data</span><span class="p">()</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">pass</span>
</code></pre></div></div>
<ul>
  <li>파이썬의 철학은, “에러는 조용히 전달되어서는 안된다는 것”입니다. 위와 같은 방식은 코드를 숨기고 에러 수정을 어렵게 합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">Exception</code>과 같이 광범위한 예외 보다는 <code class="language-plaintext highlighter-rouge">보다 구체적인 예외</code>를 사용해야합니다.</li>
</ul>

<p><strong>원본 예외 포함</strong></p>
<ul>
  <li>오류 처리 과정에서 다른 오류를 발생시키고 메시지를 변경하는 경우가 있을 수 있습니다.</li>
  <li>이 때, 원본의 예외를 포함하는 것이 좋습니다.
```python
class InternalDataError(Exception):
  “"”업무 도메인 데이터의 예외”””</li>
</ul>

<p>def process(data_dictionary, record_id):
    try:
        return data_dictionary[record_id]
    except KeyError as e:
      raise InternalDataError(“Record not present”) from e</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 위와 같이, 기본 예외를 상속받아, 커스텀 예외로 처리하는 방식도 있습니다.

### 파이썬에서 어썰션 사용하기
- 절대로 일어나지 않아야하는 상황에서 사용됩니다. 따라서, assert 문이 작동하면, 소프트웨어에 결함이 있음을 의미합니다.
- 따라서, 프로그램을 중단해야할 가능성이 있는 오류로, 결함을 수정하기 위해 프로그램을 중지하는 것이 좋습니다.
```python
result = condition.holds()
assert result &gt; 0, "에러 {0}".format(result)
</code></pre></div></div>

<h2 id="관심사의-분리">관심사의 분리</h2>
<ul>
  <li>프로그램의 각 부분은 기능의 일부분(관심사)에 대해서만 책임을 지며, 나머지 부분에 대해서는 알 필요가 없습니다.</li>
  <li>소프트웨어의 관심사를 분리하는 목표는 파급 효과(한 지점의 변화가 전체로 전파되는 것)를 최소화하여 유지보수성을 향상시키는데 있습니다.</li>
</ul>

<h3 id="응집력">응집력</h3>
<ul>
  <li>객체는 작고 잘 정의된 목적을 가져야 하며, 가능하면 작아야 합니다.</li>
  <li>객체의 응집력이 높을수록 더 유용하고 재사용성이 높아지므로, 더 좋은 디자인입니다.</li>
</ul>

<h3 id="결합력">결합력</h3>
<ul>
  <li>두 개 이상의 객체가 서로 어떻게 의존하는지를 나타냅니다.</li>
  <li>객체 또는 메서드의 두 부분이 서로 너무 의존적이라면, 다음과 같은 결과를 가져옵니다.</li>
  <li>
    <ol>
      <li>낮은 재사용성: 어떤 함수가 특정 객체에 지나치게 의존하거나 너무 많은 파라미터를 가진다면, 해당 객체에 결합하게 됩니다.</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>파급효과: 너무 가깝게 붙어있게 되면, 두 부분 중 하나를 변경할 때 다른 부분에도 영향을 미칩니다.</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>낮은 수준의 추상화: 두 함수가 너무 가깝게 관련되어 있으면, 서로 다른 추상화 레벨에서 문제를 해결하기 어렵습니다.</li>
    </ol>
  </li>
</ul>

<h2 id="컴포지션과-상속">컴포지션과 상속</h2>

<h3 id="상속의-좋은-예시">상속의 좋은 예시</h3>
<ul>
  <li>public 메서드와 속성 인터페이스를 정의한 컴포넌트를 그대로 물려받으면서 추가 기능을 더하려고 하는 경우 및 특정 기능을 수정하는 경우에 좋습니다.</li>
  <li>예를 들어, <code class="language-plaintext highlighter-rouge">http.server</code> 패키지에서 <code class="language-plaintext highlighter-rouge">BaseHTTPRequsetHandler</code> 기본 클래스와, 이를 변경한 <code class="language-plaintext highlighter-rouge">SimpleHTTPRequestHandler</code>가 있습니다.</li>
  <li>예외처리를 담당하는 <code class="language-plaintext highlighter-rouge">Exception</code> 클래스의 경우, 상속을 사용하는 것이 좋습니다.</li>
</ul>

<h3 id="상속의-안티패턴">상속의 안티패턴</h3>
<ul>
  <li>도메인 문제를 해결하기 위해, 적절한 데이터 구조를 만든 후, 이를 사용하는 객체를 만들지 않고 데이터 구조(딕셔너리/셋/리스트 등) 자체를 객체로 만드는 경우입니다.</li>
  <li>또한, public 인터페이스를 통해 노출된 public 메서드를 사용하게 되기 때문에, 필요없는 메서드에도 접근할 수 있는 coupling에 대한 문제가 발생합니다.
```python
class TransactionPolicy(collections.UserDict):
  “"”잘못된 상속 예시”””
  def change_in_policy(self, customer_id, <strong>new_policy_data):
      self[customer_id].update(</strong>new_policy_data)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 올바른 해결책은 컴포지션을 사용하는 것입니다. `TransactionalPolicy` 자체가 딕셔너리가 되는 것이 아니라 딕셔너리를 활용하는 것입니다.
- 사전을 private 속성에 저장하고 `__getitem__()`으로 사전의 프록시를 만들고 나머지 필요한 public 메서드를 추가적으로 구현하는 것입니다.
```python
class TransactionPolicy:
    """컴포지션을 사용한 리팩토링 예시"""
    def __init__(self, policy_data, **extra_data):
        self._data = {**policy_data, **extra_data}
    
    def change_in_policy(self, customer_id, **new_policy_data):
        self._data[customer_id].update(**new_policy_data)

    def __getitem__(self, customer_id):
        return self._data[customer_id]
    
    def __len__(self):
        return len(self._data)
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">TransacctionalPolicy</code> 자체가 딕셔너리가 되는 것이 아닌, 딕셔너리를 활용하는 것입니다. 즉, 딕셔너리를 private 속성에 저장하고 <code class="language-plaintext highlighter-rouge">__getitem__()</code>으로 딕셔너리의 프록시를 생성합니다.</li>
  <li>이 방법은 개념적으로 정확하며, 현재 딕셔너리의 데이터 구조를 변경하더라도 인터페이스만 유지하면, 사용자는 영향을 받지 않습니다.</li>
</ul>

<h3 id="파이썬-다중상속">파이썬 다중상속</h3>
<ul>
  <li>파이썬은 다중상속을 지원하지만, 이를 잘못 사용하면 큰 문제를 초래할 수 있습니다.</li>
  <li>다중 상속의 올바른 해결책으로는 믹스인(mixin)을 활용한 디자인 패턴이 있습니다.</li>
</ul>

<p><strong>믹스인(mixin)</strong></p>
<ul>
  <li>믹스인은 코드를 재사용하기 위해, 일반적인 행동을 캡슐화한 기본 클래스입니다.</li>
  <li>
    <p>믹스인 클래스는 그 자체로는 유용하지 않으며, 대부분이 클래스에 정의된 메서드나 속성에 의존하기 때문에 확장에서는 동작하지 않습니다.
```python
class BaseTokenizer:
  def <strong>init</strong>(self, str_token):
      self.str_token = str_token</p>

    <p>def <strong>iter</strong>(self):
      yield from self.str_token.split(“-“)</p>
  </li>
</ul>

<p>class UpperIterableMixin:
  def <strong>iter</strong>(self):
      return map(str.upper, super().<strong>iter</strong>())</p>

<p>class Tokenizer(UpperIterableMixin, BaseTokenizer):
    pass</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>tk = BaseTokenizer(“28a2320b-fd3f-4627-9792-a2b38e3c46b0”)
list(tk)
[‘28a2320b’, ‘fd3f’, ‘4627’, ‘9792’, ‘a2b38e3c46b0’]
```</p>
      <ul>
        <li>위에서 mixin과 함께 <code class="language-plaintext highlighter-rouge">BaseTokenizer</code>를 사용한 <code class="language-plaintext highlighter-rouge">Tokenizer</code> 클래스의 경우, 일종의 데코레이터 역할을 합니다.</li>
        <li>믹스인에서 <code class="language-plaintext highlighter-rouge">__iter__</code>를 호출하고 다시 <code class="language-plaintext highlighter-rouge">super()</code>를 호출하여 <code class="language-plaintext highlighter-rouge">BaseTokenizer</code>에 위임합니다.</li>
      </ul>
    </blockquote>
  </blockquote>
</blockquote>

<h3 id="파이썬의-함수-인자-동작방식">파이썬의 함수 인자 동작방식</h3>
<ul>
  <li>파이썬의 첫 번째 규칙은 모든 인자가 passed by a value 된다는 것입니다. 따라서, 함수 인자에 있는 변수를 할당하고 나중에 사용합니다.</li>
  <li>함수의 인자가 mutable한지 immutable한지에 따라서 함수 내부에서 값이 의도치 않게 변형되는 경우가 발생할 수 있습니다.
<strong>가변인자</strong></li>
  <li>파이썬에서 가변인자를 사용하려면 해당 인자를 packing할 변수 이름 앞에 <code class="language-plaintext highlighter-rouge">*</code>를 붙입니다.
```python
    <h1 id="packing-예시">packing 예시</h1>
    <p>def f(first, second):
  print(first, second)</p>
  </li>
</ul>

<blockquote>
  <blockquote>
    <blockquote>
      <p>l = [1, 2]
f(*l)
1 2</p>
    </blockquote>
  </blockquote>
</blockquote>

<h1 id="unpacking-예시">unpacking 예시</h1>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a, b = [1, 2]
print(a, b)
1 2
```</p>
      <ul>
        <li>인자를 딕셔너리로 패킹하려면 변수 이름 앞에 <code class="language-plaintext highlighter-rouge">**</code>를 붙입니다.
```python
def function(**kwargs):
  print(kwargs)</li>
      </ul>
    </blockquote>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <blockquote>
      <p>function(key=”value”)
{‘key’: ‘value’}
```</p>
    </blockquote>
  </blockquote>
</blockquote>]]></content><author><name>Yeham Kim</name></author><category term="Study" /><summary type="html"><![CDATA[계약에 의한 디자인 계약: 소프트웨어 컴포넌트 간의 통신 중에 반드시 지켜져야 하는 규칙을 강제하는 것입니다. 사전조건: 코드가 실행되기 전에 확인해야 할 조건들로, 유효성 검사, DB 및 파일 등에 대한 것들로, 서버가 담당할 부분입니다. 사후조건: 코드 실행 이후에 함수 반환 값의 유효성 검사로, 클라이언트가 담당할 부분입니다. 위의 두 가지 조건을 통해, 책임소재를 신속히 파악할 수 있습니다. 사전조건 검증에 실패한다면 클라이언트의 결함, 사후조건에 실패하면 컴포넌트의 결함입니다.]]></summary></entry><entry><title type="html">[Study] Load Balancer</title><link href="http://localhost:4000/study/study-load-balancer/" rel="alternate" type="text/html" title="[Study] Load Balancer" /><published>2023-08-11T00:05:07+09:00</published><updated>2023-08-11T00:05:07+09:00</updated><id>http://localhost:4000/study/study-load-balancer</id><content type="html" xml:base="http://localhost:4000/study/study-load-balancer/"><![CDATA[<h2 id="작성-계기">작성 계기</h2>
<ul>
  <li>면접질문 중, nginx를 사용한 로드밸런싱이 OSI Layer의 어떤 계층에서 일어나는지에<br />
대한 질문에 대해 대답하지 못해, 공부를 시작하게 되었습니다.</li>
</ul>

<h3 id="로드밸런서">로드밸런서</h3>
<ul>
  <li>트래픽을 받아서 여러 대의 서버에 분산시키는 하드웨어/소프트웨어를 의미합니다.</li>
  <li>부하 분산에는 L4 Load Balancer와 L7 Load Balancer가 사용됩니다.</li>
</ul>

<h3 id="l4-load-balancer">L4 Load Balancer</h3>
<ul>
  <li>IP Port를 활용하여 서버부하분산을 하는 것을 의미합니다. 적합한 server IP와 Port를 목적지로 하는 요청에 따라 부하를 분산합니다.</li>
  <li>로드밸런싱의 기준점이 IP와 Port이기 때문에, TCP/UDP의 Header를 분석하여 로드밸런싱에 활용하지는 않습니다. 따라서, 프로토콜들의 특성으로 인한 행동을 제어하는 편입니다.</li>
  <li>클라이언트에서 로드밸런서로 요청을 보낼 때, 최적의 서버로 요청을 전송하고, 그 결과를 클라이언트에게 전달합니다.</li>
  <li>요청 패킷에 대해 NAT도 수행하여 기록된 대상 IP 주소를 자체에서 선택한 컨텐츠 서버의 IP 주소로 변경합니다.</li>
</ul>

<h3 id="l7-load-balancer">L7 Load Balancer</h3>
<ul>
  <li>L7 Load Balancer는 URL, Payload, HTTP Header, Cookie 등의 내용을 기준으로 부하를 분산합니다. 따라서, 컨텐츠 기반 스위칭이라고도 말합니다.</li>
  <li>해당 계층에서의 로드밸런싱은 전송되는 정보의 양이 더 많기 때문에, L4 에서보다 비용이 더 많이 들게 되지만, 전체 효율성은 더욱 높습니다.</li>
  <li>클라이언트가 요청하는 데이터의 유형을 결정할 수 있기 때문입니다. 따라서, 모든 서버에 동일한 데이터를 복제할 필요가 없습니다.</li>
  <li>L4에서와 같이 트래픽을 패킷단위로 관리하는 것이 아닌, 요청과 응답을 전체적으로 읽고 관리할 수 있습니다.</li>
</ul>

<h2 id="osiopen-systems-interconnection-참조-모델">OSI(Open Systems Interconnection) 참조 모델</h2>
<p><strong>7 계층 - Application Layer</strong></p>
<ul>
  <li>사용자에게 보이는 부분으로, 최종 사용자에게 가장 가까운 계층으로, 사용자와 직접적으로 상호작용합니다.</li>
  <li>애플리케이션 목적에 맞는 통신 방법을 제공합니다.</li>
  <li>HTTP, DNS, SMTP, FTP등의 대표적인 프로토콜이 해당 레이어에 속합니다.</li>
</ul>

<p><strong>6 계층 - Presentation Layer</strong></p>
<ul>
  <li>애플리케이션 통신에서 메시지 포맷을 관리하는 계층입니다.</li>
  <li>데이터를 안전하게 전송하기 위해 암호화, 복호화하여 소통합니다.</li>
</ul>

<p><strong>5 게층 - Session Layer</strong></p>
<ul>
  <li>애플리케이션 통신에서 세션을 관리하는 계층입니다.</li>
  <li>예시로 RPC(remote procedure call)가 있습니다.</li>
</ul>

<p><strong>4 계층 - Transport Layer</strong></p>
<ul>
  <li>애플리케이션 통신을 담당하며, 실제로 목적지 애필리케이션으로 데이터를 전송합니다.</li>
  <li>TCP, UDP 프로토콜을 사용합니다.</li>
  <li>TCP: 안정적이고 신뢰할 수 있는 데이터 전송을 보장합니다.</li>
  <li>UDP: 데이터가 중간에 유실되거나 순서가 꼬일 수 있지만, 데이터를 무조건 전송합니다.</li>
  <li>Network Layer의 기능을 사용하여 데이터를 전송합니다.</li>
</ul>

<p><strong>3 계층 - Network Layer</strong></p>
<ul>
  <li>호스트 간의 통신을 담당합니다. (IP 프로토콜)</li>
  <li>목적지 호스트로 데이터를 전송합니다.</li>
  <li>네트워크 간의 최적의 경로를 결정합니다.</li>
  <li>Data Link Layer의 기능을 사용하여 기능을 구현합니다.</li>
</ul>

<p><strong>2 계층 - Data Link Layer</strong></p>
<ul>
  <li>IP 주소가 아닌 MAC 주소 기반으로 통신합니다.</li>
  <li>ARP: IP 주소를 MAC 주소로 변환하는 프로토콜입니다.</li>
</ul>

<p><strong>1 계층 - Physical Layer</strong></p>
<ul>
  <li>
    <p>bits 단위로 데이터를 전송합니다.</p>
  </li>
  <li>서로 다른 컴퓨터가 통신을 할 떄 역시, 7계층을 기반으로 통신합니다.</li>
  <li>라우터는 Network Layer, Data Link Layer, Physical Layer에 있는 프로토콜을 구현합니다.</li>
</ul>

<h2 id="참고">참고</h2>
<h2 id="amazon-elb">Amazon ELB</h2>
<ul>
  <li>AWS가 제공하는 로드 밸런서로, 집중되는 트래픽을 서버/네트워크에 분배하는 부하 분산 장치입니다.</li>
</ul>

<p><strong>ALB</strong></p>
<ul>
  <li>HTTP/HTTPS 프로토콜의 헤더를 보고 적절한 패킷으로 전송하므로, OSI 모형의 애플리케이션 계층(7계층)에서 동작합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">IP 주소 + 포트번호 + 패킷내용</code> 정보를 통해 스위칭합니다.</li>
  <li>L7단에서 지원하기 때문에 인스턴스와 로드 밸런서 사이에서 SSL이 적용된 암호화 통신이 가능합니다.</li>
  <li>IP 주소가 변동될 수 있기 때문에, Client는 DNS 주소로 접근하는 것이 좋습니다.<br />
(따라서, EIP를 ALB에 설정해두는 것이 좋습니다.)</li>
</ul>

<p><strong>NLB</strong></p>
<ul>
  <li>TCP/IP 프로토콜의 헤더를 보고 적절한 패킷으로 전송하므로, OSI 모형의 전송 계층(4계층)에서 동작합니다.<br />
(ALB보다 낮은 계층에서 동작하기 때문에 속도가 빠릅니다.)</li>
  <li><code class="language-plaintext highlighter-rouge">IP 주소 + 포트번호</code> 정보를 통해고 스위칭합니다.</li>
  <li>EIP를 이용할 수 있으며, DNS와 IP 주소 모두 사용 가능합니다. (SSL은 사용 불가능)</li>
</ul>

<h3 id="reference">reference</h3>
<ul>
  <li><a href="https://www.nginx.com/resources/glossary/layer-4-load-balancing/">Nginx 공식 홈페이지</a></li>
</ul>]]></content><author><name>Yeham Kim</name></author><category term="Study" /><summary type="html"><![CDATA[작성 계기 면접질문 중, nginx를 사용한 로드밸런싱이 OSI Layer의 어떤 계층에서 일어나는지에 대한 질문에 대해 대답하지 못해, 공부를 시작하게 되었습니다.]]></summary></entry></feed>